const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":132,\"nextId\":132,\"documentIds\":{\"0\":\"2\",\"1\":\"3\",\"2\":\"3#什么是代理\",\"3\":\"3#静态代理\",\"4\":\"3#动态代理\",\"5\":\"3#动态代理工厂\",\"6\":\"4\",\"7\":\"4#什么是spi机制\",\"8\":\"4#系统spi实现-demo\",\"9\":\"4#spi机制的应用场景\",\"10\":\"4#自定义spi机制实现\",\"11\":\"5\",\"12\":\"5#项目初始化\",\"13\":\"5#注解设计\",\"14\":\"5#enableyunrpc\",\"15\":\"5#yunrpcservice\",\"16\":\"5#yunrpcreference\",\"17\":\"5#注解驱动\",\"18\":\"5#全局启动类\",\"19\":\"5#提供者启动\",\"20\":\"5#消费者启动\",\"21\":\"5#注册已编写的启动类\",\"22\":\"5#测试\",\"23\":\"6\",\"24\":\"6#为什么要全局配置加载\",\"25\":\"6#如何设计\",\"26\":\"6#代码实现\",\"27\":\"7\",\"28\":\"7#代码优化说明\",\"29\":\"7#服务提供者启动类\",\"30\":\"7#服务消费者启动类\",\"31\":\"8\",\"32\":\"8#什么是容错机制\",\"33\":\"8#为什么要容错机制\",\"34\":\"8#容错机制有哪些\",\"35\":\"8#容错方案的设计\",\"36\":\"8#容错机制实现-1\",\"37\":\"8#容错策略接口定义\",\"38\":\"8#快速失败策略\",\"39\":\"8#静默处理策略\",\"40\":\"8#故障恢复策略\",\"41\":\"8#失败恢复策略\",\"42\":\"9\",\"43\":\"9#我们为什么要实现序列化\",\"44\":\"9#常见序列化器对比\",\"45\":\"9#几种常见的序列化和反序列化协议\",\"46\":\"9#接口定义\",\"47\":\"9#jdk\",\"48\":\"9#json\",\"49\":\"9#kryo\",\"50\":\"9#hessian\",\"51\":\"9#protobuf\",\"52\":\"9#avro\",\"53\":\"9#xml-soap\",\"54\":\"9#thrift\",\"55\":\"10\",\"56\":\"10#项目创建\",\"57\":\"10#导入依赖\",\"58\":\"10#接口与实现代码\",\"59\":\"10#common模块\",\"60\":\"10#provider模块\",\"61\":\"10#consumer模块\",\"62\":\"10#注解添加\",\"63\":\"10#yunrpcservice\",\"64\":\"10#yunrpcreference\",\"65\":\"10#enableyunrpc\",\"66\":\"10#测试\",\"67\":\"11\",\"68\":\"11#什么是接口mock服务\",\"69\":\"11#为什么要接口mock服务\",\"70\":\"11#mock服务实现\",\"71\":\"12\",\"72\":\"12#什么是注册中心\",\"73\":\"12#注册中心有哪些\",\"74\":\"12#注册中心设计\",\"75\":\"12#技术选型etcd\",\"76\":\"12#etcd介绍\",\"77\":\"12#服务元信息设计\",\"78\":\"12#注册中心配置\",\"79\":\"12#注册中心接口\",\"80\":\"12#etcd注册中心实现\",\"81\":\"12#全局变量\",\"82\":\"12#初始化\",\"83\":\"12#服务注册\",\"84\":\"12#服务取消注册\",\"85\":\"12#服务发现\",\"86\":\"12#服务销毁\",\"87\":\"12#心跳检测\",\"88\":\"12#服务监听\",\"89\":\"13\",\"90\":\"13#一些协议概念\",\"91\":\"13#为什么要自定义rpc协议\",\"92\":\"13#自定义rpc协议设计\",\"93\":\"13#网络传输设计\",\"94\":\"13#消息结构设计\",\"95\":\"13#代码实现\",\"96\":\"13#消息结构代码\",\"97\":\"13#消息编码\",\"98\":\"13#消息编码-1\",\"99\":\"13#消息解码\",\"100\":\"13#tcp服务器实现\",\"101\":\"13#tcp客户端实现\",\"102\":\"13#请求处理器-服务提供者\",\"103\":\"13#请求发送-服务消费者\",\"104\":\"13#半包粘包\",\"105\":\"13#什么是半包粘包\",\"106\":\"13#如何解决半包粘包问题\",\"107\":\"13#如何解决半包\",\"108\":\"13#如何解决粘包问题\",\"109\":\"14\",\"110\":\"14#什么是负载均衡\",\"111\":\"14#负载均衡类型\",\"112\":\"14#负载均衡算法实现\",\"113\":\"14#负载均衡接口定义\",\"114\":\"14#随机负载均衡器\",\"115\":\"14#轮询负载均衡器\",\"116\":\"14#一致性哈希负载均衡器\",\"117\":\"14#加权轮询-随机\",\"118\":\"14#平滑加权轮询\",\"119\":\"15\",\"120\":\"15#什么是重试机制\",\"121\":\"15#为什么要重试机制\",\"122\":\"15#重试机制有哪些\",\"123\":\"15#重试策略实现\",\"124\":\"15#重试策略接口定义\",\"125\":\"15#不重试策略\",\"126\":\"15#固定重试间隔策略\",\"127\":\"15#指数退避重试策略\",\"128\":\"15#线性重试策略\",\"129\":\"16\",\"130\":\"17\",\"131\":\"18\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,147],\"1\":[3],\"2\":[2,42],\"3\":[1,97],\"4\":[1,179],\"5\":[1,79],\"6\":[1],\"7\":[2,44],\"8\":[3,56],\"9\":[1,69],\"10\":[1,255],\"11\":[1,11],\"12\":[1,42],\"13\":[1],\"14\":[2,69],\"15\":[2,59],\"16\":[2,81],\"17\":[1],\"18\":[1,72],\"19\":[1,99],\"20\":[1,95],\"21\":[1,23],\"22\":[1,2],\"23\":[1],\"24\":[2,30],\"25\":[2,96],\"26\":[1,275],\"27\":[1],\"28\":[1,12],\"29\":[1,128],\"30\":[1,39],\"31\":[1],\"32\":[2,55],\"33\":[2,40],\"34\":[2,66],\"35\":[1,2],\"36\":[1,24],\"37\":[1,56],\"38\":[1,31],\"39\":[1,58],\"40\":[1,101],\"41\":[1,81],\"42\":[1],\"43\":[2,17],\"44\":[1,112],\"45\":[1],\"46\":[1,32],\"47\":[1,45],\"48\":[1,156],\"49\":[1,107],\"50\":[1,54],\"51\":[1,96],\"52\":[1,1],\"53\":[2,1],\"54\":[1,1],\"55\":[1,2],\"56\":[1,8],\"57\":[1,27],\"58\":[1],\"59\":[1,11],\"60\":[1,22],\"61\":[1,29],\"62\":[1],\"63\":[2,23],\"64\":[2,30],\"65\":[2,21],\"66\":[1,12],\"67\":[1],\"68\":[2,7],\"69\":[2,67],\"70\":[1,84],\"71\":[3],\"72\":[2,39],\"73\":[2,32],\"74\":[1,63],\"75\":[1,15],\"76\":[1,25],\"77\":[1,48],\"78\":[1,36],\"79\":[1,47],\"80\":[1],\"81\":[1,29],\"82\":[1,22],\"83\":[1,62],\"84\":[1,27],\"85\":[1,88],\"86\":[1,84],\"87\":[1,78],\"88\":[1,41],\"89\":[3],\"90\":[1,45],\"91\":[1,18],\"92\":[1,3],\"93\":[1,9],\"94\":[1,69],\"95\":[1],\"96\":[1,44],\"97\":[1,5],\"98\":[1,99],\"99\":[1,92],\"100\":[1,55],\"101\":[1,137],\"102\":[3,127],\"103\":[3,141],\"104\":[1],\"105\":[2,10],\"106\":[2],\"107\":[2,5],\"108\":[1,135],\"109\":[1],\"110\":[2,21],\"111\":[1,57],\"112\":[1,24],\"113\":[1,20],\"114\":[1,35],\"115\":[1,53],\"116\":[1,133],\"117\":[2,107],\"118\":[1,87],\"119\":[1],\"120\":[2,20],\"121\":[2,59],\"122\":[2,70],\"123\":[1,8],\"124\":[1,49],\"125\":[1,22],\"126\":[1,93],\"127\":[1,186],\"128\":[1,128],\"129\":[1,12],\"130\":[1,10],\"131\":[1,3]},\"averageFieldLength\":[1.2954545454545456,61.298595061372815],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"本次手写RPC框架参考了许多优秀的设计，如下：\",\"完整的RPC实现思路：\",\"从零开始实现简单 RPC 框架：https://www.cnblogs.com/chenchuxin\",\"RPC-Dubbo架构：https://ldbmcs.gitbook.io/java/fen-bu-shi-1/rpc/rpc-dubbo-de-jia-gou-yuan-li\",\"Dubbo官网：https://cn.dubbo.apache.org/zh-cn/overview/home/\",\"一起写个Dubbo：https://blog.csdn.net/qq_40856284/category_10138756.html\",\"简易版Dubbo构造：https://blog.csdn.net/qq_38685503/category_10794078.html\",\"关于RPC的一些问题：https://www.nowcoder.com/discuss/353159058410643456?sourceSSR=users 序列化方式解决方案：\",\"深入理解RPC框架的序列化方案：https://www.51cto.com/article/748249.html\",\"如何手撸一个较为完整的RPC框架：https://juejin.cn/post/6992867064952127524#heading-16\",\"简单RPC框架https://github.com/tychozzz/ltyzzz-rpc?tab=readme-ov-file\",\"如何实现一个RPC框架：https://www.cnblogs.com/whgk/p/14371290.html\",\"SPI机制部分：\",\"SPI机制：https://pdai.tech/md/java/advanced/java-advanced-spi.html\",\"Java SPI 机制详解:https://javaguide.cn/java/basis/spi.html\",\"Java SPI概念、实现原理、优缺点、应用场景、使用步骤、实战SPI案例:https://www.51cto.com/article/756685.html\",\"接口Mock部分\",\"接口Mock服务方案设计：https://blog.daraw.cn/2019/06/12/thrift-rpc-mock/\",\"基于动态代理 Mock dubbo 服务的实现方案：https://tech.youzan.com/ji-yu-dong-tai-dai-li-mock-dubbofu-wu-de-shi-xian-fang-an/\",\"负载均衡器\",\"负载均衡器：https://jonasx.com/archives/load-balancehttps://jonasx.com/archives/load-balance\",\"什么是负载均衡：https://www.codefather.cn/什么是负载均衡/\",\"重试与容错：\",\"利用Spring-Retry定制化你的RPC重试：https://kriszhang.com/spring-retry/\",\"详解-手写RPC框架（7）- 服务容错：https://blog.csdn.net/qq_18884633/article/details/132053496\",\"其他：\",\"剖析 | SOFARPC 框架之总体设计与扩展机制：https://mp.weixin.qq.com/s/ZKUmmFT0NWEAvba2MJiJfA\",\"10分钟带你彻底搞懂RPC架构：https://blog.csdn.net/belongtocode/article/details/118639448\"]},\"1\":{\"h\":\"RPC调用(代理)\"},\"2\":{\"h\":\"什么是代理？\",\"t\":[\"在 RPC (远程过程调用) 中,代理(Proxy)是一个非常重要的概念。代理对象是客户端用来调用远程服务的中间层,它可以帮助客户端屏蔽掉远程调用的细节。\",\"代理模式是一种常见的设计模式,它为一个对象提供一个替身,以控制对这个对象的访问。在 RPC 中,代理对象扮演着这样的角色:\",\"隐藏远程调用细节:\",\"客户端只需要调用代理对象的方法,而不需要关心远程服务的地址、协议、序列化等细节。\",\"代理对象会负责将客户端的请求转换为远程服务能够理解的格式,并将结果转换回客户端期望的格式。\",\"支持中间件功能:\",\"代理对象可以在转发请求和响应的过程中,增加额外的功能,如负载均衡、重试、熔断、监控等。\",\"这些功能都是在客户端感知不到的情况下完成的,提高了系统的可靠性和可扩展性。\",\"抽象客户端与服务端的耦合:\",\"客户端只需要依赖代理对象,而不需要直接依赖远程服务的接口定义。\",\"这样可以降低客户端与服务端的耦合度,提高系统的灵活性和可维护性。\",\"在 RPC 框架中,代理对象通常是由客户端动态生成的,使用了动态代理的技术。这样客户端可以无感知地调用远程服务,而代理对象会负责完成各种中间件功能,为客户端提供一个简单、可靠的远程调用接口。\"]},\"3\":{\"h\":\"静态代理\",\"t\":[\"静态代理就是自己去写一个实现类，但是这种办法缺点很明显，每个类都要去写实现类\",\"静态代理是在编译时就已经生成代理类的字节码文件。\",\"代理类的实现是手动编写的,需要实现与目标类相同的接口,并在内部调用目标类的方法。\",\"静态代理的优点是实现简单,可以在代理类中添加额外的功能。缺点是如果目标类有变化,则需要修改代理类的代码。\",\"在common模块里面，我们定一个接口UserService\",\"consumer通过静态代理调用，直接new出UserServiceProxy对象进行调用\",\"public class EasyConsumerExample { public static void main(String[] args) { UserServiceProxy userServiceProxy = new UserServiceProxy(); userServiceProxy.getNumber(); } } \",\"在consumer模块里面，我们实现静态代理UserServiceProxy\",\"/** * 静态代理 */ public class UserServiceProxy implements UserService { @Override public User getUser(User user) { // 指定序列化方式 JdkSerializer serializer = new JdkSerializer(); // 发送请求 RpcRequest rpcRequest = RpcRequest.builder() .serviceName(UserService.class.getName()) .methodName(\\\"getUser\\\") .parameterTypes(new Class[]{User.class}) .args(new Object[]{user}) .build(); try { byte[] bodyBytes = serializer.serialize(rpcRequest); byte[] result; String url = \\\"http://localhost:8080\\\"; try (HttpResponse httpResponse = HttpRequest.post(url).body(bodyBytes).execute()) { result = httpResponse.bodyBytes(); } RpcResponse rpcResponse = serializer.deserialize(result, RpcResponse.class); return (User) rpcResponse.getData(); } catch (IOException e) { e.printStackTrace(); } return null; } } \",\"上面的代码是通过http来请求拿到provider提供者的实现函数，具体在设置methodName为调用的函数\",\"// 发送请求 RpcRequest rpcRequest = RpcRequest.builder() .serviceName(UserService.class.getName()) .methodName(\\\"getUser\\\") .parameterTypes(new Class[]{User.class}) .args(new Object[]{user}) .build(); \",\"下面是provider提供的具体代码，也就是具体的操作\",\"public class UserServiceImpl implements UserService { public User getUser(User user) { System.out.println(\\\"UserServiceImpl.getUser username=\\\" + user.getName()); return user; } } \",\"当然，服务提供者也要提前把对应的实现类进行注册,否则将找不到实现类：\",\"public class EasyProviderExample { public static void main(String[] args) { LocalRegistry.register(UserService.class.getName(), UserServiceImpl.class); // 启动服务 VertxHttpServer server = new VertxHttpServer(); server.doStart(8080); } } \"]},\"4\":{\"h\":\"动态代理\",\"t\":[\"动态代理是在运行时通过反射机制动态地创建代理类的实例。\",\"动态代理不需要事先编写代理类的源码,而是在运行时根据需要动态生成代理类的字节码。\",\"动态代理的优点是灵活性高,可以很方便地对目标类进行功能增强,并且不需要修改目标类的代码。缺点是实现相对复杂,需要使用反射等高级编程技术。\",\"在 RPC 框架中,通常会采用动态代理的方式来实现客户端的代理对象。这样可以做到不修改客户端代码的情况下,就可以为目标服务添加各种中间件功能,如负载均衡、失败重试、熔断保护等。\",\"Java 中常见的动态代理实现方式有:\",\"JDK 动态代理:使用 java.lang.reflect.Proxy 类及其相关接口实现。\",\"CGLib 动态代理:使用字节码技术在运行时动态生成代理类。\",\"具体实现：\",\"/** * 动态代理 */ public class ServiceProxy implements InvocationHandler { // 指定序列化器 final Serializer serializer = SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer()); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 构造请求 RpcRequest rpcRequest = RpcRequest.builder() .serviceName(method.getDeclaringClass().getName()) .methodName(method.getName()) .parameterTypes(method.getParameterTypes()) .args(args) .build(); // 从注册中心获取服务提供者请求地址 RpcConfig rpcConfig = RpcApplication.getRpcConfig(); Registry registry = RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry()); ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); // 构造请求 String serviceName = method.getDeclaringClass().getName(); serviceMetaInfo.setServiceName(serviceName); serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION); List<ServiceMetaInfo> serviceMetaInfos = registry.serviceDiscovery(serviceMetaInfo.getServiceKey()); if (CollUtil.isEmpty(serviceMetaInfos)) { throw new RuntimeException(\\\"暂无可用服务提供者\\\"); } // 负载均衡 LoadBalancer loadBalancer = LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer()); HashMap<String, Object> requestParams = new HashMap<>(); requestParams.put(\\\"methodName\\\", rpcRequest.getMethodName()); ServiceMetaInfo metaInfo = loadBalancer.select(requestParams, serviceMetaInfos); // 发送TCP请求 // 使用重试策略 RpcResponse response ; try { RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy()); response = retryStrategy.doRetry(() -> { return VertxTcpClient.doRequest(rpcRequest, metaInfo); }); } catch (Exception e) { TolerantStrategy strategy = TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy()); // 构造上下文 Map<String, Object> context = new HashMap<>(); context.put(TolerantStrategyConstant.SERVICE_LIST, serviceMetaInfos); context.put(TolerantStrategyConstant.CURRENT_SERVICE, metaInfo); context.put(TolerantStrategyConstant.RPC_REQUEST, rpcRequest); response = strategy.doTolerant(context, e); } return response.getData(); } } \",\"解释：\",\"我们想要用动态代理，就需要去继承InvocationHandler接口，然后实现invoke方法\",\"ServiceProxy 类实现了 InvocationHandler 接口:\",\"InvocationHandler 是 Java 动态代理的核心接口,它定义了 invoke() 方法,当代理对象的方法被调用时,会自动调用这个方法。\",\"invoke() 方法的实现:\",\"在这个方法中,首先根据反射获取到的方法信息,构建了一个 RpcRequest 对象,包含了服务名、方法名、参数类型和参数值等信息。\",\"这个 RpcRequest 对象就是动态代理要封装和处理的核心请求信息。\",\"动态代理的功能实现:\",\"在 invoke() 方法中,我们看到了从注册中心查询服务提供者信息、负载均衡选择服务提供者、使用重试策略和容错策略执行 RPC 调用等功能。\",\"这些功能都是在动态代理层面实现的,客户端调用时无需关心这些细节,只需要调用代理对象的方法即可。\",\"返回结果处理:\",\"最后,invoke() 方法将服务提供者返回的 RpcResponse 对象转换为方法调用的返回结果,并返回给客户端。\",\"这段代码体现了动态代理的核心思想,即为客户端提供一个透明的代理层,在代理层面封装并处理 RPC 调用的各种细节,让客户端可以像调用本地方法一样使用远程服务,提高了系统的可靠性和可扩展性。\"]},\"5\":{\"h\":\"动态代理工厂\",\"t\":[\" public class ServiceProxyFactory { /** * 根据服务类获取代理对象 * * @param serviceClass * @param <T> * @return */ public static <T> T getProxy(Class<T> serviceClass) { if (RpcApplication.getRpcConfig().isMock()) { return getMockProxy(serviceClass); } return (T) Proxy.newProxyInstance( serviceClass.getClassLoader(), new Class[]{serviceClass}, new ServiceProxy() ); } /** * 根据服务类 获取Mock代理对象 * * @param serviceClass * @param <T> * @return */ public static <T> T getMockProxy(Class<T> serviceClass) { return (T) Proxy.newProxyInstance( serviceClass.getClassLoader(), new Class[]{serviceClass}, new MockServiceProxy() ); } } \",\"这个 ServiceProxyFactory 类提供了两个静态方法,用于生成 RPC 客户端的代理对象:\",\"getProxy(Class<T> serviceClass) 方法:\",\"该方法首先检查 RPC 配置是否开启了 Mock 模式。\",\"如果开启了 Mock 模式,则调用 getMockProxy() 方法生成一个 Mock 代理对象。\",\"如果未开启 Mock 模式,则使用 Java 动态代理创建一个 ServiceProxy 对象作为代理。\",\"getMockProxy(Class<T> serviceClass) 方法:\",\"该方法使用 Java 动态代理的方式,创建一个 MockServiceProxy 对象作为代理。\",\"动态代理的实现主要有两个步骤:\",\"创建动态代理实例:\",\"使用 Proxy.newProxyInstance() 方法创建动态代理实例。\",\"该方法需要传入三个参数: \",\"目标类的类加载器 (serviceClass.getClassLoader())\",\"目标类实现的接口数组 (new Class[]{serviceClass})\",\"实现 InvocationHandler 接口的代理类实例 (new ServiceProxy() 或 new MockServiceProxy())\",\"返回代理对象:\",\"Proxy.newProxyInstance() 方法返回一个动态生成的代理对象,该对象实现了目标类的所有接口方法。\",\"最后将这个代理对象强制转换为目标类型 (T) 并返回。\",\"通过这个 ServiceProxyFactory 类,客户端可以非常方便地获取到 RPC 服务的代理对象,无需关心代理对象的具体实现细节。如果需要切换到 Mock 模式,只需要在配置中开启 Mock 功能即可。\",\"这种代理工厂的设计模式可以很好地封装动态代理的创建逻辑,提高代码的可维护性和扩展性。同时,它也体现了面向接口编程的设计思想,客户端只需要依赖目标服务的接口,而不需要依赖具体的代理实现。\"]},\"6\":{\"h\":\"SPI服务发现机制实现\"},\"7\":{\"h\":\"什么是SPI机制？\",\"t\":[\"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。\",\"当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\",\"Java SPI 就是提供了这样一个机制：为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。\"]},\"8\":{\"h\":\"系统SPI实现(Demo)\",\"t\":[\"如图，我们在com.yunfei.rpc.spi目录下面 建三个类，\",\"public interface Animal { void eat(String food); } public class Cat implements Animal{ @Override public void eat(String food) { System.out.println(\\\"Cat eat\\\"+ food); } } public class Dog implements Animal { @Override public void eat(String food) { System.out.println(\\\"Dog eat \\\" + food); } } \",\"然后我们在META-INF/services目录下面去新建一个文件com.yunfei.rpc.spi.Animal,这个文件是接口全限定名的文件，里面放上我们需要用到的实现类\",\"我在这里写的是狗，而不是猫，然后编写测试代码：\",\"public static void main(String[] args) throws Exception { ServiceLoader<Animal> animalServiceLoader = ServiceLoader.load(Animal.class); for (Animal animal : animalServiceLoader) { animal.eat(\\\"shit\\\"); } } \",\"成功加载：\",\"现在，我在里面写两个实现类：\",\"运行结果：\",\"我们发现，现在就是两个类都可以加载了，这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。\"]},\"9\":{\"h\":\"SPI机制的应用场景\",\"t\":[\"以下为一些具体的应用场景，我们开发中国呢经常用到的框架基本都使用了java的SPI机制\",\"应用名称\",\"具体应用场景\",\"数据库驱动程序加载\",\"JDBC为了实现可插拔的数据库驱动，在Java.sql.Driver接口中定义了一组标准的API规范，而具体的数据库厂商则需要实现这个接口，以提供自己的数据库驱动程序。在Java中，JDBC驱动程序的加载就是通过SPI机制实现的。\",\"日志框架的实现\",\"流行的开源日志框架，如Log4j、SLF4J和Logback等，都采用了SPI机制。用户可以根据自己的需求选择合适的日志实现，而不需要修改代码。\",\"Spring框架\",\"Spring框架中的Bean加载机制就使用了SPI思想，通过读取classpath下的META-INF/spring.factories文件来加载各种自定义的Bean。\",\"Dubbo框架\",\"Dubbo框架也使用了SPI思想，通过接口注解@SPI声明扩展点接口，并在classpath下的META-INF/dubbo目录中提供实现类的配置文件，来实现扩展点的动态加载。\",\"MyBatis框架\",\"MyBatis框架中的插件机制也使用了SPI思想，通过在classpath下的META-INF/services目录中存放插件接口的实现类路径，来实现插件的加载和执行。\",\"Netty框架\",\"Netty框架也使用了SPI机制，让用户可以根据自己的需求选择合适的网络协议实现方式。\",\"Hadoop框架\",\"Hadoop框架中的输入输出格式也使用了SPI思想，通过在classpath下的META-INF/services目录中存放输入输出格式接口的实现类路径，来实现输入输出格式的灵活配置和切换。\",\"Spring的SPI机制相对于Java原生的SPI机制进行了改造和扩展，主要体现在以下几个方面：\",\"支持多个实现类：Spring的SPI机制允许为同一个接口定义多个实现类，而Java原生的SPI机制只支持单个实现类。这使得在应用程序中使用Spring的SPI机制更加灵活和可扩展。\",\"支持自动装配：Spring的SPI机制支持自动装配，可以通过将实现类标记为Spring组件（例如@Component），从而实现自动装配和依赖注入。这在一定程度上简化了应用程序中服务提供者的配置和管理。\",\"支持动态替换：Spring的SPI机制支持动态替换服务提供者，可以通过修改配置文件或者其他方式来切换服务提供者。而Java原生的SPI机制只能在启动时加载一次服务提供者，并且无法在运行时动态替换。\",\"提供了更多扩展点：Spring的SPI机制提供了很多扩展点，例如BeanPostProcessor、BeanFactoryPostProcessor等，可以在服务提供者初始化和创建过程中进行自定义操作。\"]},\"10\":{\"h\":\"自定义SPI机制实现\",\"t\":[\"指定SPI的配置目录位置\",\"系统内置的SPI机制会加载resources/META-INFO/services目录，我们自定义的目录位置可以放在resources/META-INFO/rpc，还可以在这个目录下面继续细分，用户自定义SPIrpc/custom，我们系统内置的SPI：rpc/custom\",\"在配置文件中编写我们之前实现的类，如序列化器\",\"格式为：key=value\",\"编写工具类，用来读取配置并加载实现类的方法\",\"package com.yunfei.rpc.spi; import cn.hutool.core.io.resource.ResourceUtil; import com.yunfei.rpc.serializer.Serializer; import lombok.extern.slf4j.Slf4j; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; /** * SPI加载器 （支持键值对映射） */ @Slf4j public class SpiLoader { /** * 存储已加载的类：接口名=>（key=>实现类） */ private static Map<String, Map<String, Class<?>>> loaderMap = new ConcurrentHashMap<>(); /** * 对象实例缓存 避免重放new 类路径=> 对象实例 ，单例模式 */ private static Map<String, Object> instanceCache = new ConcurrentHashMap<>(); /** * 系统 SPI 目录 */ private static final String RPC_SYSTEM_SPI_DIR = \\\"META-INF/rpc/system/\\\"; /** * 用户自定义SPI目录 */ private static final String RPC_CUSTOM_SPI_DIR = \\\"META-INF/rpc/custom/\\\"; /** * 扫描路径 */ private static final String[] SCAN_DIRS = new String[]{ RPC_SYSTEM_SPI_DIR, RPC_CUSTOM_SPI_DIR, }; /** * 动态加载的类列表 */ private static final List<Class<?>> LOAD_CLASS_LIST = Arrays.asList(Serializer.class); /** * 加载所有类型 */ public static void loadAll() { log.info(\\\"加载所有的SPI\\\"); for (Class<?> aClass : LOAD_CLASS_LIST) { load(aClass); } } /** * 加载某个类型 * * @param loadClass * @return */ public static Map<String, Class<?>> load(Class<?> loadClass) { log.info(\\\"加载类型为 {} 的SPI\\\", loadClass.getName()); // 扫描路径，用户自定义的SPI 优先级高于系统SPI HashMap<String, Class<?>> keyClassMap = new HashMap<>(); for (String scanDir : SCAN_DIRS) { log.info(\\\"扫描路径为 {}\\\", scanDir + loadClass.getName()); List<URL> resources = ResourceUtil.getResources(scanDir + loadClass.getName()); // 读取每个资源文件 for (URL resource : resources) { try { InputStreamReader inputStreamReader = new InputStreamReader(resource.openStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { String[] split = line.split(\\\"=\\\"); if (split.length < 2) { log.error(\\\"SPI配置文件格式错误\\\"); continue; } String key = split[0]; String className = split[1]; log.info(\\\"加载 {} SPI配置文件 key={} className={}\\\", scanDir.equals(RPC_CUSTOM_SPI_DIR) ? \\\"自定义\\\" : \\\"系统\\\", key, className); keyClassMap.put(key, Class.forName(className)); } } catch (Exception e) { log.error(\\\"加载SPI配置文件失败\\\", e); } } } loaderMap.put(loadClass.getName(), keyClassMap); return keyClassMap; } /** * 获取某个类型的实例 * * @param tClass * @param key * @param <T> 类型 */ public static <T> T getInstance(Class<?> tClass, String key) { String tClassName = tClass.getName(); Map<String, Class<?>> keyClassMap = loaderMap.get(tClassName); if (keyClassMap == null) { throw new RuntimeException(String.format(\\\"SpiLoader 未加载%s 类型\\\", tClassName)); } if (!keyClassMap.containsKey(key)) { throw new RuntimeException(String.format(\\\"SpiLoader 的 %s不存在 key= %s\\\", tClassName, key)); } // 获取到要加载的实现类型 Class<?> implClass = keyClassMap.get(key); // 从实例缓存中加载指定类型的实例 String implClassName = implClass.getName(); if (!instanceCache.containsKey(implClassName)) { try { instanceCache.put(implClassName, implClass.newInstance()); } catch (InstantiationException | IllegalAccessException e) { String format = String.format(\\\"实例化 %s 失败\\\", implClassName); throw new RuntimeException(format, e); } } return (T) instanceCache.get(implClassName); } } \",\"对代码的一些解释：\",\"/** * 存储已加载的类：接口名=>（key=>实现类） */ private static Map<String, Map<String, Class<?>>> loaderMap = new ConcurrentHashMap<>(); /** * 对象实例缓存 避免重放new 类路径=> 对象实例 ，单例模式 */ private static Map<String, Object> instanceCache = new ConcurrentHashMap<>(); \",\"这里的loaderMap是存放 接口=>实现类的映射\",\"instanceCache是存放key对应的类的实例\",\"InputStreamReader inputStreamReader = new InputStreamReader(resource.openStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { String[] split = line.split(\\\"=\\\"); if (split.length < 2) { log.error(\\\"SPI配置文件格式错误\\\"); continue; } String key = split[0]; String className = split[1]; keyClassMap.put(key, Class.forName(className)); } \",\"这里 是按行读取，用=分割，\",\"例如读取到的结果为：jdk=com.yunfei.rpc.serializer.JdkSerializer\",\"然后使用Class.forName(className)进行动态加载类，className为 com.yunfei.rpc.serializer.JdkSerializer\",\"Class.forName(className) 方法只是返回一个表示指定类的 Class 对象,并不会实例化这个类的对象。\",\"返回 Class 对象\",\"Class.forName(className) 方法会根据传入的类名动态加载并返回一个 Class 对象。\",\"这个 Class 对象可以用来进行各种反射操作,如获取类的成员、创建实例等。\",\"不会实例化对象\",\"Class.forName(className) 方法只是加载并返回 Class 对象,并不会创建该类的实例。\",\"如果要创建类的实例,需要使用 Class 对象的 newInstance() 方法或通过构造函数反射来实例化。\",\"在 SPI 加载器的实现中,Class.forName(className) 只是用来加载 SPI 实现类的 Class 对象,并将其存储在 keyClassMap 中。真正的实例化操作是在 getInstance() 方法中完成的,通过 newInstance() 或反射的方式创建 SPI 实现类的实例,并缓存起来。\",\"这种分离加载和实例化的设计,可以让 SPI 加载器更加灵活和高效。只有当需要使用 SPI 实现时,才会触发实例化操作,避免了不必要的资源消耗。具体的代码如下 ：\",\"// 获取到要加载的实现类型 Class<?> implClass = keyClassMap.get(key); // 从实例缓存中加载指定类型的实例 String implClassName = implClass.getName(); if (!instanceCache.containsKey(implClassName)) { try { instanceCache.put(implClassName, implClass.newInstance()); } catch (InstantiationException | IllegalAccessException e) { String format = String.format(\\\"实例化 %s 失败\\\", implClassName); throw new RuntimeException(format, e); } } return (T) instanceCache.get(implClassName); \",\"测试：\",\" @Test void load() { Map<String, Class<?>> classMap = SpiLoader.load(Serializer.class); for (Map.Entry<String, Class<?>> entry : classMap.entrySet()) { System.out.println(entry.getKey() + \\\" : \\\" + entry.getValue()); } } @Test void getInstance() { this.load(); Object jdk = SpiLoader.getInstance(Serializer.class, \\\"jdk\\\"); System.out.println(jdk); } \",\"运行结果，可以看到先扫描系统目录，再扫描用户目录，会覆盖系统设置，同时也可以获取 到实例对象：\",\"针对Serializer使用工厂单例模式：\",\"public class SerializerFactory { static { SpiLoader.load(Serializer.class); } /** * 获取序列化器 */ public static Serializer getInstance(String key) { return SpiLoader.getInstance(Serializer.class, key); } } \"]},\"11\":{\"h\":\"SpringBoot注解驱动设计\",\"t\":[\"在Dubbo中，我们想要使用Dubbo框架的RPC远程调用功能，主要有三步：\",\"在启动类上加@EnableDubbo\",\"在提供方类上加：@DubboService\",\"在消费者注入的类上加：@DubboReference\",\"我们参考Dubbo，也开发这样三个注解就可以使用整个RPC框架\"]},\"12\":{\"h\":\"项目初始化\",\"t\":[\"新建一个SpringBoot项目，加入相关依赖，插件，以及build都不需要\",\"<properties> <java.version>17</java.version> </properties> <dependencies> <dependency> <groupId>org.apache.dubbo</groupId> <artifactId>dubbo</artifactId> <version>3.0.9</version> </dependency> <dependency> <groupId>com.yunfei</groupId> <artifactId>yunfei-rpc-core</artifactId> <version>1.0-SNAPSHOT</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-configuration-processor</artifactId> <optional>true</optional> </dependency> </dependencies> \",\"这个插件的主要作用是用户在写yml的时候可以有注释\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-configuration-processor</artifactId> <optional>true</optional> </dependency> \"]},\"13\":{\"h\":\"注解设计\"},\"14\":{\"h\":\"@EnableYunRpc\",\"t\":[\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Import({RpcInitBootStrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class}) public @interface EnableYunRpc { /** * 需要启动server * * @return */ boolean needServer() default true; } \",\"@EnableYunRpc 注解的设计:\",\"@Target({ElementType.TYPE}):\",\"这个注解用于指定 @EnableYunRpc 注解可以被应用于哪些程序元素。在这里,它被限定为只能应用于类型(Type)级别,也就是类、接口或枚举。\",\"@Retention(RetentionPolicy.RUNTIME):\",\"这个注解用于指定 @EnableYunRpc 注解的保留策略。RUNTIME 表示该注解会在运行时被 JVM 读取和使用,可以被反射机制访问。\",\"@Import({RpcInitBootStrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class}):\",\"这个注解用于导入其他配置类。在这里,它导入了三个引导类: \",\"RpcInitBootStrap: RPC 应用程序的初始化引导类。\",\"RpcProviderBootstrap: RPC 服务提供者的引导类。\",\"RpcConsumerBootstrap: RPC 服务消费者的引导类。\",\"当 @EnableYunRpc 注解被应用到一个类上时,Spring 容器会自动注册这三个引导类。\",\"public @interface EnableYunRpc {}:\",\"这是一个自定义注解的声明,名为 @EnableYunRpc。通过这个注解,开发者可以在自己的应用程序中开启 RPC 相关的功能。\",\"boolean needServer() default true;:\",\"这是 @EnableYunRpc 注解中定义的一个属性。它用于指定是否需要启动 RPC 服务端。默认值为 true。\",\"开发者可以通过设置这个属性的值来决定是否需要启动 RPC 服务端,例如在仅作为 RPC 客户端的场景下,可以将其设置为 false。\",\"这个 @EnableYunRpc 注解是一个基于 Spring 的注解驱动设计模式,它可以帮助开发者快速地在自己的应用程序中集成 RPC 功能。通过将引导类的注册和初始化过程封装在这个注解中,开发者只需要简单地在入口类上添加该注解,就可以自动完成 RPC 相关的配置和初始化。\"]},\"15\":{\"h\":\"@YunRpcService\",\"t\":[\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Component public @interface YunRpcService { /** * 服务接口类 * * @return */ Class<?> interfaceClass() default void.class; /** * 服务版本 * * @return */ String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION; } \",\"@YunRpcService 注解主要用于标注 RPC 服务提供者。\",\"@Target({ElementType.TYPE}):\",\"这个元注解指定了 @YunRpcService 注解可以被应用于类型(Type)级别,也就是类、接口或枚举。\",\"@Retention(RetentionPolicy.RUNTIME):\",\"这个元注解指定了 @YunRpcService 注解的保留策略是在运行时被 JVM 读取和使用。\",\"@Component:\",\"这个元注解将 @YunRpcService 注解标记为 Spring 组件,意味着被这个注解标注的类会被 Spring 容器自动扫描和注册。\",\"public @interface YunRpcService {}:\",\"这是 @YunRpcService 注解本身的声明。它定义了这个注解的名称和作用域。\",\"Class<?> interfaceClass() default void.class;:\",\"这是 @YunRpcService 注解定义的一个属性,用于指定服务接口类。\",\"如果不设置该属性,默认值为 void.class。\",\"String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION;:\",\"这是 @YunRpcService 注解定义的另一个属性,用于指定服务的版本号。\",\"如果不设置该属性,默认值为 RpcConstant.DEFAULT_SERVICE_VERSION。\",\"@YunRpcService 注解的设计目的是为了简化 RPC 服务提供者的配置。当一个类被这个注解标注时,Spring 容器会自动扫描并注册该服务,同时也会提取服务接口类和版本号等元信息。这些信息可以在后续的服务发现和调用过程中使用。\"]},\"16\":{\"h\":\"@YunRpcReference\",\"t\":[\"@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface YunRpcReference { /** * 服务接口类 * @return */ Class<?> interfaceClass() default void.class; /** * 服务版本 * @return */ String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION; /** * 负载均衡策略 * @return */ String loadBalancer() default LoadBalancerKeys.ROUND_ROBIN; /** * 重试策略 * @return */ String retryStrategy() default RetryStrategyKeys.NO; /** * 容错策略 * @return */ String tolerantStrategy() default TolerantStrategyKeys.FAIL_FAST; /** * 是否mock * @return */ boolean mock() default false; } \",\"这个 @YunRpcReference 注解是用于标注 RPC 服务消费者端的注解。\",\"@Target({ElementType.FIELD}):\",\"这个元注解指定了 @YunRpcReference 注解只能被应用在字段(Field)级别。\",\"@Retention(RetentionPolicy.RUNTIME):\",\"这个元注解指定了 @YunRpcReference 注解的保留策略是在运行时被 JVM 读取和使用。\",\"public @interface YunRpcReference {}:\",\"这是 @YunRpcReference 注解本身的声明。它定义了这个注解的名称和作用域。\",\"Class<?> interfaceClass() default void.class;:\",\"这是 @YunRpcReference 注解定义的一个属性,用于指定服务接口类。\",\"如果不设置该属性,默认值为 void.class。\",\"String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION;:\",\"这是 @YunRpcReference 注解定义的另一个属性,用于指定服务的版本号。\",\"如果不设置该属性,默认值为 RpcConstant.DEFAULT_SERVICE_VERSION。\",\"String loadBalancer() default LoadBalancerKeys.ROUND_ROBIN;:\",\"这是 @YunRpcReference 注解定义的一个属性,用于指定负载均衡策略。\",\"如果不设置该属性,默认值为 LoadBalancerKeys.ROUND_ROBIN。\",\"String retryStrategy() default RetryStrategyKeys.NO;:\",\"这是 @YunRpcReference 注解定义的一个属性,用于指定重试策略。\",\"如果不设置该属性,默认值为 RetryStrategyKeys.NO。\",\"String tolerantStrategy() default TolerantStrategyKeys.FAIL_FAST;:\",\"这是 @YunRpcReference 注解定义的一个属性,用于指定容错策略。\",\"如果不设置该属性,默认值为 TolerantStrategyKeys.FAIL_FAST。\",\"boolean mock() default false;:\",\"这是 @YunRpcReference 注解定义的一个属性,用于指定是否使用 Mock 模式。\",\"如果不设置该属性,默认值为 false。\",\"总的来说,@YunRpcReference 注解的设计目的是为了简化 RPC 服务消费者的配置。当一个字段被这个注解标注时,Spring 容器会自动注入一个代理对象,该代理对象会负责执行 RPC 调用。开发者可以通过设置注解属性来配置负载均衡、重试、容错等策略,以满足不同的业务需求。\"]},\"17\":{\"h\":\"注解驱动\"},\"18\":{\"h\":\"全局启动类\",\"t\":[\"我们希望在Spring框架初始化的时候，能够获取@EnableYunRpc注解，并且初始化RPC框架。\",\"可以使用Spring的ImportBeanDefinitionRegistrar接口来实现，此接口用于在 Spring 容器初始化时执行自定义的注册逻辑。\",\"具体的自定义的注册逻辑写在registerBeanDefinitions方法里面\",\"@Slf4j public class RpcInitBootStrap implements ImportBeanDefinitionRegistrar { /** * Spring初始化执行时候，初始化Rpc框架 * * @param importingClassMetadata * @param registry */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 获取EnableRpc 注解的属性值 boolean needServer = (boolean) importingClassMetadata.getAnnotationAttributes(EnableYunRpc.class.getName()).get(\\\"needServer\\\"); // Rpc框架初始化（配置和注册中心） RpcApplication.init(); final RpcConfig rpcConfig = RpcApplication.getRpcConfig(); // 启动服务器 if (needServer) { VertxTcpServer vertxTcpServer = new VertxTcpServer(); vertxTcpServer.doStart(rpcConfig.getServerPort()); } else { log.info(\\\"Rpc server is not started\\\"); } } } \",\"这个 RpcInitBootStrap 类负责在 Spring 容器初始化时执行 RPC 框架的初始化和服务端启动逻辑。\",\"它利用 @EnableYunRpc 注解中的 needServer 属性,来决定是否需要启动 RPC 服务端。这种设计可以让 RPC 框架在 Spring Boot 应用中更加灵活和可配置。\"]},\"19\":{\"h\":\"提供者启动\",\"t\":[\"提供者需要获取到所有包含@YunRpcService的注解的类，然后利用反射机制，获取到对应的注册信息，完成服务信息的注册。\",\"我们让启动类实现BeanPostProcessor接口里的postProcessAfterInitialization方法，就可以在服务提供者Bean初始化之后，执行注册服务等操作了。\",\"public class RpcProviderBootstrap implements BeanPostProcessor { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { Class<?> beanClass = bean.getClass(); YunRpcService rpcService = beanClass.getAnnotation(YunRpcService.class); if (rpcService != null) { // 需要注册服务 // 获取服务基本信息 Class<?> interfaceClass = rpcService.interfaceClass(); // 默认值处理 if (interfaceClass == void.class) { interfaceClass = beanClass.getInterfaces()[0]; } String serviceName = interfaceClass.getName(); String serviceVersion = rpcService.serviceVersion(); // 注册服务 // 本地注册 LocalRegistry.register(serviceName, beanClass); // 全局配置 final RpcConfig rpcConfig = RpcApplication.getRpcConfig(); // 注册到注册中心 RegistryConfig registryConfig = rpcConfig.getRegistryConfig(); Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry()); ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); serviceMetaInfo.setServiceName(serviceName); serviceMetaInfo.setServiceVersion(serviceVersion); serviceMetaInfo.setServiceHost(rpcConfig.getServerHost()); serviceMetaInfo.setServicePort(rpcConfig.getServerPort()); try { registry.register(serviceMetaInfo); } catch (Exception e) { throw new RuntimeException(e); } } return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); } } \",\"获取服务基本信息:\",\"首先从 @YunRpcService 注解中获取 interfaceClass 属性的值。这个属性指定了服务的接口类。\",\"如果 interfaceClass 的值为 void.class(默认值),则说明开发者没有手动指定接口类,于是取当前 Bean 实例的第一个接口作为服务接口。\",\"使用服务接口类的名称作为 serviceName。\",\"从 @YunRpcService 注解中获取 serviceVersion 属性的值。\",\"本地注册服务:\",\"使用 LocalRegistry.register(serviceName, beanClass) 方法将服务信息注册到本地注册表中。这样在后续的 RPC 调用中,就可以从本地注册表中获取到服务的实现类。\"]},\"20\":{\"h\":\"消费者启动\",\"t\":[\"RpcConsumerBootstrap 类是 RPC 服务消费者的引导类,它同样实现了 Spring 的 BeanPostProcessor 接口。它的主要作用是在 Spring 容器初始化 Bean 实例后,检查这些 Bean 中是否有被 @YunRpcReference 注解标注的字段,如果有,则为这些字段生成代理对象并注入。\",\"public class RpcConsumerBootstrap implements BeanPostProcessor { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { Class<?> beanClass = bean.getClass(); // 遍历对象的所有属性 Field[] declaredFields = beanClass.getDeclaredFields(); for (Field field : declaredFields) { YunRpcReference rpcReference = field.getAnnotation(YunRpcReference.class); if (rpcReference != null) { // 为属性生成代理对象 Class<?> interfaceClass = rpcReference.interfaceClass(); if (interfaceClass == void.class) { interfaceClass = field.getType(); } System.out.println(\\\"生成代理对象:\\\" + interfaceClass.getName()+\\\" \\\"+field.getType()); field.setAccessible(true); log.info(\\\"生成代理对象:{}\\\", interfaceClass.getName()); Object proxy = ServiceProxyFactory.getProxy(interfaceClass); try { field.set(bean, proxy); field.setAccessible(false); } catch (IllegalAccessException e) { System.out.println(\\\"生成代理对象失败\\\"); throw new RuntimeException(e); } } } return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); } } \",\"让我们逐步解析这个类的实现:\",\"Field[] declaredFields = beanClass.getDeclaredFields();:这行代码获取当前 Bean 实例的所有声明字段。\",\"YunRpcReference rpcReference = field.getAnnotation(YunRpcReference.class);:如果字段被 @YunRpcReference 注解标注,则获取该注解实例。\",\"if (rpcReference != null) { ... }: \",\"如果字段被 @YunRpcReference 注解标注,则执行以下逻辑: \",\"获取服务接口类,如果未指定则默认使用字段类型。\",\"使用 ServiceProxyFactory.getProxy(interfaceClass) 方法为服务接口生成代理对象。\",\"将生成的代理对象设置到当前 Bean 实例的字段上。\",\"return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);: \",\"最后,调用父类 BeanPostProcessor 的 postProcessAfterInitialization() 方法,确保其他 BeanPostProcessor 实现也能正确执行。\"]},\"21\":{\"h\":\"注册已编写的启动类\",\"t\":[\"最后还需要在启动类上面使用@Import到注册我们自定义的启动类\",\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Import({RpcInitBootStrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class}) public @interface EnableYunRpc { /** * 需要启动server * * @return */ boolean needServer() default true; } \"]},\"22\":{\"h\":\"测试\",\"t\":[\"见快速入门：快速入门\"]},\"23\":{\"h\":\"全局配置加载\"},\"24\":{\"h\":\"为什么要全局配置加载？\",\"t\":[\"在开发 RPC 框架时需要引入全局配置加载的功能主要有以下几个原因:\",\"配置信息繁多:\",\"RPC 框架需要涉及很多配置信息,如注册中心地址、序列化方式、网络服务端口号等。\",\"如果直接在代码中硬编码这些配置,不利于后期维护和扩展。\",\"支持自定义配置:\",\"RPC 框架需要被其他项目引入使用,作为服务提供者或消费者。\",\"引入框架的项目应该能够通过配置文件自定义 RPC 框架的配置,而不是强制使用框架中的硬编码配置。\",\"统一配置管理:\",\"服务提供者和服务消费者需要使用相同的 RPC 框架配置,以保证网络通信的一致性。\",\"因此需要一个统一的全局配置对象,方便框架内部各组件快速获取一致的配置信息。\",\"配置文件读取:\",\"RPC 框架需要能够从配置文件中读取配置信息,并将其转换为Java对象。\",\"使用通用的配置读取工具(如Hutool)可以简化这个过程,提高代码复用性。\"]},\"25\":{\"h\":\"如何设计？\",\"t\":[\"参考Dubbo的设计方案：https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/overview/\",\"在本RPC框架中，我们主要做了以下一些配置：\",\"RpcConfig 类是 RPC 框架的全局配置类,它包含了 RPC 框架中很多重要的配置项。\",\"名称和版本:\",\"name 和 version 属性用于标识 RPC 框架的名称和版本号。这些信息可以在日志、监控等场景中使用。\",\"服务器配置:\",\"serverHost 和 serverPort 定义了 RPC 服务器的主机和端口信息。这是 RPC 服务提供者端的必要配置。\",\"模拟调用:\",\"mock 属性用于控制是否开启模拟调用模式,可在测试或者特殊场景下使用。\",\"序列化配置:\",\"serializer 属性指定了默认的序列化实现,可以选择 SerializerKeys 中定义的不同序列化方式,如 JDK、Kryo 等。\",\"注册中心配置:\",\"registryConfig 属性包含了服务注册中心的配置信息,如地址、凭证等。这是 RPC 的关键功能之一。\",\"负载均衡配置:\",\"loadBalancer 属性指定了默认的负载均衡策略,可以选择 LoadBalancerKeys 中定义的不同策略,如轮询、随机等。\",\"容错策略配置:\",\"retryStrategy 属性用于配置服务调用的重试策略,如 RetryStrategyKeys 中定义的不重试、有限重试等。\",\"tolerantStrategy 属性用于配置服务调用的容错策略,如 TolerantStrategyKeys 中定义的快速失败、熔断等。\",\"这个 RpcConfig 类将 RPC 框架中的各种重要配置项集中在一起,使得整个框架的配置管理更加集中和便捷。开发者可以根据具体需求,灵活地配置不同的序列化、负载均衡、容错等策略,从而满足不同应用场景的需求。\",\"为了更直观表示我们整个系统的配置，我画了一张框架图：\",\"上面这些只是Rpc的配置，除此之外，我们还需要一个RpcApplication 类来管理 RPC 框架的入口和全局配置管理器，我们希望在里面可以集中管理这些配置选项，并且可以轻松获取这些选项，例如\",\"初始化Rpc配置信息\",\"通过单例模式来获取上述的Rpc配置信息\"]},\"26\":{\"h\":\"代码实现\",\"t\":[\"RpcConfig类代码如下：\",\"/** * RPC配置 */ @Data public class RpcConfig { /** * 名称 */ private String name = \\\"yunfei-rpc\\\"; /** * 版本号 */ private String version = \\\"1.0\\\"; /** * 服务器主机 */ private String serverHost = \\\"localhost\\\"; /** * 服务器端口 */ private int serverPort = 8080; /** * 模拟调用 */ private boolean mock = false; /** * 序列化器 */ private String serializer = SerializerKeys.JDK; /** * 注册中心配置 */ private RegistryConfig registryConfig = new RegistryConfig(); /** * 负载均衡器 */ private String loadBalancer = LoadBalancerKeys.ROUND_ROBIN; /** * 重试策略 */ private String retryStrategy = RetryStrategyKeys.NO; /** * 容错策略 */ private String tolerantStrategy = TolerantStrategyKeys.FAIL_FAST; } \",\"RpcApplication类：\",\" /** * RPC应用 * 相当于holder ,存放了项目全局用到的变量，双检锁实现单例 */ @Slf4j public class RpcApplication { private static volatile RpcConfig rpcConfig; public static void init(RpcConfig newRpcConfig) { rpcConfig = newRpcConfig; log.info(\\\"rpc application init success,config:{}\\\", rpcConfig); // // 注册中心初始化 RegistryConfig registryConfig = rpcConfig.getRegistryConfig(); Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry()); registry.init(registryConfig); log.info(\\\"registry init success,config:{}\\\", registryConfig); // 创建并 注册Shutdown Hook ,JVM 退出时执行擦欧总 Runtime.getRuntime().addShutdownHook(new Thread(registry::destroy)); } /** * 初始化 */ public static void init() { RpcConfig newRpcConfig; try { newRpcConfig = ConfigUtils.loadConfig(RpcConfig.class, RpcConstant.DEFAULT_CONFIG_PREFIX); } catch (Exception e) { // 读取配置文件失败，使用默认配置 log.error(\\\"load config error,use default config\\\", e); newRpcConfig = new RpcConfig(); } init(newRpcConfig); } /** * 获取配置 */ public static RpcConfig getRpcConfig() { if (rpcConfig == null) { synchronized (RpcApplication.class) { if (rpcConfig == null) { init(); } } } return rpcConfig; } } \",\"代码解释：\",\"单例模式实现: \",\"rpcConfig 是一个静态的 volatile 变量,用于存储全局的 RpcConfig 配置对象。\",\"getRpcConfig() 方法使用了双重检查锁的单例模式实现,确保 rpcConfig 对象的唯一性。\",\"初始化方法: \",\"init(RpcConfig newRpcConfig) 方法用于初始化 RPC 应用,接受一个 RpcConfig 对象作为参数。\",\"然后根据 registryConfig 创建并初始化注册中心实例。\",\"最后注册一个 JVM 关闭钩子,在 JVM 退出时自动销毁注册中心实例。\",\"自动初始化: \",\"init() 方法用于自动初始化 RPC 应用。\",\"首先尝试使用 ConfigUtils.loadConfig() 方法从默认的配置文件路径加载 RpcConfig 对象。\",\"如果加载失败,则创建一个默认的 RpcConfig 对象。\",\"这个 RpcApplication 类是整个 RPC 框架的核心入口点。它负责管理全局的 RpcConfig 配置对象,同时还负责初始化注册中心实例并确保其生命周期与 JVM 保持一致。这种设计模式能够确保整个 RPC 框架的配置管理和初始化过程是统一和可靠的。\",\"我们再来看看如何从配置文件中读取信息：\",\" newRpcConfig = ConfigUtils.loadConfig(RpcConfig.class, RpcConstant.DEFAULT_CONFIG_PREFIX); \",\"对于propertities文件的读取比较 简单，可以直接使用Hutool工具类实现：\",\"public static <T> T loadConfig(Class<T> tClass, String prefix, String environment) { StringBuilder configFileBuilder = new StringBuilder(\\\"application\\\"); if (StrUtil.isNotBlank(environment)) { configFileBuilder.append(\\\"-\\\").append(environment); } configFileBuilder.append(\\\".properties\\\"); Props props = new Props(configFileBuilder.toString()); return props.toBean(tClass, prefix); } \",\"读取yml文件需要引入依赖：\",\" <dependency> <groupId>org.yaml</groupId> <artifactId>snakeyaml</artifactId> <version>1.29</version> </dependency> \",\"读取配置文件的完整代码如下：\",\"参考：github\",\"package com.yunfei.rpc.utils; import cn.hutool.core.io.resource.NoResourceException; import cn.hutool.core.util.StrUtil; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import cn.hutool.setting.dialect.Props; import cn.hutool.setting.yaml.YamlUtil; import java.util.Map; import lombok.extern.slf4j.Slf4j; /** * 配置工具类 * 加载配置文件规则： * <p>conf/application.properties > * application.properties > * conf/application.yaml > * application.yaml > * conf/application.yml > * application.yml</p> */ @Slf4j public class ConfigUtils { private static final String BASE_PATH_DIR = \\\"conf/\\\"; private static final String BASE_CONF_FILE_NAME = \\\"application\\\"; private static final String PROPERTIES_FILE_EXT = \\\".properties\\\"; private static final String YAML_FILE_EXT = \\\".yaml\\\"; private static final String YML_FILE_EXT = \\\".yml\\\"; private static final String ENV_SPLIT = \\\"-\\\"; /** * 加载配置 * * @param clazz clazz * @param prefix properties common prefix * @param <T> T * @return props */ public static <T> T loadConfig(Class<T> clazz, String prefix) { return loadConfig(clazz, prefix, \\\"\\\"); } /** * 加载配置 * <p> * 优先加载 properties, 找不到再加载 yaml / yml * * @param clazz clazz * @param prefix properties common prefix * @param env environment * @param <T> T * @return props */ public static <T> T loadConfig(Class<T> clazz, String prefix, String env) { T props; return (props = loadProperties(clazz, prefix, env)) != null ? props : loadYaml(clazz, prefix, env); } /** * 加载 properties 配置 application-{env}.properties * <p> * 优先加载 conf/conf.properties, 找不到再加载 conf.properties * * @param clazz clazz * @param prefix properties common prefix * @param env environment * @param <T> T * @return props */ public static <T> T loadProperties(Class<T> clazz, String prefix, String env) { try { return doLoadProperties(clazz, BASE_PATH_DIR + BASE_CONF_FILE_NAME, prefix, env); } catch (NoResourceException e) { log.warn( \\\"Not exists properties conf file in [{}], will load properties file from classpath\\\", BASE_PATH_DIR); } try { return doLoadProperties(clazz, BASE_CONF_FILE_NAME, prefix, env); } catch (NoResourceException e) { log.warn(\\\"Not exists properties conf file, will load yaml/yml file from classpath\\\"); } return null; } /** * 加载 yaml 配置 application-{env}.yaml / application-{env}.yml * <p> * 优先加载 conf/conf.yaml, 找不到再加载 conf.yaml，其次加载 conf/conf.yml, 找不到再加载 conf.yml * * @param clazz clazz * @param prefix properties common prefix * @param env environment * @param <T> T * @return props */ public static <T> T loadYaml(Class<T> clazz, String prefix, String env) { // 读取 yaml 文件，优先读取 conf/application-{env}.yaml try { return doLoadYaml(clazz, BASE_PATH_DIR + BASE_CONF_FILE_NAME, prefix, env, YAML_FILE_EXT); } catch (NoResourceException e) { log.warn(\\\"Not exists yaml conf file in [{}], will load yaml file from classpath\\\", BASE_PATH_DIR); } // 加载 application-{env}.yaml 文件 try { return doLoadYaml(clazz, BASE_CONF_FILE_NAME, prefix, env, YAML_FILE_EXT); } catch (NoResourceException e) { log.warn(\\\"Not exists yaml conf file in [{}], will load yml file\\\", BASE_PATH_DIR); } // 读取 yml 文件，优先读取 conf/application-{env}.yml try { return doLoadYaml(clazz, BASE_PATH_DIR + BASE_CONF_FILE_NAME, prefix, env, YML_FILE_EXT); } catch (NoResourceException e) { log.warn(\\\"Not exists yml conf file in [{}], will load yml file from classpath\\\", BASE_PATH_DIR); } // 加载 application-{env}.yml 文件 try { return doLoadYaml(clazz, BASE_CONF_FILE_NAME, prefix, env, YML_FILE_EXT); } catch (NoResourceException e) { log.error(\\\"no conf file!\\\"); throw e; } } /** * 加载 properties 配置 application-{env}.properties * * @param clazz clazz * @param base base path * @param prefix properties common prefix * @param env environment * @param <T> T * @return props */ public static <T> T doLoadProperties(Class<T> clazz, String base, String prefix, String env) throws NoResourceException { String confFilePath = buildConfigFilePath(base, env, PROPERTIES_FILE_EXT); Props props = new Props(confFilePath); return props.toBean(clazz, prefix); } /** * 加载 yaml 配置 application-{ev}.yaml / application-{env}.yml * * @param clazz clazz * @param base base path * @param prefix properties common prefix * @param env environment * @param ext file extension * @param <T> T * @return props */ public static <T> T doLoadYaml(Class<T> clazz, String base, String prefix, String env, String ext) throws NoResourceException { String confFilePath = buildConfigFilePath(base, env, ext); Map<String, Object> props = YamlUtil.loadByPath(confFilePath); JSONObject rpcConfigProps = JSONUtil.parseObj(props).getJSONObject(prefix); return JSONUtil.toBean(rpcConfigProps, clazz); } /** * 构建配置文件路径 * * @param base base path * @param env environment * @param ext file extension * @return config file path */ private static String buildConfigFilePath(String base, String env, String ext) { StringBuilder configFileBuilder = new StringBuilder(base); if (StrUtil.isNotBlank(env)) { configFileBuilder.append(ENV_SPLIT).append(env); } configFileBuilder.append(ext); return configFileBuilder.toString(); } } \",\"测试：\",\"@Test void loadYaml() { RpcConfig rpcConfig = ConfigUtils.loadYaml(RpcConfig.class, \\\"rpc\\\", \\\"\\\"); System.out.println(rpcConfig); } \",\"运行结果：\"]},\"27\":{\"h\":\"RPC框架启动机制\"},\"28\":{\"h\":\"代码优化说明\",\"t\":[\"我们想要开发者可以用更少的代码就可以使用我们的RPC框架，只需要把启动的代码封装为一个专门的启动类或者函数，然后让提供者(Provider)和消费者(Consumer)来调用即可。需要注意的是，服务提供者和消费者需要初始化的模块是不同，消费者（Consumer）不需要初始化Web服务器。\"]},\"29\":{\"h\":\"服务提供者启动类\",\"t\":[\"ServiceRegisterInfo类主要是服务名称和服务实现类\",\"@Data @AllArgsConstructor @NoArgsConstructor public class ServiceRegisterInfo<T> { /** * 服务名称 */ private String serviceName; /** * 服务实现类 */ private Class<? extends T> implClass; } \",\"服务启动的时候，将ServiceRegisterInfo注册到注册中心。\",\"@Slf4j public class ProviderBootstrap { /** * 初始化 */ public static void init(List<ServiceRegisterInfo<?>> serviceRegisterInfoList) { // RPC初始化 RpcApplication.init(); // 全局配置 final RpcConfig rpcConfig = RpcApplication.getRpcConfig(); for (ServiceRegisterInfo<?> serviceRegisterInfo : serviceRegisterInfoList) { String serviceName = serviceRegisterInfo.getServiceName(); Class<?> implClass = serviceRegisterInfo.getImplClass(); // 本地注册 LocalRegistry.register(serviceName, implClass); // 注册到注册中心 RegistryConfig registryConfig = rpcConfig.getRegistryConfig(); Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry()); ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); serviceMetaInfo.setServiceName(serviceName); serviceMetaInfo.setServiceHost(rpcConfig.getServerHost()); serviceMetaInfo.setServicePort(rpcConfig.getServerPort()); try { registry.register(serviceMetaInfo); } catch (Exception e) { throw new RuntimeException(e); } } // 启动服务 VertxTcpServer vertxTcpServer = new VertxTcpServer(); vertxTcpServer.doStart(RpcApplication.getRpcConfig().getServerPort()); } } \",\"具体实现如下:\",\"初始化 RPC 应用程序:\",\"调用 RpcApplication.init() 方法进行全局初始化。\",\"服务注册:\",\"遍历传入的 ServiceRegisterInfo 列表,获取服务名和服务实现类。\",\"将服务实现类注册到本地注册表 LocalRegistry 中,供 RPC 调用时使用。\",\"根据 RPC 配置中的注册中心信息,创建对应的注册中心实例 Registry。\",\"使用 registry.register() 方法将服务元信息(服务名、主机、端口等)注册到注册中心。\",\"启动 RPC 服务端:\",\"创建 VertxTcpServer 实例,它是基于 Vert.x 框架实现的 TCP 服务端。\",\"调用 vertxTcpServer.doStart() 方法,并传入 RPC 配置中指定的服务端口,启动 TCP 服务端。\",\"这个引导程序的设计目的是将 RPC 服务端的初始化和启动过程集中在一个入口类中,方便管理和扩展。它处理了服务注册、配置读取等常见的 RPC 服务端初始化逻辑,并将具体的网络通信细节委托给了 VertxTcpServer 类。\",\"服务提供者初始化启动：\",\"public class CoreProviderExample { public static void main(String[] args) { List<ServiceRegisterInfo<?>> serviceRegisterInfos = new ArrayList<>(); ServiceRegisterInfo serviceRegisterInfo = new ServiceRegisterInfo(UserService.class.getName(), UserServiceImpl.class); serviceRegisterInfos.add(serviceRegisterInfo); ProviderBootstrap.init(serviceRegisterInfos); } } \",\"用户在使用的时候，只需要先创建要注册的实现类，放入serviceRegisterInfos里面,然后调用 ProviderBootstrap.init(serviceRegisterInfos);即可\"]},\"30\":{\"h\":\"服务消费者启动类\",\"t\":[\"消费者启动只需要初始化配置。\",\"/** * @author houyunfei * 服务消费者启动类 */ public class ConsumerBootstrap { public static void init() { RpcApplication.init(); } } \",\"服务消费者初始化启动：\",\"public class CoreConsumerExample { public static void main(String[] args) { ConsumerBootstrap.init(); // 获取 代理 UserService userService = ServiceProxyFactory.getProxy(UserService.class); User user = new User(); user.setName(\\\"cxk\\\"); User user1 = userService.getUser(user); if (user1 != null) { System.out.println(user1.getName()); } else { System.out.println(\\\"user==null\\\"); } } } \"]},\"31\":{\"h\":\"容错机制实现\"},\"32\":{\"h\":\"什么是容错机制？\",\"t\":[\"容错机制是分布式系统设计中非常重要的一部分,它的目标是在部分组件或节点出现故障时,仍能保证系统整体的正常运转和服务可用性。\",\"这种能力对于构建高可用、高可靠的分布式系统非常关键。\",\"容错机制主要包括以下几个方面:\",\"故障检测和隔离:\",\"系统需要能够及时发现和定位故障,并将故障节点或服务隔离,防止故障扩散。\",\"可以使用心跳监测、状态检查等手段来检测故障。\",\"当发现故障时,可以采用服务熔断、容器隔离等方式将故障节点隔离。\",\"请求重试和超时控制:\",\"对于临时性的网络或服务异常,可以采用重试机制来提高成功概率。\",\"重试策略可以是固定时间间隔、指数退避、随机等不同形式。\",\"同时需要设置合理的超时时间,超时后放弃重试,防止无限重试耗尽资源。\",\"容错路由和负载均衡:\",\"当某个服务节点出现故障时,可以通过容错路由将请求重新分配到其他可用节点。\",\"负载均衡策略也需要考虑容错因素,例如剔除故障节点、动态调整权重等。\",\"服务降级和业务兜底:\",\"当依赖的关键服务出现故障时,可以采用服务降级,临时使用备用方案或返回默认响应。\",\"通过业务层面的兜底措施,保证核心功能的可用性。\",\"资源隔离和限流:\",\"将不同服务或模块的资源进行隔离,例如使用容器、虚拟机等技术。\",\"对关键服务实施限流,防止被大量请求冲垮。\",\"数据备份和恢复:\",\"定期备份系统状态和业务数据,以便在发生故障时快速恢复。\",\"备份方案包括数据备份、日志备份、配置备份等。\",\"监控报警和自愈机制:\",\"建立完善的监控体系,实时检测系统运行状态,及时发现并报警异常。\",\"结合其他容错手段,设计自动化的故障修复和自愈流程。\"]},\"33\":{\"h\":\"为什么要容错机制？\",\"t\":[\"分布式系统需要使用容错机制主要有以下几个原因:\",\"提高系统可用性\",\"分布式系统由多个独立组件构成,任何一个组件的故障都可能导致整个系统不可用。\",\"容错机制可以在部分组件出现故障时,保证系统整体仍能正常提供服务,提高可用性。\",\"降低故障影响\",\"在分布式环境下,一个故障可能会通过调用链在系统中传播,导致级联故障。\",\"容错机制可以及时隔离故障,阻止其扩散,降低故障对整个系统的影响。\",\"增强系统弹性\",\"分布式系统面临各种不确定因素,如网络延迟、服务器故障等。\",\"容错机制可以让系统在面对这些不确定性时,仍能保持稳定和可靠的运行。\",\"支持高并发和扩展性\",\"分布式系统通常需要支持高并发访问和动态扩展。\",\"容错机制可以在系统扩展或负载增大时,确保服务质量不会下降。\",\"满足业务连续性要求\",\"许多关键业务系统需要实现7*24小时的持续运行。\",\"容错机制可以确保业务在出现故障时仍能快速恢复,减少业务中断。\",\"降低运维成本\",\"容错机制可以自动化地处理和修复故障,减少人工介入。\",\"这可以降低系统维护的人力和时间成本。\",\"容错机制是构建高可用、高可靠分布式系统的关键所在。它可以显著提高系统的抗风险能力,确保业务连续性,为用户提供稳定可靠的服务。这对于许多关键性的分布式应用来说是非常必要的。\"]},\"34\":{\"h\":\"容错机制有哪些？\",\"t\":[\"参考Dubbo的实现，\",\"在Dubbo的文档中也介绍了这些容错策略：https://cn.dubbo.apache.org/zh-cn/blog/2018/08/22/dubbo-集群容错/\",\"Failover (失败自动切换):\",\"当某个服务提供者出现故障时,自动切换到备用的服务提供者。\",\"这样可以在某个节点出现问题时,保证服务的可用性。\",\"通常会配合负载均衡策略使用,确保流量能够自动分配到可用的节点上。\",\"Failsafe (失败安全):\",\"当服务调用出现异常时,直接返回一个安全的默认值或者空值。\",\"这种策略适用于一些对结果容忍度较高的场景,比如日志记录、缓存预热等。\",\"通过快速返回,可以避免阻塞调用链,提高系统的整体可用性。\",\"Failfast (快速失败):\",\"当服务调用出现异常时,立即抛出异常,不进行重试或降级。\",\"这种策略适用于对响应时间敏感的场景,比如用户交互界面。\",\"快速失败可以减少系统资源的占用,但需要在上层进行更好的异常处理。\",\"Failback (失败自动恢复):\",\"当服务提供者恢复正常后,自动恢复对该服务的调用。\",\"这种策略通常与Failover一起使用,可以在故障恢复后,自动切换回正常的服务节点。\",\"这样可以最大程度地减少服务中断的时间。\",\"Forking (并行调用):\",\"当调用一个服务时,同时向多个服务提供者发起并行调用。\",\"只要有一个调用成功,就返回结果,其他的调用则会被取消。\",\"这种策略可以提高服务的可靠性,但会增加资源消耗。适用于对响应时间有严格要求的场景。\",\"Broadcast (广播调用):\",\"当调用一个服务时,向所有已知的服务提供者发起调用。\",\"所有提供者的响应都会被收集和合并,返回给调用方。\",\"这种策略可以提高服务的可用性,但会增加网络开销。适用于需要聚合多个服务结果的场景。\"]},\"35\":{\"h\":\"容错方案的设计\",\"t\":[\"先容错再重试\",\"先重试再容错\"]},\"36\":{\"h\":\"容错机制实现\",\"t\":[\"除了上述的策略之外，很多 技术都可以算得上是容错，例如：\",\"重试：重试本身就是容错的降级策略，系统出现错误后再重试\",\"限流：如果系统压力过大，已经出现部分错误，那么可以限制请求的频率数量来进行保护\",\"降级：出现错误之后，可以变成执行其他更稳定 的操作，也称兜底，\",\"熔断：出现故障或者异常，暂停服务，避免连锁故障\",\"超时控制：长时间没有处理完成，就中断，防止阻塞和资源占用\"]},\"37\":{\"h\":\"容错策略接口定义\",\"t\":[\"我们定义的 TolerantStrategy 接口主要有两个参数：\",\"Map<String, Object> context\",\"这个参数是一个上下文对象,用于在容错处理过程中传递一些数据。\",\"在分布式系统中,当一个远程调用出现异常时,我们需要根据当前的上下文信息来决定如何进行容错处理。\",\"这个上下文可以包含一些关键信息,例如: \",\"当前请求的参数\",\"调用链路信息\",\"服务实例的元数据\",\"重试次数等\",\"通过这个上下文对象,容错策略实现可以获取到更丰富的信息,从而做出更加合理的容错决策。\",\"Exception e\",\"这个参数表示在执行远程调用时出现的异常。\",\"容错策略需要根据异常的类型、错误信息等,来决定采取什么样的容错措施。\",\"例如,对于网络异常可以选择重试,而对于业务异常可能需要降级或返回默认响应。\",\"通过分析异常信息,容错策略可以更有针对性地进行容错处理。\",\"RpcResponse doTolerant(Map<String, Object> context, Exception e)\",\"这个方法定义了容错处理的具体实现。\",\"它接收上下文信息和异常对象作为参数,并返回一个 RpcResponse 作为处理结果。\",\"容错策略的实现者需要根据具体的业务需求和故障情况,编写相应的容错逻辑,并返回一个合适的响应结果。\",\"总的来说,这个 TolerantStrategy 接口为容错处理提供了一个标准的抽象和扩展点。通过传入上下文信息和异常对象,容错策略的实现者可以更灵活地根据不同的场景,制定出适合自己系统的容错机制。\",\"/** * @author houyunfei */ public interface TolerantStrategy { /** * 容错处理 * @param context 上下文，用于传递数据 * @param e 异常 * @return */ RpcResponse doTolerant(Map<String, Object> context, Exception e); } \"]},\"38\":{\"h\":\"快速失败策略\",\"t\":[\"打印一个日志，直接抛异常出去。\",\"/** * @author houyunfei * 快速失败 */ @Slf4j public class FailFastTolerantStrategy implements TolerantStrategy { /** * 快速失败 -立刻通知调用方失败 * * @param context 上下文，用于传递数据 * @param e 异常 * @return */ @Override public RpcResponse doTolerant(Map<String, Object> context, Exception e) { log.error(\\\"FailFastTolerantStrategy doTolerant\\\", e); throw new RuntimeException(\\\"FailFastTolerantStrategy doTolerant\\\", e); } } \"]},\"39\":{\"h\":\"静默处理策略\",\"t\":[\"静默处理策略提供了一种安静而高效的容错处理方式，再需要容错的时候，我们返回一个默认的RpcResponse即可，可以通过构造函数传入\",\"静默处理策略的特点是:\",\"不通知调用方失败:\",\"当服务调用出现异常时,不会抛出异常,也不会返回错误响应。\",\"而是直接返回一个默认的响应结果。\",\"只记录日志:\",\"异常信息仅仅通过日志的形式记录下来,方便事后排查问题。\",\"但不会将异常信息直接返回给调用方。\",\"适用场景:\",\"这种策略适用于对最终结果不太敏感的场景,比如日志记录、缓存预热等。\",\"即使服务调用失败,也不会影响业务的核心逻辑。\",\"优缺点:\",\"优点是简单易实现,对系统负载影响小。\",\"缺点是可能会丢失一些有价值的业务信息,无法保证最终一致性。\",\"/** * @author houyunfei * 静默处理 */ @Slf4j public class FailSilentTolerantStrategy implements TolerantStrategy { private final RpcResponse defaultResponse; public FailSilentTolerantStrategy(RpcResponse rpcResponse) { this.defaultResponse = rpcResponse; } public FailSilentTolerantStrategy() { this.defaultResponse = new RpcResponse(); } /** * 静默处理 - 不通知调用方失败，只记录日志 * * @param context 上下文，用于传递数据 * @param e 异常 * @return */ @Override public RpcResponse doTolerant(Map<String, Object> context, Exception e) { log.info(\\\"FailSafeTolerantStrategy doTolerant\\\", e); return defaultResponse; } } \"]},\"40\":{\"h\":\"故障恢复策略\",\"t\":[\"故障恢复是容错机制的一个重要组成部分,它的目的是在服务出现故障时,能够快速恢复服务的正常运行,减少业务中断时间。\",\"我们在重试策略失败的时候，这个时候触发容错策略，可以把我们的上下文传过来 ，\",\"// 发送TCP请求 // 使用重试策略 RpcResponse response ; try { RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy()); response = retryStrategy.doRetry(() -> { return VertxTcpClient.doRequest(rpcRequest, metaInfo); }); } catch (Exception e) { TolerantStrategy strategy = TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy()); // 构造上下文 Map<String, Object> context = new HashMap<>(); context.put(TolerantStrategyConstant.SERVICE_LIST, serviceMetaInfos); context.put(TolerantStrategyConstant.CURRENT_SERVICE, metaInfo); context.put(TolerantStrategyConstant.RPC_REQUEST, rpcRequest); response = strategy.doTolerant(context, e); } return response.getData(); \",\"然后去获取所有的服务列表，只要不是当前的服务，都可以重试一次，如果都失败，那就直接抛异常，不重试了。\",\"/** * @author houyunfei * 故障转移 */ @Slf4j public class FailOverTolerantStrategy implements TolerantStrategy { /** * 故障转移 - 重试其他服务 * * @param context 上下文，用于传递数据 * @param e 异常 * @return */ @Override public RpcResponse doTolerant(Map<String, Object> context, Exception e) { List<ServiceMetaInfo> metaInfos = (List<ServiceMetaInfo>) context.get(TolerantStrategyConstant.SERVICE_LIST); ServiceMetaInfo metaInfo = (ServiceMetaInfo) context.get(TolerantStrategyConstant.CURRENT_SERVICE); RpcRequest rpcRequest = (RpcRequest) context.get(TolerantStrategyConstant.RPC_REQUEST); if (metaInfos == null || metaInfos.isEmpty()) { log.error(\\\"FailOverTolerantStrategy doTolerant metaInfos is empty\\\"); return null; } // 重试metaInfo之外的其他服务 for (ServiceMetaInfo serviceMetaInfo : metaInfos) { if (serviceMetaInfo.equals(metaInfo)) { continue; } // 重试 RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(RpcApplication.getRpcConfig().getRetryStrategy()); try { return retryStrategy.doRetry(() -> { return VertxTcpClient.doRequest(rpcRequest, metaInfo); }); } catch (Exception ex) { // 如果重试再失败，继续重试下一个 log.error(\\\"FailOverTolerantStrategy doTolerant retry fail\\\"); } } // 所有服务都重试失败 throw new RuntimeException(\\\"FailOverTolerantStrategy doTolerant all retry fail\\\"); } } \"]},\"41\":{\"h\":\"失败恢复策略\",\"t\":[\"这种策略和故障恢复差不多，都是尝试其他服务，只不过这个在故障服务恢复正常后触发,目的是将流量切换回原来的服务实例。\",\"/** * @author houyunfei * 降级到其他服务 */ @Slf4j public class FailBackTolerantStrategy implements TolerantStrategy { /** * 降级到其他服务 - 重试其他服务 * * @param context 上下文，用于传递数据 * @param e 异常 * @return */ @Override public RpcResponse doTolerant(Map<String, Object> context, Exception e) { List<ServiceMetaInfo> metaInfos = (List<ServiceMetaInfo>) context.get(TolerantStrategyConstant.SERVICE_LIST); ServiceMetaInfo metaInfo = (ServiceMetaInfo) context.get(TolerantStrategyConstant.CURRENT_SERVICE); RpcRequest rpcRequest = (RpcRequest) context.get(TolerantStrategyConstant.RPC_REQUEST); if (metaInfos == null || metaInfos.isEmpty()) { log.error(\\\"FailOverTolerantStrategy doTolerant metaInfos is empty\\\"); return null; } // 重试metaInfo之外的其他服务 for (ServiceMetaInfo serviceMetaInfo : metaInfos) { if (serviceMetaInfo.equals(metaInfo)) { continue; } // 重试 RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(RpcApplication.getRpcConfig().getRetryStrategy()); try { return retryStrategy.doRetry(() -> { return VertxTcpClient.doRequest(rpcRequest, metaInfo); }); } catch (Exception ex) { // 如果重试再失败，继续重试下一个 log.error(\\\"FailOverTolerantStrategy doTolerant retry fail\\\"); } } // 所有服务都重试失败 throw new RuntimeException(\\\"FailOverTolerantStrategy doTolerant all retry fail\\\"); } } \"]},\"42\":{\"h\":\"序列化器实现\"},\"43\":{\"h\":\"我们为什么要实现序列化？\",\"t\":[\"这是因为：网络传输的数据须是二进制数据，但调用方请求的出入参数都是对象：\",\"序列化：对象不能直接在网络传输，需提前转成可传输的二进制，且要求可逆，即“序列化”将对象转换成二进制数据\",\"反序列化：服务提供方就能正确从二进制数据中分割出不同请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，即“反序列化”将二进制转换为对象\",\"整体的RPC框架如图：\",\"以上两点便是我们这个RPC框架要实现序列化和反序列化的原因。\"]},\"44\":{\"h\":\"常见序列化器对比\",\"t\":[\"Dubbo中对序列化器的介绍：https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/ 经调查，常见的序列化器对比情况如下：\",\"JDK原生序列化：\",\"优点：使用方便，无需引入额外依赖。\",\"缺点：速度慢，占空间，有安全问题，已不再推荐使用。\",\"为什么会有安全问题？ 答：只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力。\",\"JSON：\",\"优点：跨语言，使用简单，格式可读，几乎所有编程语言都有JSON的解析和生成库。\",\"缺点：序列化结果大小较大，性能一般，可能存在反序列化漏洞。不能很好地处理复杂的数据结构和循环引用，可能导致性能下降或者序列化失败。\",\"Kryo：\",\"优点：高性能，序列化后体积小，适合分布式。无需实现Serializable接口。\",\"缺点：不跨语言，只有Java。序列化格式复杂\",\"Hessian：\",\"优点：二进制序列化，数据量哓，网络传输速度快。支持跨语言，适合分布式\",\"缺点：性能比JSON低，需要实现Serializable接口，有限制\",\"Protobuf：\",\"优点：高性能，跨语言，序列化后体积小。跨语言。适合分布式。支持schema演化。\",\"缺点：使用不够友好，生成类可读性差，需要工具辅助。配置复杂，需要先定义数据结构消息格式\",\"Avro:\",\"优点：高性能二进制序列化,支持动态类型,适合大数据场景。可以将序列化数据和Schema一起存储。\",\"缺点：对于习惯静态类型语言的工程师来说,JSON格式的IDL不够直观。\",\"XML&SOAP:\",\"优点：可读性好,利于人工维护和调试。\",\"缺点：序列化后数据冗长,性能相对较差。SOAP使用较为复杂。\",\"Thrift:\",\"优点：高性能、跨语言、跨平台支持。适合高性能分布式RPC场景。\",\"缺点：文档相对较少，服务器部署需要开放特定端口,不够灵活。序列化数据不可读,调试较困难。\",\"做一张表总结：\",\"序列化协议\",\"简要介绍\",\"优点\",\"缺点\",\"JDK原生序列化\",\"JVM原生序列化支持\",\"使用方便,无需引入额外依赖\",\"速度慢,占空间,有安全问题,已不再推荐使用\",\"JSON\",\"各种JSON库直接使用\",\"跨语言,使用简单,格式可读\",\"序列化结果大小较大,性能一般,可能存在反序列化漏洞\",\"Kryo\",\"Kryo框架\",\"速度快,序列化后体积小，适合分布式\",\"跨语言支持较复杂,如果服务端增删字段,客户端没有更新会失败,不支持无参构造函数\",\"Hessian\",\"Hessian2协议,安全改进\",\"Java友好,性能较高\",\"跨语言支持一般\",\"Protobuf\",\"中间描述型\",\"跨语言,性能高\",\"使用不够友好,生成类可读性差,需要工具辅助\",\"Avro\",\"数据序列化系统\",\"跨语言,压缩效果好,支持schema演化\",\"使用复杂,需要定义schema\",\"XML\",\"标记语言序列化\",\"跨语言,可读性好\",\"序列化结果大,解析效率低\",\"Thrift\",\"高性能的RPC框架\",\"跨语言,性能高\",\"使用复杂,需要定义IDL\"]},\"45\":{\"h\":\"几种常见的序列化和反序列化协议\"},\"46\":{\"h\":\"接口定义\",\"t\":[\"先定义序列化器的接口，然后再实现具体的序列化器。\",\"import java.io.IOException; /** * 序列化接口 */ public interface Serializer { /** * 序列化 * * @param obj 待序列化的对象 * @param <T> 对象类型 * @return 序列化后的字节数组 * @throws IOException 序列化异常 */ <T> byte[] serialize(T obj) throws IOException; /** * 反序列化 * * @param bytes 字节数组 * @param clazz 对象类型 * @param <T> 对象类型 * @return 反序列化后的对象 * @throws IOException 反序列化异常 */ <T> T deserialize(byte[] bytes, Class<T> clazz) throws IOException; } \"]},\"47\":{\"h\":\"JDK\",\"t\":[\"使用JDK提供的ObjectOutputStream和ObjectInputStream类来完成序列化和反序列化的功能。\",\"序列化将Java对象转换为字节数组,反序列化则从字节数组中重新构建Java对象。\",\"import java.io.*; public class JdkSerializer implements Serializer { @Override public <T> byte[] serialize(T obj) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(obj); objectOutputStream.close(); return outputStream.toByteArray(); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) throws IOException { ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); try { return (T) objectInputStream.readObject(); } catch (ClassNotFoundException e) { throw new IOException(e); } finally { objectInputStream.close(); } } } \"]},\"48\":{\"h\":\"JSON\",\"t\":[\"JSON序列化是将Java对象转换为JSON字符串的过程。在JSON序列化过程中，Java对象的属性将被转换为JSON对象的键值对，如果Java对象包含其他Java对象或集合，这些嵌套对象也会被转换为嵌套的JSON对象和JSON数组。\",\"JSON反序列化是将JSON字符串转换为Java对象的过程。在JSON反序列化过程中，JSON对象的键值对将被转换为Java对象的属性，如果JSON对象包含其他JSON对象或JSON数组，这些嵌套的JSON也会被转换为嵌套的Java对象和Java集合。\",\"使用Jackson库的ObjectMapper来完成序列化和反序列化的功能。ObjectMapper类的实例是线程安全的，可以在多线程环境中共享。\",\"导入依赖：\",\" <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.16.1</version> </dependency> \",\"实现代码：\",\"import com.fasterxml.jackson.databind.ObjectMapper; import com.yunfei.rpc.model.RpcRequest; import com.yunfei.rpc.model.RpcResponse; import java.io.IOException; /** * JSON 序列化器 */ public class JsonSerializer implements Serializer { private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); @Override public <T> byte[] serialize(T obj) throws IOException { return OBJECT_MAPPER.writeValueAsBytes(obj); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) throws IOException { T obj = OBJECT_MAPPER.readValue(bytes, clazz); if (obj instanceof RpcRequest) { return handleRequest((RpcRequest) obj, clazz); } if (obj instanceof RpcResponse) { return handleResponse((RpcResponse) obj, clazz); } return obj; } /** * 由于Object 的原始对象会被擦除，导致反序列化时 LinkedHashMap 无法转换为 原始对象，这里需要特殊处理 * * @param rpcResponse * @param type * @param <T> * @return * @throws IOException */ public <T> T handleResponse(RpcResponse rpcResponse, Class<T> type) throws IOException { byte[] bytes = OBJECT_MAPPER.writeValueAsBytes(rpcResponse.getData()); rpcResponse.setData(OBJECT_MAPPER.readValue(bytes, rpcResponse.getDataType())); return type.cast(rpcResponse); } /** * 由于Object 的原始对象会被擦除，导致反序列化时 LinkedHashMap 无法转换为 原始对象，这里需要特殊处理 * * @param rpcRequest * @param type * @param <T> * @return */ public <T> T handleRequest(RpcRequest rpcRequest, Class<T> type) throws IOException { Class<?>[] parameterTypes = rpcRequest.getParameterTypes(); Object[] args = rpcRequest.getArgs(); // 循环处理每个参数的类型 for (int i = 0; i < parameterTypes.length; i++) { Class<?> clazz = parameterTypes[i]; // 如果类型不同，需要重新转换 if (!clazz.isAssignableFrom(args[i].getClass())) { byte[] bytes = OBJECT_MAPPER.writeValueAsBytes(args[i]); args[i] = OBJECT_MAPPER.readValue(bytes, clazz); } } return type.cast(rpcRequest); } } \",\"代码解释： 在Java中,由于泛型擦除的原因,原始类型信息在编译时会被擦除掉。这意味着,当你使用泛型类型作为方法参数或返回值时,实际上传递或返回的是Object类型。\",\"在这段代码中,RpcResponse的Data字段被声明为泛型类型T。在反序列化时,由于泛型擦除,Data字段实际上被反序列化为一个LinkedHashMap对象,而不是原来的对象类型。 这个问题的关键在于:\",\"当你从字节数组中反序列化一个对象时,Jackson会将其反序列化为一个LinkedHashMap对象,而不是原来的对象类型。\",\"由于泛型擦除,原始对象类型信息在编译时已经丢失,所以无法直接将LinkedHashMap转换回原来的对象类型。\",\"为了解决这个问题,这段代码中引入了handleResponse方法。它的作用是:\",\"先将rpcResponse.getData()序列化为字节数组。\",\"然后使用ObjectMapper.readValue()方法,将字节数组反序列化为rpcResponse.getDataType()指定的类型。\",\"最后将反序列化后的对象设置回rpcResponse的Data字段。\",\"最后返回类型为T的rpcResponse对象。\",\"这样做的目的是,通过手动控制反序列化的过程,确保能够正确地还原原始对象类型,而不是简单的LinkedHashMap。这种特殊处理是因为Java泛型擦除带来的限制而产生的。\",\"同理：在处理RpcRequest对象时,也需要进行类似的处理。这段代码中引入了handleRequest方法,用于处理RpcRequest对象的参数列表。\",\"获取RpcRequest中声明的参数类型数组(parameterTypes)和实际参数数组(args)。\",\"遍历每个参数,检查其实际类型是否与声明的类型不同。\",\"如果类型不同,则使用ObjectMapper重新将参数对象序列化为字节数组,然后反序列化为声明的类型。\",\"最后,将处理后的RpcRequest对象强制转换为目标类型T,并返回。\"]},\"49\":{\"h\":\"Kryo\",\"t\":[\"导入依赖：\",\" <dependency> <groupId>com.esotericsoftware</groupId> <artifactId>kryo</artifactId> <version>5.5.0</version> </dependency> \",\"代码实现：\",\"import com.esotericsoftware.kryo.Kryo; import com.esotericsoftware.kryo.io.Input; import com.esotericsoftware.kryo.io.Output; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; /** * Kryo 序列化器 */ public class KryoSerializer implements Serializer { /** * Kryo 对象不是线程安全的，因此使用 ThreadLocal 来保证线程安全 */ private static final ThreadLocal<Kryo> KRYO_THREAD_LOCAL = ThreadLocal.withInitial(() -> { Kryo kryo = new Kryo(); // 设置动态序列化和反序列化类，不能提前注册类（可能有安全问题） kryo.setRegistrationRequired(false); return kryo; }); @Override public <T> byte[] serialize(T obj) throws IOException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream); KRYO_THREAD_LOCAL.get().writeObject(output, obj); output.close(); return byteArrayOutputStream.toByteArray(); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) throws IOException { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); Input input = new Input(byteArrayInputStream); T res = KRYO_THREAD_LOCAL.get().readObject(input, clazz); input.close(); return res; } } \",\"对代码的解释:\",\"ThreadLocal 保证线程安全:\",\"Kryo对象本身不是线程安全的,因此使用ThreadLocal来保证每个线程都有一个独立的Kryo实例。\",\"动态序列化和反序列化:\",\"kryo.setRegistrationRequired(false); 设置为动态序列化和反序列化,不需要提前注册类。这种方式更灵活,但可能存在一定的安全隐患。\",\"动态注册类型:\",\"当 setRegistrationRequired(false) 时,Kryo会在序列化和反序列化时动态注册类型,无需提前注册。这意味着你可以序列化/反序列化任何类型的对象,无需担心类型是否已被注册。 这种方式更加灵活,可以无需修改代码就能处理新的类型。但同时也存在一定的安全隐患,因为可能会反序列化未知或恶意的类型。 提前注册类型:\",\"当 setRegistrationRequired(true) 时,Kryo会要求在使用之前先注册类型。这样可以提高序列化/反序列化的性能,并增强安全性,因为只有被注册的类型才能被序列化和反序列化。 但缺点是需要提前知道所有可能使用的类型,并显式地注册它们。这在某些场景下可能比较麻烦,尤其是当应用程序需要处理大量不同的类型时。\"]},\"50\":{\"h\":\"Hessian\",\"t\":[\"导入依赖：\",\" <dependency> <groupId>com.caucho</groupId> <artifactId>hessian</artifactId> <version>4.0.66</version> </dependency> \",\"代码实现：\",\" import com.caucho.hessian.io.HessianInput; import com.caucho.hessian.io.HessianOutput; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; /** * Hessian 序列化器 */ public class HessianSerializer implements Serializer { @Override public <T> byte[] serialize(T obj) throws IOException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.writeObject(obj); return byteArrayOutputStream.toByteArray(); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) throws IOException { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); HessianInput hessianInput = new HessianInput(byteArrayInputStream); return (T) hessianInput.readObject(clazz); } } \"]},\"51\":{\"h\":\"Protobuf\",\"t\":[\"ProtoBuf需要先定义 proto 结构，使用相对麻烦，不过 Java 可以使用 Protostuff 解决这个问题。\",\"导入依赖：\",\" <dependency> <groupId>io.protostuff</groupId> <artifactId>protostuff-core</artifactId> <version>1.6.0</version> </dependency> <dependency> <groupId>io.protostuff</groupId> <artifactId>protostuff-runtime</artifactId> <version>1.6.0</version> </dependency> \",\"代码实现：\",\"package com.yunfei.rpc.serializer; import io.protostuff.LinkedBuffer; import io.protostuff.ProtostuffIOUtil; import io.protostuff.Schema; import io.protostuff.runtime.RuntimeSchema; import java.io.IOException; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; /** * https://github.com/protostuff/protostuff */ public class ProtostuffSerializer implements Serializer { // 避免每次序列化都重新申请Buffer空间 private static LinkedBuffer BUFFER = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE); // 缓存Schema private static Map<Class<?>, Schema<?>> schemaCache = new ConcurrentHashMap<Class<?>, Schema<?>>(); @Override public <T> byte[] serialize(T obj) throws IOException { Class<T> clazz = (Class<T>) obj.getClass(); Schema<T> schema = getSchema(clazz); byte[] data; try { data = ProtostuffIOUtil.toByteArray(obj, schema, BUFFER); } finally { BUFFER.clear(); } return data; } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) { Schema<T> schema = getSchema(clazz); T obj = schema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, obj, schema); return obj; } private static <T> Schema<T> getSchema(Class<T> clazz) { Schema<T> schema = (Schema<T>) schemaCache.get(clazz); if (schema == null) { schema = RuntimeSchema.getSchema(clazz); if (schema == null) { schemaCache.put(clazz, schema); } } return schema; } } \"]},\"52\":{\"h\":\"Avro\",\"t\":[\"todo\"]},\"53\":{\"h\":\"XML&SOAP\",\"t\":[\"todo\"]},\"54\":{\"h\":\"Thrift\",\"t\":[\"todo\"]},\"55\":{\"h\":\"快速入门\",\"t\":[\"注意需要自己启动Etcd作为注册中心，暂时未实现其他注册中心\"]},\"56\":{\"h\":\"项目创建\",\"t\":[\"首先创建三个模块，分别是\",\"common模块：提供consumer和provider之间需要使用的接口\",\"consumer：消费者\",\"provider：提供者\"]},\"57\":{\"h\":\"导入依赖\",\"t\":[\"需要让consumer和provider都导入如下依赖，也就是我们的RPC框架依赖yunfei-rpc-spring-boot-starter\",\"<dependencies> <dependency> <groupId>com.yunfeirpc</groupId> <artifactId>yunfei-rpc-spring-boot-starter</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency> <dependency> <groupId>com.yunfei</groupId> <artifactId>example-common</artifactId> <version>1.0-SNAPSHOT</version> </dependency> </dependencies> \"]},\"58\":{\"h\":\"接口与实现代码\"},\"59\":{\"h\":\"common模块\",\"t\":[\"在common模块我们定义了一个getUser的接口\",\"public interface UserService { /** * 获取用户 * * @param user * @return */ User getUser(User user); } \"]},\"60\":{\"h\":\"Provider模块\",\"t\":[\"在Provider模块我们实现了这个接口的功能，也就是这个接口最后是需要提供服务的\",\"@Slf4j @Service @YunRpcService public class UserServiceImpl implements UserService { @Override public User getUser(User user) { System.out.println(\\\"provider received: \\\" + user); return user; } } \"]},\"61\":{\"h\":\"Consumer模块\",\"t\":[\"在Consumer模块，我们写了一个类，这个类中的某些功能需要使用到远程调用的功能\",\"@Service public class ExampleServiceImpl { @YunRpcReference private UserService userService; public void test() { User user = new User(); user.setName(\\\"yunfei\\\"); User resultUser = userService.getUser(user); System.out.println(\\\"consumer get User:\\\" + resultUser.getName()); } } \"]},\"62\":{\"h\":\"注解添加\"},\"63\":{\"h\":\"@YunRpcService\",\"t\":[\"在服务提供者（Provider）的类上加YunRpcService\",\"@Slf4j @Service @YunRpcService public class UserServiceImpl implements UserService { @Override public User getUser(User user) { System.out.println(\\\"provider received: \\\" + user); return user; } } \"]},\"64\":{\"h\":\"@YunRpcReference\",\"t\":[\"在消费者模块（Consumer）要使用的 服务上加YunRpcReference\",\"@Service public class ExampleServiceImpl { @YunRpcReference private UserService userService; public void test() { User user = new User(); user.setName(\\\"yunfei\\\"); User resultUser = userService.getUser(user); System.out.println(\\\"consumer get User:\\\" + resultUser.getName()); } } \"]},\"65\":{\"h\":\"@EnableYunRpc\",\"t\":[\"在服务提供者上加EnableYunRpc注解\",\"@SpringBootApplication @EnableYunRpc public class ExampleSpringbootProviderApplication { public static void main(String[] args) { SpringApplication.run(ExampleSpringbootProviderApplication.class, args); } } \",\"在服务消费者上加EnableYunRpc(needServer = false)注解，这里是不需要启动服务器。\",\"@SpringBootApplication @EnableYunRpc(needServer = false) public class ExampleSpringbootConsumerApplication { public static void main(String[] args) { SpringApplication.run(ExampleSpringbootConsumerApplication.class, args); } } \"]},\"66\":{\"h\":\"测试\",\"t\":[\"@SpringBootTest class ExampleServiceImplTest { @Resource private ExampleServiceImpl exampleService; @Test void test() { exampleService.test(); } } \",\"测试结果：\"]},\"67\":{\"h\":\"接口Mock服务\"},\"68\":{\"h\":\"什么是接口Mock服务？\",\"t\":[\"接口 Mock 服务是一种用于模拟接口行为的技术,它的主要目的是为了在实际服务还未就绪的情况下,提供模拟的接口数据,使得依赖该接口的其他团队或系统可以独立进行开发和测试工作。\"]},\"69\":{\"h\":\"为什么要接口Mock服务？\",\"t\":[\"​ 在传统前后端分离开发的场景下，前端和后端一般定好 HTTP API 接口后就各自进行开发，前端开发中使用 EasyMock、webpack-api-mock 等平台/工具进行接口的 mock，后端通过 Postman / curl 等工具进行接口的自测。\",\"​ 在微服务场景下，各服务之间通过 IDL 定义好 RPC 接口。但是接口调用方依然有 mock 接口的需求，接口提供方也有着自测接口的需求。公司内的服务化平台已经提供了较为完善的接口测试工具，自己实现一个相对也比较容易，但目前却没有一个比较完善的 RPC Mock 方案。\",\"​ 在新项目启动后，前端、API 层和依赖的 Service 往往同步开始开发，只要依赖的 Service 未提供，API 和前端的开发、自测都会被阻塞，在侧重数据展示类需求的项目中这种问题更加严重。\",\"​ 所以，有必要尝试探索一套 RPC Mock 的方案，在保证开发者使用体验的前提下，解决上述问题。除此之外 ，使用接口 Mock 服务还主要有以下几个原因:\",\"提高开发效率:减少等待实际服务开发完成的时间,从而加快开发进度。\",\"降低成本和风险:在开发早期发现问题,避免后期集成时出现的问题。\",\"支持自动化测试:提供可控的测试环境,有助于实现更全面的自动化测试。\",\"模拟异常场景:模拟各种异常情况,如超时、错误码等,帮助开发人员进行容错性测试。\",\"提高系统可用性:当实际服务不可用时,作为备用方案提高整体系统的可用性。\"]},\"70\":{\"h\":\"Mock服务实现\",\"t\":[\"我们可以使用动态代理，在创建调用方法的时候返回固定值对象即可。\",\"依赖安装：\",\"<dependency> <groupId>com.github.jsonzou</groupId> <artifactId>jmockdata</artifactId> <version>4.3.0</version> </dependency> \",\"获取Mock代理的 工厂：\",\"public class ServiceProxyFactory { /** * 根据服务类 获取Mock代理对象 */ public static <T> T getMockProxy(Class<T> serviceClass) { return (T) Proxy.newProxyInstance( serviceClass.getClassLoader(), new Class[]{serviceClass}, new MockServiceProxy() ); } } \",\"Mock代理的具体实现：\",\"如下，我们是通过JMockData来实现模拟数据的获取\",\"/** * Mock 服务代理 JDK动态代理 */ @Slf4j public class MockServiceProxy implements InvocationHandler { /** * 调用代理 * * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 根据方法的返回值类型，生成特定的默认值对象 Class<?> returnType = method.getReturnType(); Object mockData = JMockData.mock(returnType); log.info(\\\"mockData:{}\\\", mockData); return mockData; } } \",\"测试：\",\"@Slf4j public class MockTest { public static void main(String[] args) { // 获取 代理 UserService userService = ServiceProxyFactory.getMockProxy(UserService.class); short number = userService.getNumber(); log.info(\\\"number:{}\\\", number); User user = userService.getUser(new User()); log.info(\\\"user:{}\\\", user); } } \",\"运行结果：\"]},\"71\":{\"h\":\"注册中心实现(Etcd)\"},\"72\":{\"h\":\"什么是注册中心？\",\"t\":[\"注册中心(Service Registry)是 RPC 框架中非常重要的一个组件,它的主要作用包括以下几点:\",\"服务注册\",\"服务提供者在启动时,会将自己的服务信息(如服务名、地址、端口等)注册到注册中心。\",\"注册中心负责维护这些服务的注册信息,为服务消费者提供查询。\",\"服务发现\",\"服务消费者在需要调用服务时,会查询注册中心获取可用的服务提供者信息。\",\"注册中心根据负载均衡策略选择合适的服务实例,返回给消费者。\",\"服务状态管理\",\"注册中心会定期检查服务实例的健康状态,并及时更新注册信息。\",\"当某个服务实例下线或者故障时,注册中心会将其从服务列表中剔除。\",\"服务治理\",\"注册中心可以提供服务分组、服务版本管理等功能,支持更细粒度的服务治理。\",\"通过注册中心,可以实现服务的权重调整、灰度发布等高级特性。\",\"用一张图来表示在本RPC项目中注册中心的作用,服务提供者把服务的信息放到注册中心中，消费者去注册中心服务发现，获取要调用的服务，然后再向服务提供者发起调用：\"]},\"73\":{\"h\":\"注册中心有哪些？\",\"t\":[\"Zookeeper: 分布式协调服务,广泛应用于 Dubbo、Kafka 等 RPC 框架中。\",\"Consul: HashiCorp 公司开源的服务网格解决方案,集成了注册中心、服务发现等功能。\",\"Eureka: Netflix 开源的服务注册中心,曾广泛应用于 Spring Cloud 生态。\",\"etcd: CoreOS 公司开源的分布式键值存储,也可用作注册中心。\",\"Nacos: Alibaba 开源的应用管理与服务治理平台,集成了注册中心、配置管理等功能。\",\"注册中心作为 RPC 框架的核心组件,它的可靠性和性能对整个分布式系统的可用性都有重要影响。\"]},\"74\":{\"h\":\"注册中心设计\",\"t\":[\"我们的注册中心需要实现几个关键的能力：\",\"服务注册和发现\",\"服务提供者在启动时将自身信息注册到注册中心。\",\"服务消费者通过注册中心查找并调用可用的服务提供者。\",\"注册中心需要提供高效的查询和路由机制,确保服务发现的性能。\",\"服务健康检查\",\"注册中心需要定期检查服务实例的健康状态,及时剔除下线或故障的服务。\",\"健康检查可以通过心跳机制、TCP 连接检测等方式实现。\",\"注册中心需要处理服务实例的上下线事件,并通知相关的服务消费者。\",\"负载均衡策略\",\"当存在多个可用的服务提供者时,注册中心需要根据负载均衡策略选择合适的实例。\",\"常见的负载均衡策略包括随机、轮询、加权轮询、最小活跃连接数等。\",\"注册中心需要根据服务实例的负载情况动态调整负载均衡策略。\",\"服务元数据管理\",\"注册中心需要存储服务提供者的详细元数据信息,如服务名称、版本、实例地址等。\",\"这些元数据信息可以帮助服务消费者做更精细的服务选择和调用。\",\"注册中心需要提供元数据的增删改查等管理功能。\",\"服务治理能力\",\"注册中心可以提供服务分组、服务权重、路由规则等高级服务治理功能。\",\"这些功能可以帮助开发者实现更细粒度的服务管控,如灰度发布、流量控制等。\",\"注册中心需要设计可扩展的架构,支持服务治理功能的灵活配置和动态调整。\",\"高可用和容错\",\"注册中心自身需要具备高可用性,避免单点故障。\",\"可以采用主备复制、分布式部署等方式来提高可用性。\",\"注册中心还需要考虑服务发现的容错性,在注册中心宕机时仍能保证服务调用。\",\"性能和扩展性\",\"注册中心需要支撑大规模的服务注册和发现,具备良好的性能表现。\",\"可以采用分片、缓存、异步等手段来提高注册中心的吞吐量和响应速度。\",\"注册中心的架构还需要具备良好的扩展性,以应对不断增长的服务规模。\",\"用一张图来表示注册中心要实现的功能\",\"一些功能如 负载均衡我们已经在RPC层实现过了，注册中心可以暂时不实现，主要实现几个核心的：\",\"服务注册、服务发现、服务剔除、心跳检测、数据存储\"]},\"75\":{\"h\":\"技术选型Etcd\",\"t\":[\"对于注册中心的技术选型，我们需要考虑它的性能，高可用性，高可靠性，稳定性，数据一致性等内容。\",\"高可靠和高可用非要重要，如果注册中心都挂了，那么会影响到所有服务调用。\",\"在本章节中，我们实现Etcd作为注册中心。https://etcd.io/\"]},\"76\":{\"h\":\"Etcd介绍\",\"t\":[\"etcd（读作 et-see-dee）是一种开源的分布式统一键值存储，用于分布式系统或计算机集群的共享配置、服务发现和的调度协调。etcd 有助于促进更加安全的自动更新，协调向主机调度的工作，并帮助设置容器的覆盖网络。\",\"etcd 是许多其他项目的核心组件。最值得注意的是，它是 Kubernetes 的首要数据存储，也是容器编排的实际标准系统。使用 etcd， 云原生应用可以保持更为一致的运行时间，而且在个别服务器发生故障时也能正常工作。应用从 etcd 读取数据并写入到其中；通过分散配置数据，为节点配置提供冗余和弹性。\"]},\"77\":{\"h\":\"服务元信息设计\",\"t\":[\"ServiceMetaInfo是注册中心中服务的元数据信息,包含服务名称、版本、地址、权重等关键属性,为服务注册、发现等功能提供了基础数据模型。\",\"/** * 服务元信息 （注册信息） */ @Data public class ServiceMetaInfo { /** * 服务名称 */ private String serviceName; /** * 服务版本号 */ private String serviceVersion = \\\"1.0\\\"; /** * 服务地址 */ private String serviceAddress; /** * 服务分组（暂未实现） */ private String serviceGroup = \\\"default\\\"; private String serviceHost; private Integer servicePort; /** * 服务权重 */ private int weight = 1; /** * 获取服务键名 */ public String getServiceKey() { return String.format(\\\"%s:%s\\\", serviceName, serviceVersion); } /** * 获取服务节点键名 */ public String getServiceNodeKey() { return String.format(\\\"%s/%s:%s\\\", getServiceKey(), serviceHost,servicePort); } /** * 获取完整的服务地址 */ public String getServiceAddress() { if (!StrUtil.contains(serviceHost, \\\"http\\\")) { return String.format(\\\"http://%s:%s\\\", serviceHost, servicePort); } return String.format(\\\"%s:%s\\\", serviceHost, servicePort); } } \"]},\"78\":{\"h\":\"注册中心配置\",\"t\":[\"注册中心配置主要包括：注册中心类别、地址、用户名、密码、超时时间。\",\"package com.yunfei.rpc.config; import com.yunfei.rpc.registry.RegistryKeys; import lombok.Data; /** * RPC注册中心配置 */ @Data public class RegistryConfig { /** * 注册中心类别 */ private String registry = RegistryKeys.ETCD; /** * 注册中心地址 */ private String address = \\\"http://localhost:2380\\\"; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 超时时间 ms */ private Long timeout = 10000L; } \"]},\"79\":{\"h\":\"注册中心接口\",\"t\":[\"我们可能会有多个注册中心，它和我们的序列化器一样，都应该可以支持使用Java的SPI机制进行动态加载，例如注册中心我们可以在配置文件中设置，可以选用Zookeeper、Redis、Nacos等等。\",\"接口主要提供：初始化、服务注册、服务发现 、注销服务、心跳检测、节点监听功能。\",\"/** * 注册中心接口 */ public interface Registry { /** * 初始化 * * @param registryConfig */ void init(RegistryConfig registryConfig); /** * 注册服务 服务端 * * @param serviceMetaInfo * @throws Exception */ void register(ServiceMetaInfo serviceMetaInfo) throws Exception; /** * 取消注册服务 服务端 * * @param serviceMetaInfo */ void unRegister(ServiceMetaInfo serviceMetaInfo); /** * 服务发现 获取某服务的所有节点 客户端 消费端 * * @param serviceKey * @return */ List<ServiceMetaInfo> serviceDiscovery(String serviceKey); /** * 服务销毁 */ void destroy(); /** * 心跳检测 */ void heartbeat(); /** * 监听服务节点 */ void watch(String serviceNodeKey); } \"]},\"80\":{\"h\":\"Etcd注册中心实现\"},\"81\":{\"h\":\"全局变量\",\"t\":[\" private Client client; private KV kvClient; /** * 根节点 */ private static final String ETCD_ROOT_PATH = \\\"/rpc/\\\"; /** * 本地注册节点 key 集合 用于维护续期 */ private final Set<String> localRegisterNodeKeySet = new HashSet<>(); /** * 注册中心缓存 */ private final RegistryServiceCache registryServiceCache = new RegistryServiceCache(); /** * 监听的key集合 */ private final Set<String> watchingKeySet = new ConcurrentHashSet<>(); \"]},\"82\":{\"h\":\"初始化\",\"t\":[\"初始化主要是为了创建Etcd的client和KVClient对象\",\"@Override public void init(RegistryConfig registryConfig) { client = Client.builder().endpoints(registryConfig.getAddress()) .connectTimeout(Duration.ofMillis(registryConfig.getTimeout())).build(); kvClient = client.getKVClient(); heartbeat(); } \"]},\"83\":{\"h\":\"服务注册\",\"t\":[\"服务注册主要就是把键值对保存到Etcd中：\",\"键是：ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey() 相当于一个唯一标识\",\"值是：服务的元信息serviceMetaInfo\",\"同时我们需要设置过期时间30s，用于剔除过期节点、心跳检测。这样如果服务提供者宕机了，也可以超时自动移除\",\"@Override public void register(ServiceMetaInfo serviceMetaInfo) throws Exception { // 创建Lease 和KV客户端 Lease leaseClient = client.getLeaseClient(); // 创建租约 30s long leaseId = leaseClient.grant(30).get().getID(); // 设置要存储的键值对 String registerKey = ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey(); ByteSequence key = ByteSequence.from(registerKey, StandardCharsets.UTF_8); ByteSequence value = ByteSequence.from(JSONUtil.toJsonStr(serviceMetaInfo), StandardCharsets.UTF_8); // 将键值对与租约绑定 并设置过期时间 PutOption putOption = PutOption.builder().withLeaseId(leaseId).build(); kvClient.put(key, value, putOption).get(); localRegisterNodeKeySet.add(registerKey); } \"]},\"84\":{\"h\":\"服务取消注册\",\"t\":[\"即从Etcd中删除对应的服务节点信息，本地集合 也要删。\",\"@Override public void unRegister(ServiceMetaInfo serviceMetaInfo) { String registerKey = ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey(); kvClient.delete(ByteSequence.from(registerKey, StandardCharsets.UTF_8)); localRegisterNodeKeySet.remove(registerKey); } \"]},\"85\":{\"h\":\"服务发现\",\"t\":[\"我们有一个本地缓存数组serviceCache:它的实现很简单：\",\"public class RegistryServiceCache { /** * 服务缓存 */ List<ServiceMetaInfo> serviceCache; /** * 写缓存 */ void writeCache(List<ServiceMetaInfo> newServiceCache) { serviceCache = newServiceCache; } /** * 读缓存 */ List<ServiceMetaInfo> readCache() { return serviceCache; } /** * 清空缓存 */ void clearCache() { serviceCache = null; } } \",\"如果缓存中有，那么直接获取，就不用从Etcd中获取了\",\"如果没有的话，那么就去搜索，根据前缀搜索，拿到结果之后再把服务进行解析为List<ServiceMetaInfo>的样子\",\"最后还可以 写入缓存中\",\"@Override public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) { // 优先从缓存中获取 List<ServiceMetaInfo> serviceMetaInfoList = registryServiceCache.readCache(); if (CollUtil.isNotEmpty(serviceMetaInfoList)) { return serviceMetaInfoList; } // 前缀搜索，结尾一定要加 '/' String searchPrefix = ETCD_ROOT_PATH + serviceKey + \\\"/\\\"; GetOption getOption = GetOption.builder().isPrefix(true).build(); try { List<KeyValue> keyValues = kvClient.get(ByteSequence.from(searchPrefix, StandardCharsets.UTF_8), getOption).get().getKvs(); // 解析服务 List<ServiceMetaInfo> serviceMetaInfos = keyValues.stream().map(keyValue -> { String key = keyValue.getValue().toString(StandardCharsets.UTF_8); // 监听key的变化 watch(key); return JSONUtil.toBean(key, ServiceMetaInfo.class); }).collect(Collectors.toList()); // 写入缓存 registryServiceCache.writeCache(serviceMetaInfos); return serviceMetaInfos; } catch (Exception e) { throw new RuntimeException(\\\"服务发现失败\\\", e); } } \"]},\"86\":{\"h\":\"服务销毁\",\"t\":[\"当服务提供者关闭的时候，我们需要关闭所有注册的服务，同时也要删除本地即集合。\",\"@Override public void destroy() { System.out.println(\\\"当前节点下线\\\"); // 下线时，删除所有注册的服务 for (String key : localRegisterNodeKeySet) { try { kvClient.delete(ByteSequence.from(key, StandardCharsets.UTF_8)).get(); } catch (Exception e) { throw new RuntimeException(key + \\\"下线失败\\\", e); } } // 关闭客户端 if (client != null) { client.close(); } if (kvClient != null) { kvClient.close(); } } \",\"服务下线分为：\",\"被动下线：Etcd过期机制删除\",\"主动下线：提供者主动从注册中心删除\",\"如何在Java项目退出的时候，执行操作呢？我们可以 利用JVM的ShutDownHook来实现\",\"@Slf4j public class RpcApplication { private static volatile RpcConfig rpcConfig; public static void init(RpcConfig newRpcConfig) { rpcConfig = newRpcConfig; log.info(\\\"rpc application init success,config:{}\\\", rpcConfig); // // 注册中心初始化 RegistryConfig registryConfig = rpcConfig.getRegistryConfig(); Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry()); registry.init(registryConfig); log.info(\\\"registry init success,config:{}\\\", registryConfig); // 创建并 注册Shutdown Hook ,JVM 退出时执行擦欧总 Runtime.getRuntime().addShutdownHook(new Thread(registry::destroy)); } ... } \"]},\"87\":{\"h\":\"心跳检测\",\"t\":[\"我们向Etcd定期发送心跳信号来检测目标是否存活，如果系统在一定时间内没有响应，那么就 认为目标系统故障或者不可用了。\",\"Etcd实现心跳检测比较简单，因为Etcd自带了key过期的机制。我们给节点注册的时候加上了过期时间，再让节点定期去续期，重置过期时间，如果节点宕机了，一直不去续期，那么Etcd会自动删除过期key。\",\"因此我们的心跳检测只需要去定期的续约即可。\",\"我们怎么知道服务提供者要去维护哪些节点呢？\",\"只需要在本地维护一个注册节点信息集合，注册的时候把Key加入到集合中，每次维护集合的信息。\",\"@Override public void heartbeat() { // 100s续约一次 CronUtil.schedule(\\\"*/10 * * * * *\\\", new Task() { @Override public void execute() { for (String key : localRegisterNodeKeySet) { try { List<KeyValue> keyValues = kvClient.get(ByteSequence.from(key, StandardCharsets.UTF_8)).get().getKvs(); // 节点已经过期了，需要重启节点才能重新注册 if (CollUtil.isEmpty(keyValues)) { continue; } // 节点没有过期，重新 注册 相当于续约 KeyValue keyValue = keyValues.get(0); String value = keyValue.getValue().toString(StandardCharsets.UTF_8); ServiceMetaInfo serviceMetaInfo = JSONUtil.toBean(value, ServiceMetaInfo.class); register(serviceMetaInfo); } catch (Exception e) { throw new RuntimeException(key + \\\"续约失败\\\", e); } } } }); // 支持秒级别定时任务 CronUtil.setMatchSecond(true); CronUtil.start(); } \"]},\"88\":{\"h\":\"服务监听\",\"t\":[\"如果服务注册信息发生了变化，那么我们需要更新消费端缓存\",\"@Override public void watch(String serviceNodeKey) { Watch watchClient = client.getWatchClient(); // 之间未被监听，添加监听 boolean newWatch = watchingKeySet.add(serviceNodeKey); if (newWatch) { watchClient.watch(ByteSequence.from(serviceNodeKey, StandardCharsets.UTF_8), (response) -> { for (WatchEvent event : response.getEvents()) { switch (event.getEventType()) { case DELETE: registryServiceCache.clearCache(); break; case PUT: default: break; } } }); } } \"]},\"89\":{\"h\":\"自定义协议(重点)\"},\"90\":{\"h\":\"一些协议概念\",\"t\":[\"RPC(Remote Procedure Call Protocol)远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。\",\"HTTP（超文本传输协议，Hypertext Transfer Protocol是一种用于从网络传输超文本到本地浏览器的传输协议。它定义了客户端与服务器之间请求和响应的格式。HTTP 工作在 TCP/IP 模型之上，通常使用端口 80。\",\"传输控制协议（TCP，Transmission Control Protocol是一种面向连接的、可靠的、基于字节流的传输层通信协议，\",\"UDP(User Datagram Protocol)即用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。\",\"HTTP只是一个通信协议，工作在OSI的第七层，不是一个完整的远程调用方案。\",\"其实rpc不是一种协议，rpc是一种调用过程的方案/范式/实现。RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。\"]},\"91\":{\"h\":\"为什么要自定义RPC协议\",\"t\":[\"性能优化:\",\"标准的 HTTP/REST 协议虽然使用广泛,但由于其报文头部开销较大,不适合高性能的 RPC 场景。\",\"自定义的二进制协议,如 Protobuf、Thrift 等,可以大幅降低数据传输的开销,提升 RPC 的吞吐量和延迟。\"]},\"92\":{\"h\":\"自定义RPC协议设计\",\"t\":[\"自定义RPC协议两大核心部分：\",\"自定义网络传输\",\"自定义消息结构\"]},\"93\":{\"h\":\"网络传输设计\",\"t\":[\"由于HTTP本身是应用层协议，我们现在要设计的RPC协议也是 应用层协议，性能不如底层（TCP与UDP）传输效率高 ，因此对于高性能的追求，我们选择使用TCP协议进行网络传输。\"]},\"94\":{\"h\":\"消息结构设计\",\"t\":[\"我们设计消息结构的目的是为了用最少的空间来传输需要的信息。\",\"int占4个字节、32个比特（bit）位、而byte占1个字节（8个bit位），尽量要选择使用byte。\",\"但是Java中bit运算麻烦，因此要尽量凑到整个字节\",\"消息结构设计，我们的RPC消息所需要的信息：\",\"魔数：标识当前消息是 RPC 协议的消息，避免与其他协议的消息混淆,提高消息的可靠性。\",\"版本号：用于标识当前 RPC 协议的版本,以便于后续的协议升级和兼容性管理。\",\"序列化方式：标识消息体采用的序列化方式,如 Protobuf、Hessian 等,便于接收方进行正确的反序列化。\",\"类型：标识当前消息的类型,如请求、响应、通知\",\"状态：标识当前消息的状态,如成功、失败等\",\"请求ID：标识当前消息的唯一标识符,便于接收方与对应的请求进行关联。\",\"消息体长度：标识消息体的长度,便于接收方准确获取完整的消息内容（TCP有半包和粘包问题，传输信息不完整）\",\"消息体内容：携带实际的业务数据,如方法名、参数列表、返回值等。\",\"结构如下：\",\"请求头的大小$=1+1+1+1+1+8+4=17字节$，我们将整个结构拼接在一起成紧凑的数据。\",\"在后续实现消息编码器和消息解码器的时候：\",\"首先编码器按照顺序向缓冲区Buffer写入这些数据\",\"解码器在按照这个顺序依次读取，比如读magic，只需要读第一个 字节(8bit)即可。\",\"使用这种方式，我们就不用使用key=value的格式 ，这样可以更省内存 。\",\"Redis中很多数据结构都是这样设计的如：参考链接\",\"Dubbo协议设计：\"]},\"95\":{\"h\":\"代码实现\"},\"96\":{\"h\":\"消息结构代码\",\"t\":[\"package com.yunfei.rpc.protocol; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * 协议消息结构 */ @Data @AllArgsConstructor @NoArgsConstructor public class ProtocolMessage<T> { /** * 消息头 */ private Header header; /** * 消息体 （请求或响应对象） */ private T body; /** * 协议消息头 */ @Data public static class Header { /** * 魔数 */ private byte magic; /** * 协议版本 */ private byte version; /** * 序列化器 */ private byte serializer; /** * 消息类型 - 请求/响应 */ private byte type; /** * 状态 */ private byte status; /** * 请求 ID */ private long requestId; /** * 消息体长度 */ private int bodyLength; } } \"]},\"97\":{\"h\":\"消息编码\",\"t\":[\"Vert.x的TCP服务器收发消息都是Buffer类型，不可以直接写入Java对象，我们需要实现一个编码器和解码器，使得Java对象和Buffer之间可以相互转换\"]},\"98\":{\"h\":\"消息编码\",\"t\":[\"public class ProtocolMessageEncoder { /** * 编码 */ public static Buffer encode(ProtocolMessage<?> protocolMessage) throws Exception { if (protocolMessage == null || protocolMessage.getHeader() == null) { return Buffer.buffer(); } ProtocolMessage.Header header = protocolMessage.getHeader(); // 依次向缓冲区写入字节 Buffer buffer = Buffer.buffer(); buffer.appendByte(header.getMagic()); buffer.appendByte(header.getVersion()); buffer.appendByte(header.getSerializer()); buffer.appendByte(header.getType()); buffer.appendByte(header.getStatus()); buffer.appendLong(header.getRequestId()); // 获取序列化器 ProtocolMessageSerializerEnum serializerEnum = ProtocolMessageSerializerEnum.getEnumByKey(header.getSerializer()); if (serializerEnum == null) { throw new RuntimeException(\\\"不支持的序列化器\\\"); } Serializer serializer = SerializerFactory.getInstance(serializerEnum.getValue()); byte[] bodyBytes = serializer.serialize(protocolMessage.getBody()); // 写入 body 长度 和 数据 buffer.appendInt(bodyBytes.length); buffer.appendBytes(bodyBytes); return buffer; } } \",\"解释：\",\"获取 protocolMessage 的 header 属性,并将其各个字段写入到一个新创建的 Buffer 对象中。这些字段包括:\",\"magic: 消息头的\\\"魔数\\\",用于标识消息协议。byte类型，1个字节\",\"version: 消息协议的版本号。byte类型，1个字节\",\"serializer: 消息体的序列化方式。byte类型，1个字节\",\"type: 消息的类型,如请求、响应等。byte类型，1个字节\",\"status: 消息的状态,如成功、失败等。byte类型，1个字节\",\"requestId: 消息的请求 ID。long类型，8个字节\",\"然后根据 header 中的 serializer 字段,获取对应的序列化器实现。使用序列化器将 protocolMessage 的 body 属性序列化为字节数组。\",\"bodyLength:将字节数组的长度写入 Buffer 对象。int类型，4个字节\",\"body:然后将字节数组本身也写入 Buffer 对象。未知\"]},\"99\":{\"h\":\"消息解码\",\"t\":[\"在消息解码的时候，我们就可以参考上面的图了，依次从中读取对应的数据，同时为了解决粘包的问题，我们读取的body的大小应该是bodyLength的值。\",\"/** * 协议消息解码器 */ public class ProtocolMessageDecoder { public static ProtocolMessage<?> decode(Buffer buffer) throws Exception { // 分别从指定位置读出Buffer ProtocolMessage.Header header = new ProtocolMessage.Header(); byte magic = buffer.getByte(0); // 校验魔数 if (magic != ProtocolConstant.PROTOCOL_MAGIC) { throw new Exception(\\\"Invalid magic!\\\"); } header.setMagic(magic); header.setVersion(buffer.getByte(1)); header.setSerializer(buffer.getByte(2)); header.setType(buffer.getByte(3)); header.setStatus(buffer.getByte(4)); header.setRequestId(buffer.getLong(5)); header.setBodyLength(buffer.getInt(13)); // 解决粘包问题，只读取指定长度的数据 byte[] bodyBytes = buffer.getBytes(17, 17 + header.getBodyLength()); // 解析消息体 ProtocolMessageSerializerEnum serializerEnum = ProtocolMessageSerializerEnum.getEnumByKey(header.getSerializer()); if (serializerEnum == null) { throw new RuntimeException(\\\"序列化消息的协议不存在\\\"); } Serializer serializer = SerializerFactory.getInstance(serializerEnum.getValue()); ProtocolMessageTypeEnum messageTypeEnum = ProtocolMessageTypeEnum.getEnum(header.getType()); if (messageTypeEnum == null) { throw new RuntimeException(\\\"序列化消息的类型不存在\\\"); } switch (messageTypeEnum) { case REQUEST: RpcRequest request = serializer.deserialize(bodyBytes, RpcRequest.class); return new ProtocolMessage<>(header, request); case RESPONSE: RpcResponse response = serializer.deserialize(bodyBytes, RpcResponse.class); return new ProtocolMessage<>(header, response); case HEAT_BEAT: case OTHER: default: throw new RuntimeException(\\\"不支持的消息类型\\\"); } } } \"]},\"100\":{\"h\":\"TCP服务器实现\",\"t\":[\"我们使用Vert.x创建一个TCP服务\",\"/** * TCP服务器实现 */ public class VertxTcpServer implements HttpServer { @Override public void doStart(int port) { // 创建一个Vertx实例 Vertx vertx = Vertx.vertx(); // 创建一个TCP服务器 NetServer server = vertx.createNetServer(); // 处理连接请求 server.connectHandler(new TcpServerHandler()); // 启动TCP服务器并监听指定端口 server.listen(port, res -> { if (res.succeeded()) { System.out.println(\\\"TCP server is now listening on actual port: \\\" + server.actualPort()); } else { System.err.println(\\\"Failed to bind!\\\"); } }); } public static void main(String[] args) { new VertxTcpServer().doStart(8080); } } \",\"其中处理连接请求在后面 server.connectHandler(new TcpServerHandler());,主要涉及半包、粘包等问题的处理\"]},\"101\":{\"h\":\"TCP客户端实现\",\"t\":[\"public class VertxTcpClient { public static RpcResponse doRequest(RpcRequest rpcRequest, ServiceMetaInfo metaInfo) throws Exception { // 发送TCP请求 Vertx vertx = Vertx.vertx(); NetClient netClient = vertx.createNetClient(); CompletableFuture<RpcResponse> responseFuture = new CompletableFuture<>(); netClient.connect(metaInfo.getServicePort(), metaInfo.getServiceHost(), res -> { if (!res.succeeded()) { System.err.println(\\\"Failed to connect to TCP server\\\"); return; } System.out.println(\\\"Connected to TCP server\\\"); NetSocket socket = res.result(); // 发送数据 ProtocolMessage<Object> protocolMessage = new ProtocolMessage<>(); ProtocolMessage.Header header = new ProtocolMessage.Header(); header.setMagic(ProtocolConstant.PROTOCOL_MAGIC); header.setVersion(ProtocolConstant.PROTOCOL_VERSION); header.setSerializer((byte) ProtocolMessageSerializerEnum.getEnumByValue(RpcApplication.getRpcConfig().getSerializer()).getKey()); header.setType((byte) ProtocolMessageTypeEnum.REQUEST.getKey()); header.setRequestId(IdUtil.getSnowflakeNextId()); protocolMessage.setHeader(header); protocolMessage.setBody(rpcRequest); // 编码请求 try { Buffer encodeBuffer = ProtocolMessageEncoder.encode(protocolMessage); socket.write(encodeBuffer); } catch (Exception e) { throw new RuntimeException(e); } // 接收响应 TcpBufferHandlerWrapper tcpBufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> { try { ProtocolMessage<RpcResponse> responseProtocolMessage = (ProtocolMessage<RpcResponse>) ProtocolMessageDecoder.decode(buffer); responseFuture.complete(responseProtocolMessage.getBody()); } catch (Exception e) { throw new RuntimeException(\\\"协议消息码错误\\\"); } }); socket.handler(tcpBufferHandlerWrapper); }); System.out.println(\\\"Waiting for response\\\"); RpcResponse rpcResponse = null; rpcResponse = responseFuture.get(5, TimeUnit.SECONDS); System.out.println(\\\"Received response\\\"); netClient.close(); return rpcResponse; } public void start() { Vertx vertx = Vertx.vertx(); vertx.createNetClient().connect(8082, \\\"localhost\\\", res -> { if (res.succeeded()) { System.out.println(\\\"Connected to Tcp Server!\\\"); NetSocket socket = res.result(); for (int i = 0; i < 1000; i++) { Buffer buffer = Buffer.buffer(); String str = \\\"hello,server!hello,server!hello,server!hello,server!\\\"; buffer.appendInt(0); buffer.appendInt(str.getBytes().length); System.out.println(\\\"Send data to server:\\\" + str); buffer.appendBytes(str.getBytes()); socket.write(buffer); } // 接收数据 socket.handler(buffer -> { System.out.println(\\\"Received data from server:\\\" + buffer.toString()); }); } else { System.out.println(\\\"Failed to connect: \\\" + res.cause().getMessage()); } }); } public static void main(String[] args) { new VertxTcpClient().start(); } } \"]},\"102\":{\"h\":\"请求处理器（服务提供者）\",\"t\":[\"请求处理器的主要作用是接受请求，通过反射调用对应的服务实现类\",\"我们通过Vert.x提供的Handler<NetSocket>接口，来实现TCP请求处理器\",\"public class TcpServerHandler implements Handler<NetSocket> { /** * 处理请求 * * @param socket the event to handle */ @Override public void handle(NetSocket socket) { TcpBufferHandlerWrapper bufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> { // 接受请求，解码 ProtocolMessage<RpcRequest> protocolMessage; try { protocolMessage = (ProtocolMessage<RpcRequest>) ProtocolMessageDecoder.decode(buffer); } catch (Exception e) { throw new RuntimeException(\\\"协议消息解码错误\\\"); } RpcRequest rpcRequest = protocolMessage.getBody(); ProtocolMessage.Header header = protocolMessage.getHeader(); // 处理请求 // 构造响应结果对象 RpcResponse rpcResponse = new RpcResponse(); try { // 获取要调用的服务实现类，通过反射调用 Class<?> implClass = LocalRegistry.get(rpcRequest.getServiceName()); Method method = implClass.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes()); Object result = method.invoke(implClass.newInstance(), rpcRequest.getArgs()); // 封装返回结果 rpcResponse.setData(result); rpcResponse.setDataType(method.getReturnType()); rpcResponse.setMessage(\\\"ok\\\"); } catch (Exception e) { e.printStackTrace(); rpcResponse.setMessage(e.getMessage()); rpcResponse.setException(e); } // 发送响应，编码 header.setType((byte) ProtocolMessageTypeEnum.RESPONSE.getKey()); header.setStatus((byte) ProtocolMessageStatusEnum.OK.getValue()); ProtocolMessage<RpcResponse> responseProtocolMessage = new ProtocolMessage<>(header, rpcResponse); try { Buffer encode = ProtocolMessageEncoder.encode(responseProtocolMessage); socket.write(encode); } catch (Exception e) { throw new RuntimeException(\\\"协议消息编码错误\\\"); } }); socket.handler(bufferHandlerWrapper); } } \",\"我们的 Vert.x 的 TCP 服务端处理器,主要实现了以下功能:\",\"接收客户端连接请求,并创建 TcpBufferHandlerWrapper 对象处理接收的数据。\",\"在 TcpBufferHandlerWrapper 中实现了以下逻辑:\",\"使用 ProtocolMessageDecoder.decode() 方法解码接收到的数据,得到 ProtocolMessage<RpcRequest> 对象。\",\"从 ProtocolMessage 中获取 RpcRequest 对象,并根据其中的服务名称和方法名,通过反射调用对应的服务实现类方法,获取执行结果。\",\"创建 RpcResponse 对象,将执行结果封装其中,并设置响应状态为成功。如果在调用过程中出现异常,则将异常信息设置到 RpcResponse 中。\",\"使用 ProtocolMessageEncoder.encode() 方法将 ProtocolMessage<RpcResponse> 对象编码为字节序列,并通过 socket.write() 方法写回给客户端。\"]},\"103\":{\"h\":\"请求发送（服务消费者）\",\"t\":[\"/** * 动态代理 */ public class ServiceProxy implements InvocationHandler { // 指定序列化器 final Serializer serializer = SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer()); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 构造请求 RpcRequest rpcRequest = RpcRequest.builder() .serviceName(method.getDeclaringClass().getName()) .methodName(method.getName()) .parameterTypes(method.getParameterTypes()) .args(args) .build(); // 从注册中心获取服务提供者请求地址 RpcConfig rpcConfig = RpcApplication.getRpcConfig(); Registry registry = RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry()); ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); // 构造请求 String serviceName = method.getDeclaringClass().getName(); serviceMetaInfo.setServiceName(serviceName); serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION); List<ServiceMetaInfo> serviceMetaInfos = registry.serviceDiscovery(serviceMetaInfo.getServiceKey()); if (CollUtil.isEmpty(serviceMetaInfos)) { throw new RuntimeException(\\\"暂无可用服务提供者\\\"); } // 负载均衡 LoadBalancer loadBalancer = LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer()); HashMap<String, Object> requestParams = new HashMap<>(); requestParams.put(\\\"methodName\\\", rpcRequest.getMethodName()); ServiceMetaInfo metaInfo = loadBalancer.select(requestParams, serviceMetaInfos); // 发送TCP请求 // 使用重试策略 RpcResponse response ; try { RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy()); response = retryStrategy.doRetry(() -> { return VertxTcpClient.doRequest(rpcRequest, metaInfo); }); } catch (Exception e) { TolerantStrategy strategy = TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy()); // 构造上下文 Map<String, Object> context = new HashMap<>(); context.put(TolerantStrategyConstant.SERVICE_LIST, serviceMetaInfos); context.put(TolerantStrategyConstant.CURRENT_SERVICE, metaInfo); context.put(TolerantStrategyConstant.RPC_REQUEST, rpcRequest); response = strategy.doTolerant(context, e); } return response.getData(); } } \",\"VertxTcpClient.doRequest(rpcRequest, metaInfo);在上面已经有了\",\"Vert.x提供的请求处理器是异步的，反应式的，为了更方便的获取结果，我们使用CompletableFuture将异步转为同步，阻塞代码responseFuture.get()，直到拿到了结果才会继续往下执行\",\"CompletableFuture<RpcResponse> responseFuture = new CompletableFuture<>(); netClient.connect(metaInfo.getServicePort(), metaInfo.getServiceHost(), res -> { // 接收响应 TcpBufferHandlerWrapper tcpBufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> { //返回处理结果 responseFuture.complete(responseProtocolMessage.getBody()); }); socket.handler(tcpBufferHandlerWrapper); }); RpcResponse rpcResponse = null; rpcResponse = responseFuture.get(5, TimeUnit.SECONDS); \"]},\"104\":{\"h\":\"半包粘包\"},\"105\":{\"h\":\"什么是半包粘包？\",\"t\":[\"举例：\",\"如果我们客户端要发送的消息为hello,cxk!hello,cxk!\",\"半包：收到消息少了，例如hello,cxk!\",\"粘包：收到消息多了，例如hello,cxk!hello,cxk!hello,cxk!\"]},\"106\":{\"h\":\"如何解决半包粘包问题？\"},\"107\":{\"h\":\"如何解决半包？\",\"t\":[\"我们在消息头中已经设置了请求体的长度，在服务端接收的时候，判断每次消息的长度是否符合我们的预期，如果消息不完整，那么我们就留到下一次再读取\"]},\"108\":{\"h\":\"如何解决粘包问题\",\"t\":[\"解决思路类似，我们每次只读取指定长度的数据，超过的长度留到下一次接收消息的时候再读取\",\"在Vert.x中，我们可以使用内置的RecordParser来解决半包和粘包问题，它可以保证下次读取到特定长度的字符，这是我们解决半包粘包问题的基础。\",\"具体为：RecordParser.newFixed(len)\",\"我们封装一个TcpBufferHandlerWrapper类,这里我们使用了设计模式中的装饰者模式,使用RecordParser来对原来的Buffer处理器功能进行增强\",\"public class TcpBufferHandlerWrapper implements Handler<Buffer> { private final RecordParser recordParser; public TcpBufferHandlerWrapper(Handler<Buffer> bufferHandler) { this.recordParser = initRecordParser(bufferHandler); } @Override public void handle(Buffer buffer) { recordParser.handle(buffer); } private RecordParser initRecordParser(Handler<Buffer> bufferHandler) { // 构造parser RecordParser parser = RecordParser.newFixed(ProtocolConstant.MESSAGE_HEADER_LENGTH); parser.setOutput(new Handler<Buffer>() { // 初始化 int size = -1; Buffer resultBuffer = Buffer.buffer(); @Override public void handle(Buffer buffer) { if (size == -1) { // 读取消息体的长度 size = buffer.getInt(13); parser.fixedSizeMode(size); // 写入头信息到结果 resultBuffer.appendBuffer(buffer); } else { // 写入体信息到结果 resultBuffer.appendBuffer(buffer); // 已拼接为完整的Buffer，执行处理 bufferHandler.handle(resultBuffer); // 重置parser parser.fixedSizeMode(ProtocolConstant.MESSAGE_HEADER_LENGTH); size = -1; resultBuffer = Buffer.buffer(); } } }); return parser; } } \",\"TcpBufferHandlerWrapper 类是一个 Vert.x 的 Handler<Buffer> 实现,用于处理从 TCP 连接中接收到的二进制数据。它的主要功能如下:\",\"在构造函数中初始化一个 RecordParser 对象,用于解析接收到的数据。\",\"实现 handle(Buffer buffer) 方法,将接收到的二进制数据传递给 RecordParser 进行处理。\",\"initRecordParser() 方法中实现了 RecordParser 的初始化逻辑:\",\"创建一个新的 RecordParser 实例,并设置其固定长度为 ProtocolConstant.MESSAGE_HEADER_LENGTH(消息头长度)。\",\"设置 RecordParser 的输出处理器,该处理器内部实现了以下逻辑: \",\"首先读取消息体的长度,并设置 RecordParser 的固定长度模式为该长度。\",\"将消息头部分数据写入临时缓冲区 resultBuffer。\",\"当接收到完整的消息体数据后,将整个消息写入 resultBuffer,并将其传递给外部处理器进行处理。\",\"重置 RecordParser 的固定长度模式为消息头长度,并清空 resultBuffer。\",\"这个 TcpBufferHandlerWrapper 类的作用是将从 TCP 连接中接收到的二进制数据流,按照消息协议的格式进行解析,并将解析后的完整消息传递给外部处理器进行处理。\",\" if (size == -1) { // 读取消息体的长度 size = buffer.getInt(13); parser.fixedSizeMode(size); // 写入头信息到结果 resultBuffer.appendBuffer(buffer); } else { // 写入体信息到结果 resultBuffer.appendBuffer(buffer); // 已拼接为完整的Buffer，执行处理 bufferHandler.handle(resultBuffer); // 重置parser parser.fixedSizeMode(ProtocolConstant.MESSAGE_HEADER_LENGTH); size = -1; resultBuffer = Buffer.buffer(); } \",\"在这段代码中，如果size==-1,那么我们就读取从位置13开始的数据，读一个int，这个数据就是消息体的长度。\",\"等到下次size不等于-1了，因为我们设置了parser.fixedSizeMode(size);就是保证可以读取size 长度，也就是下次一定可以读取到整个消息体内容，读完了之后再重置一下。\",\"MESSAGE_HEADER_LENGTH=17,在初始化设置为这样就是为了读取整个消息头的内容，然后可以获取消息体的长度。\",\"因为我们在消息结构是这样设计的：消息结构代码\",\"具体使用：\",\"在TcpServerHandler进行增强\",\"public class TcpServerHandler implements Handler<NetSocket> { @Override public void handle(NetSocket socket) { TcpBufferHandlerWrapper bufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> { //... socket.handler(bufferHandlerWrapper); } } \",\"在VertxTcpClient进行增强\",\"public class VertxTcpClient { netClient.connect(metaInfo.getServicePort(), metaInfo.getServiceHost(), res -> { // 接收响应 TcpBufferHandlerWrapper tcpBufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> { }); socket.handler(tcpBufferHandlerWrapper); }); } \"]},\"109\":{\"h\":\"负载均衡器实现\"},\"110\":{\"h\":\"什么是负载均衡？\",\"t\":[\"在 RPC 框架中,负载均衡是一个非常重要的概念。它指的是将请求流量合理地分配到多个服务提供者实例上,以提高系统的可用性和性能。通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的。\",\"RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。\"]},\"111\":{\"h\":\"负载均衡类型\",\"t\":[\"负载均衡可分为软件负载均衡和硬件负载均衡，本篇主要分析软件负载均衡，这是我们后端开发比较经常接触的均衡器，常见的如HAProxy、LVS、Nginx、定制化的应用请求负载（RPC框架如Dubbo）等，诸如CDN、DNS也运用到了负载均衡算法。\",\"根据 网络层区分负载均衡：\",\"根据网络层协议类型,负载均衡可分为四层负载(TCP/UDP)和七层负载(HTTP/HTTPS)等不同类型。\",\"四层负载均衡直接根据传输层信息(IP、端口)进行分发,不处理应用层数据内容,优点是简单高效,缺点是容易受到SYN Flood等攻击。\",\"七层负载均衡根据应用层信息(URL、请求头、cookie等)进行更精细的分发,可实现更复杂的负载逻辑,但需要额外的TCP连接层,会略微增加网络性能损耗。\",\"尽管七层负载均衡需要更多时间和计算资源,但对现代机器性能而言影响已经很小了。\",\"二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址； 三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址； 四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器； 七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。\",\"无论是哪层负载均衡，都需要有代理服务器，并且对外提供唯一的 IP 地址，然后根据算法将请求转发到目标服务器（实际处理请求的服务器）\"]},\"112\":{\"h\":\"负载均衡算法实现\",\"t\":[\"常见的负载均衡算法主要有以下几种:\",\"轮询(Round Robin):按照请求顺序依次分配到各个服务实例。这是最基础的负载均衡算法。\",\"加权轮询(Weighted Round Robin):根据服务实例的权重进行轮询分配。可以针对不同性能的实例进行加权。\",\"随机(Random):随机选择一个服务实例进行分配。\",\"最小连接数(Least Connections):选择当前连接数最小的服务实例进行分配。这可以平衡各个实例的负载。\",\"一致性哈希(Consistent Hashing):利用一致性哈希算法将请求均匀地分布到不同的服务实例上。可以应对动态扩容缩容场景。\"]},\"113\":{\"h\":\"负载均衡接口定义\",\"t\":[\"我们的负载均衡器算法的作用主要就是从注册服务中去选出一个服务来使用，因此定义如下：\",\"/** * 负载均衡器 （消费端使用） */ public interface LoadBalancer { /** * 选择服务调用 * @param requestParams 请求参数 * @param serviceMetaInfoList 服务列表 * @return */ ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList); } \"]},\"114\":{\"h\":\"随机负载均衡器\",\"t\":[\"实现最简单，每次调用随机函数 ，从列表中随便选一个即可。\",\"/** * 随机负载均衡器 （消费端使用） */ public class RandomLoadBalancer implements LoadBalancer { private final Random random = new Random(); @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { int size = serviceMetaInfoList.size(); if (size == 0) { return null; } if (size == 1) { return serviceMetaInfoList.get(0); } return serviceMetaInfoList.get(random.nextInt(size)); } } \"]},\"115\":{\"h\":\"轮询负载均衡器\",\"t\":[\"轮询算法的实现:\",\"使用 AtomicInteger 类型的 currentIndex 变量记录当前轮询到的索引位置。\",\"每次调用 select() 方法时,都会使用 getAndIncrement() 方法获取当前索引,并将索引值加 1。\",\"然后使用取模运算 % size 得到实际的索引位置,从而从列表中选择对应的服务实例返回。\",\"这里使用JUC包下的AtomicInteger实现原子 计数器，可以防止并发冲突问题\",\"/** * 轮询负载均衡器 （消费端使用） */ public class RoundRobinLoadBalancer implements LoadBalancer { /** * 当前索引 */ private final AtomicInteger currentIndex = new AtomicInteger(0); @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { if (serviceMetaInfoList.isEmpty()) { return null; } // 只有一个服务，无需轮询 int size = serviceMetaInfoList.size(); if (size == 1) { return serviceMetaInfoList.get(0); } // 取模轮询 int index = currentIndex.getAndIncrement() % size; return serviceMetaInfoList.get(index); } } \"]},\"116\":{\"h\":\"一致性哈希负载均衡器\",\"t\":[\"我们现在将空间划分为一个环形结构，每个节点计算哈希值，放入到环上面，每个请求也可以计算哈希值映射到环上一个点，只需要找第一个 大于等于该哈希值的点即可。\",\"好处在于：如果某个点下线了，那么它会动态计算哈希值，然后分配到其他节点上\",\"如果对于轮询算法 ，节点数一变，大多数请求都要跟着变\",\"如果说服务器算出的哈希值分布不够均匀，那么我们可以引入虚拟节点，让服务变得均匀。即使只有3个节点也可以分配均匀 ，从而很好的解决了倾斜问题。\",\"具体实现如下为ConsistentHashLoadBalancer 它的工作原理如下:\",\"虚拟节点环的构建:\",\"该负载均衡器使用一个 TreeMap 来存储虚拟节点和对应的服务实例信息。\",\"在 select() 方法被调用时,会首先遍历服务实例列表 serviceMetaInfoList。\",\"对于每个服务实例,会创建 VIRTUAL_NODE_NUM 个虚拟节点,并使用服务实例的地址和虚拟节点编号计算出哈希值,作为虚拟节点在哈希环上的位置。\",\"然后将这些虚拟节点及对应的服务实例信息存储到 virtualNodes 这个有序 Map 中。\",\"请求路由:\",\"当客户端发起请求时,会调用 select() 方法进行服务实例的选择。\",\"首先根据请求参数计算出一个哈希值,表示请求在哈希环上的位置。\",\"然后在 virtualNodes 中查找最接近且大于该哈希值的虚拟节点。\",\"如果找不到大于该哈希值的虚拟节点,则选择环上的第一个虚拟节点。\",\"最终返回对应虚拟节点所映射的服务实例。\",\"这种一致性哈希算法的优点包括:\",\"负载均衡: 通过将请求映射到虚拟节点上,可以将请求合理地分配到不同的服务实例上。\",\"高可扩展性: 当增加或删除服务实例时,只会影响部分请求的路由,不会导致整体负载的重大变化。\",\"请求粘性: 同一个客户端的请求,往往会路由到同一个服务实例上,有利于保持会话状态。\",\"缺点是:\",\"实现复杂度较高: 一致性哈希算法的实现相比轮询算法要复杂一些,需要维护虚拟节点环。\",\"冷启动问题: 在系统启动初期,如果服务实例较少,可能会导致负载分布不均匀的问题。\",\"/** * 一致性哈希负载均衡器 （消费端使用） */ public class ConsistentHashLoadBalancer implements LoadBalancer { /** * 一致性Hash环，存放虚拟节点 */ private final TreeMap<Integer, ServiceMetaInfo> virtualNodes = new TreeMap<>(); /** * 虚拟节点数 * * @param requestParams 请求参数 * @param serviceMetaInfoList 服务列表 * @return */ private static final int VIRTUAL_NODE_NUM = 100; @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { if (serviceMetaInfoList.isEmpty()) { return null; } // 构建虚拟节点环 每次都重新构建，因为服务列表可能会变化 为了能够及时感知到服务的变化 for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { for (int i = 0; i < VIRTUAL_NODE_NUM; i++) { int hash = getHash(serviceMetaInfo.getServiceAddress() + \\\"#\\\" + i); virtualNodes.put(hash, serviceMetaInfo); } } int hash = getHash(requestParams); // 选择最接近且大于hash的节点 Map.Entry<Integer, ServiceMetaInfo> entry = virtualNodes.ceilingEntry(hash); if (entry == null) { entry = virtualNodes.firstEntry(); } return entry.getValue(); } /** * Hash算法 * * @param key * @return */ private int getHash(Object key) { return key.hashCode(); } } \"]},\"117\":{\"h\":\"加权轮询/随机\",\"t\":[\"比如现在有三台服务器A，B，C。权重占比为：2:3:5\",\"最简单的办法，我们开一个数组 ，把A放两个进去，B放3个进去，C放5个 进去。然后再轮询\",\"/** * @author houyunfei * 加权轮询负载均衡 */ public class WeightedRoundRobinLoadBalancer implements LoadBalancer { private AtomicInteger currentIndex = new AtomicInteger(0); private static List<ServiceMetaInfo> list; void init(List<ServiceMetaInfo> serviceMetaInfoList) { list = new ArrayList<>(); // 构建 for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { int weight = serviceMetaInfo.getWeight(); // 有多少个权重就添加多少个 for (int i = 0; i < weight; i++) { list.add(serviceMetaInfo); } } } @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { ServiceMetaInfo serviceMetaInfo = list.get(currentIndex.getAndIncrement() % list.size()); return serviceMetaInfo; } } \",\"问题是：如果服务器数量非常大，这种操作就非常浪费性能\",\"优化办法：不需要使用数组了，我们直接随机10以内的数字，如果超过5那么就是C，小于2那么就是A，剩下的就是B了。\",\"或者：比如现在权重 2 3 5 算出来pos=6\",\"那么他应该是C服务器，说白了就是求6在数组2 2 3 3 3 5 5 5 5 5是第几个服务器\",\"先6>2不符合，那么6-2=4\",\"然后4>=3不符合，那么4-3=1\",\"最后1<5符合，所以就是第三个位置\",\"有点类似于前缀和的思想（如果说服务列表不变，那么我就可以前缀和先预处理，然后二分求位置，速度更快）\",\"public class WeightedRoundRobinLoadBalancer implements LoadBalancer { private AtomicInteger num = new AtomicInteger(0); // 计数器 用于轮询 @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { int totalWeight = 0; // 总权重 for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { totalWeight += serviceMetaInfo.getWeight(); } int pos = num.getAndIncrement() % totalWeight; // 取模 for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { int weight = serviceMetaInfo.getWeight(); if (pos < weight) { // 如果当前位置小于权重值，返回当前服务 return serviceMetaInfo; } pos -= weight; // 否则减去权重值，继续循环 } return null; } } \",\"这个加权轮询算法的核心思想是,根据每个服务实例的权重,分配不同的请求量。权重越大的实例,分配到的请求也越多。通过轮询的方式,可以保证每个实例都能够得到请求,从而实现负载均衡的目标。\"]},\"118\":{\"h\":\"平滑加权轮询\",\"t\":[\"固定权重：weight=(2,3,5)\",\"动态变化权重：currWeight=(0,0,0)\",\"轮次\",\"currWeight+=weight\",\"max(currWeight)\",\"result\",\"max(currWeight)-=sum(weight)\",\"1\",\"2、3、5\",\"5\",\"C\",\"2、3、-5\",\"2\",\"4、6、0\",\"6\",\"B\",\"4、-4、0\",\"3\",\"6、-1、5\",\"6\",\"A\",\"-4、-1、5\",\"4\",\"-2、2、10\",\"10\",\"C\",\"-2、2、0\",\"5\",\"0、5、5\",\"5\",\"B\",\"0、-5、5\",\"6\",\"2、-2、10\",\"10\",\"C\",\"-2、2、0\",\"7\",\"4、1、5\",\"5\",\"C\",\"4、1、-5\",\"8\",\"6、4、0\",\"6\",\"A\",\"-4、4、0\",\"9\",\"-2、7、5\",\"7\",\"B\",\"-2、-3、5\",\"10\",\"0、0、10\",\"10\",\"C\",\"0、0、0\",\"这样也可以做到A:B:C=2:3:5\",\"/** * @author houyunfei * 加权轮询负载均衡 */ public class WeightedRoundRobinLoadBalancer implements LoadBalancer { private AtomicInteger num = new AtomicInteger(0); // 计数器 用于轮询 @Data @AllArgsConstructor public static class Weight { private ServiceMetaInfo info; private int weight; private int currentWeight; } public static Map<ServiceMetaInfo, Weight> currentWeightMap = new HashMap(); @Override public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) { int totalWeight = 0; // 总权重 for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { totalWeight += serviceMetaInfo.getWeight(); } if (currentWeightMap.isEmpty()) { for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) { // 初始化权重 currentWeight = 0 currentWeightMap.put(serviceMetaInfo, new Weight(serviceMetaInfo, serviceMetaInfo.getWeight(), 0)); } } // 将权重值加上动态权重 for (Weight weight : currentWeightMap.values()) { weight.setCurrentWeight(weight.getCurrentWeight() + weight.getWeight()); } // 选出最大的权重 Weight maxWeight = null; for (Weight weight : currentWeightMap.values()) { if (maxWeight == null || weight.getCurrentWeight() > maxWeight.getCurrentWeight()) { maxWeight = weight; } } // 将最大的权重减去总权重 maxWeight.setCurrentWeight(maxWeight.getCurrentWeight() - totalWeight); // 返回最大权重对应的服务 return maxWeight.getInfo(); } } \"]},\"119\":{\"h\":\"重试机制实现\"},\"120\":{\"h\":\"什么是重试机制？\",\"t\":[\"重试机制：就是当调用端发起的请求失败时，RPC框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试次数。\",\"调用端在发起 RPC 调用时，会经过负载均衡，选择一个节点，之后它会向这个节点发送请求信息。当消息发送失败或收到异常消息时，我们就可以捕获异常，根据异常触发重试，重新通过负载均衡选择一个节点发送请求消息，并且记录请求的重试次数，当重试次数达到用户配置的重试次数的时候，就返回给调用端动态代理一个失败异常，否则就一直重试下去。\"]},\"121\":{\"h\":\"为什么要重试机制？\",\"t\":[\"重试机制的主要原因有以下几点:\",\"提高接口的可用性和可靠性:当远程服务调用失败时,比如网络抖动导致请求失败,重试机制可以让系统自动重新发起请求,尽量保证接口能够成功执行。\",\"处理临时性的错误:一些临时性的错误,比如网络超时、连接异常等,可能会导致单次请求失败。重试机制可以自动处理这类临时性错误,提高成功率。\",\"降低调用端的复杂度:如果没有重试机制,调用端需要自行捕获异常,并手动重试,这会增加调用端代码的复杂度。重试机制可以将这部分逻辑封装在RPC框架内部,降低调用端的开发难度。\",\"实现幂等性:试机制要求被调用的服务具有幂等性,即多次执行同一个操作,不会产生副作用。这可以进一步提高系统的稳定性和可靠性。\",\"重试机制是提高分布式系统可用性和容错性的一种有效手段,能够提高系统的整体可靠性。\",\"https://blog.csdn.net/zhizhengguan/article/details/121451100\",\"RPC框架的重试机制：当调用端发起的请求失败时，如果配置了异常重试机制，RPC框架会捕捉异常，对异常进行判定，符合条件的进行重试。\",\"在重试的过程中，为了能够在约定的时间内进行安全可靠的重试，在每次触发重试之前，我们需要先判定下这个请求是否已经超时，如果超时了会直接返回超时异常，否则我们需要重置下这个请求的超时时间，防止因为多次重试而导致这个请求的处理时间超过用户配置的超时时间，从而影响到业务处理的耗时。\",\"在发起重试、负载均衡选择节点的时候，我们应该去掉重试之前出现过问题的那个节点，这样可以提高重试的成功率，并且允许用户配置可重试异常的白名单，这样可以让RPC框架的异常重试功能变得更加友好。\",\"另外，在使用RPC框架的重试机制时，我们要确保被调用的服务的业务逻辑是幂等的，这样才能考虑是否使用重试\"]},\"122\":{\"h\":\"重试机制有哪些？\",\"t\":[\"在 RPC 系统中,常见的重试策略主要包括以下几种:\",\"固定间隔重试策略（Fixed Interval Retry）:\",\"每次重试之间固定一个时间间隔,例如 3 秒。\",\"适用于对响应时间要求不太严格的场景。\",\"指数退避重试策略（Exponential Backoff Retry）:\",\"每次重试的时间间隔呈指数增长,例如 1 秒、2 秒、4 秒、8 秒等。\",\"适用于网络波动较大的场景,避免短时间内发送大量重复请求。\",\"线性重试策略（Linear Retry）:\",\"每次重试之间的时间间隔是线性增加的,例如 1 秒、2 秒、3 秒等。\",\"介于固定间隔和指数退避之间,适用于一般的网络环境。\",\"随机重试策略（Random Retry）:\",\"每次重试的时间间隔是随机的,在一定范围内波动。\",\"适用于避免重试请求同步的场景,例如防止雪崩效应。\",\"断路器重试策略（Circuit Breaker Retry）:\",\"结合断路器模式,当服务出现多次失败时,暂时断开对该服务的调用。\",\"当服务恢复正常后,再逐步恢复对该服务的调用。\",\"适用于依赖服务不稳定的场景,可以有效防止级联故障。\",\"重试次数限制策略（Retry Limit）:\",\"设置最大重试次数,超过限制则放弃重试。\",\"与其他重试策略配合使用,防止无限重试耗尽资源。\",\"不重试(No Retry)\",\"当远程调用失败时,直接返回失败结果,不进行任何重试。\",\"这种方式适用于对响应时间要求较高的场景,或者对于一些幂等性较强的操作。\",\"这些重试策略各有适用场景,在实际的 RPC 系统设计中,通常会根据业务特点和性能需求,选择合适的重试策略或者组合使用多种策略。\",\"例如,在一个对响应时间要求较高的 RPC 系统中,可以采用指数退避重试策略,并设置重试次数限制,以兼顾服务的可靠性和性能。而在一个对可用性要求更高的系统中,则可以考虑使用断路器重试策略。\"]},\"123\":{\"h\":\"重试策略实现\",\"t\":[\"我们需要搞清楚几个问题：\",\"什么时候，什么条件重试\",\"重试时间，下一次重试时间\",\"什么时候，什么条件停止重试\",\"重试之后要做什么？\"]},\"124\":{\"h\":\"重试策略接口定义\",\"t\":[\"代码如下：\",\"/** * 重试策略接口 */ public interface RetryStrategy { /** * 重试 * @param callable 重试的方法 代表一个任务 * @return * @throws Exception */ RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception; } \",\"解释：\",\"RetryStrategy 接口定义了重试策略的标准,包括以下方法:doRetry(Callable<RpcResponse> callable):\",\"该方法接受一个 Callable 对象作为参数,表示需要重试的方法调用。\",\"方法实现需要根据具体的重试策略,决定是否需要重试,并执行重试操作。\",\"如果重试成功,则返回调用结果 RpcResponse。如果重试失败,则抛出异常。\",\"引入Google的Guava-Retrying库\",\"<!-- 重试策略--> <dependency> <groupId>com.github.rholder</groupId> <artifactId>guava-retrying</artifactId> <version>2.0.0</version> </dependency> \"]},\"125\":{\"h\":\"不重试策略\",\"t\":[\"实现最简单，我们直接返回即可\",\"@Slf4j public class NoRetryStrategy implements RetryStrategy { /** * 重试 * * @param callable 重试的方法 代表一个任务 * @return * @throws Exception */ @Override public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception { return callable.call(); } } \"]},\"126\":{\"h\":\"固定重试间隔策略\",\"t\":[\"我们使用了 google-guava 提供的 Retryer 工具来实现重试逻辑。具体实现如下:\",\"doRetry() 方法是 RetryStrategy 接口的实现,它接收一个 Callable 作为需要重试的任务。\",\"在方法中,首先创建了一个 Retryer 对象,并配置了以下重试策略: \",\"retryIfExceptionOfType(Exception.class): 遇到任何异常类型都进行重试。\",\"withWaitStrategy(WaitStrategies.fixedWait(3L, TimeUnit.SECONDS)): 每次重试之间固定间隔 3 秒。\",\"withStopStrategy(StopStrategies.stopAfterAttempt(3)): 最多重试 3 次,超过则停止重试。\",\"withRetryListener(new RetryListener() { ... }): 添加了一个重试监听器,在每次重试时打印当前重试次数。\",\"最后调用 retryer.call(callable) 执行重试操作,并返回最终的调用结果 RpcResponse。\",\"这个重试策略的特点如下:\",\"固定时间间隔: 每次重试之间都有 3 秒的固定时间间隔,这种策略适用于对响应时间要求不太严格的场景。\",\"有限重试次数: 最多重试 3 次,超过则停止重试。这可以避免无限重试导致资源耗尽的问题。\",\"异常捕获: 对任何异常类型都进行捕获并重试,适用于比较通用的重试场景。\",\"重试监听: 添加了重试监听器,可以在每次重试时打印日志,方便问题排查。\",\"/** * @author houyunfei * 固定时间间隔重试策略 */ @Slf4j public class FixedIntervalRetryStrategy implements RetryStrategy { /** * 重试 * @param callable 重试的方法 代表一个任务 * @return * @throws Exception */ @Override public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception { Retryer<RpcResponse> retryer = RetryerBuilder.<RpcResponse>newBuilder() .retryIfExceptionOfType(Exception.class) .withWaitStrategy(WaitStrategies.fixedWait(3L, TimeUnit.SECONDS)) .withStopStrategy(StopStrategies.stopAfterAttempt(3)) .withRetryListener(new RetryListener() { @Override public <V> void onRetry(Attempt<V> attempt) { log.info(\\\"重试第{}次\\\", attempt.getAttemptNumber()); } }).build(); return retryer.call(callable); } } \"]},\"127\":{\"h\":\"指数退避重试策略\",\"t\":[\"我们可以实现一个指数退避重试策略。主要步骤如下:\",\"定义最大重试次数 MAX_RETRY_TIMES 为 5 次。\",\"在 doRetry() 方法中,使用 Stopwatch 来记录每次重试的耗时。\",\"在每次重试时,先调用 callable.call() 执行远程调用。\",\"如果出现异常,则进行重试处理: \",\"记录当前重试次数 retryTimes。\",\"计算本次重试的退避时间 sleepTime。初始退避时间为 100 毫秒,每次重试时退避时间翻倍。\",\"如果 sleepTime 大于 0,则通过 Thread.sleep() 进行退避延迟。\",\"如果重试次数达到上限,则抛出异常。\",\"如果重试成功,则直接返回结果 RpcResponse。\",\"这种指数退避重试策略可以有效应对网络抖动和服务短暂不可用的情况。它会逐步增加重试间隔,避免在短时间内大量重复请求,从而降低系统负载。\",\"import com.google.common.base.Stopwatch; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.Callable; import java.util.concurrent.TimeUnit; @Slf4j public class ExponentialBackoffRetryStrategy implements RetryStrategy { private static final int MAX_RETRY_TIMES = 5; private static final long INITIAL_BACKOFF_INTERVAL = 100; // 初始退避时间100毫秒 @Override public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception { int retryTimes = 0; long backoffInterval = INITIAL_BACKOFF_INTERVAL; Stopwatch stopwatch = Stopwatch.createUnstarted(); while (retryTimes < MAX_RETRY_TIMES) { try { stopwatch.start(); return callable.call(); } catch (Exception e) { retryTimes++; log.warn(\\\"RPC call failed, retrying... Current retry times: {}\\\", retryTimes, e); stopwatch.stop(); long elapsedTime = stopwatch.elapsed(TimeUnit.MILLISECONDS); long sleepTime = Math.min(backoffInterval, Math.max(0, backoffInterval - elapsedTime)); stopwatch.reset(); if (sleepTime > 0) { log.info(\\\"Backing off for {} ms before next retry.\\\", sleepTime); Thread.sleep(sleepTime); } backoffInterval *= 2; // 指数退避 } } throw new Exception(\\\"Maximum retry times exceeded, giving up.\\\"); } } \",\"callable.call() 是 Java 中 Callable 接口的一个方法,用于执行一个可以返回结果的任务。\",\"在 Java 中, Callable 是一个函数式接口,它包含一个名为 call() 的方法,该方法声明为 throws Exception。这意味着 call() 方法可能会抛出任何类型的异常。\",\"以下是 Callable 接口的定义:\",\"@FunctionalInterface public interface Callable<V> { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; } \",\"在我们的 ExponentialBackoffRetryStrategy 类中, callable.call() 用于执行需要重试的远程调用任务。具体工作流程如下:\",\"当 doRetry() 方法被调用时,会传入一个 Callable<RpcResponse> 对象作为参数。这个 Callable 对象代表了需要执行的远程调用任务。\",\"在 doRetry() 方法内部,我们会调用 callable.call() 来执行这个任务。\",\"如果 call() 方法执行成功,则直接返回结果 RpcResponse。\",\"如果 call() 方法抛出异常,则进入重试流程。\",\"使用 Callable 的好处是:\",\"返回结果: Callable 可以返回一个计算结果,而 Runnable 只能执行一个任务,无法返回结果。\",\"异常处理: Callable 的 call() 方法可以声明抛出异常,而 Runnable 的 run() 方法不能抛出异常。这使得我们可以更好地处理任务执行过程中的异常情况。\",\"灵活性: Callable 是一个函数式接口,可以方便地使用 lambda 表达式或方法引用来创建任务对象。\"]},\"128\":{\"h\":\"线性重试策略\",\"t\":[\"这个实现与之前的指数退避重试策略非常相似,主要区别在于退避时间的计算方式:\",\"在每次重试时,我们将退避时间 backoffInterval 线性增加,初始值为 1 秒。\",\"具体计算方式为 backoffInterval += INITIAL_BACKOFF_INTERVAL。这样每次重试时,退避时间都会增加 1 秒。\",\"其他部分,如最大重试次数、异常处理、日志记录等,与指数退避重试策略保持一致。\",\"这种线性重试策略适用于网络环境相对较为稳定的场景,对响应时间要求也不太严格。它能够提供一个平滑的重试过程,不会像指数退避那样导致重试间隔时间过长。\",\"与指数退避相比,线性重试的优点是:\",\"响应时间更短:每次重试的时间间隔增长较缓慢,可以更快地得到服务响应。\",\"更加稳定:重试间隔变化平缓,不会出现大幅波动。\",\"缺点是:\",\"对网络抖动不太敏感:当网络环境较差时,线性重试可能无法有效地抑制重试请求。\",\"如果对响应时间要求较高,且网络环境较为稳定,线性重试策略是一个不错的选择。\",\"import com.google.common.base.Stopwatch; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.Callable; import java.util.concurrent.TimeUnit; @Slf4j public class LinearRetryStrategy implements RetryStrategy { private static final int MAX_RETRY_TIMES = 5; private static final long INITIAL_BACKOFF_INTERVAL = 1000; // 初始退避时间1秒 @Override public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception { int retryTimes = 0; long backoffInterval = INITIAL_BACKOFF_INTERVAL; Stopwatch stopwatch = Stopwatch.createUnstarted(); while (retryTimes < MAX_RETRY_TIMES) { try { stopwatch.start(); return callable.call(); } catch (Exception e) { retryTimes++; log.warn(\\\"RPC call failed, retrying... Current retry times: {}\\\", retryTimes, e); stopwatch.stop(); long elapsedTime = stopwatch.elapsed(TimeUnit.MILLISECONDS); long sleepTime = Math.min(backoffInterval, Math.max(0, backoffInterval - elapsedTime)); stopwatch.reset(); if (sleepTime > 0) { log.info(\\\"Backing off for {} ms before next retry.\\\", sleepTime); Thread.sleep(sleepTime); } backoffInterval += INITIAL_BACKOFF_INTERVAL; // 线性增加退避时间 } } throw new Exception(\\\"Maximum retry times exceeded, giving up.\\\"); } } \"]},\"129\":{\"h\":\"RPC一些结构图介绍\",\"t\":[\"系统中的一些结构图\",\"RPC基本思路：\",\"RPC框架结构\",\"编码器\",\"序列化\",\"RPC配置\",\"SPI机制\",\"Etcd注册中心监听机制\",\"消息结构设计：\",\"消息结构写入Buffer(紧凑)：\"]},\"130\":{\"h\":\"优化与改进\",\"t\":[\"服务可以尝试使用Netty进行通信，提高性能，\",\"服务注册中心可以实现Redis、Zookeeper、Nacos等其他注册中心，\",\"更多的负载均衡策略可以实现，\",\"更多的序列化方式可以实现，\",\"更多的容错降级策略可以实现，\",\"分布式？\"]},\"131\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"更多的容错降级策略可以实现\",{\"1\":{\"130\":1}}],[\"更多的序列化方式可以实现\",{\"1\":{\"130\":1}}],[\"更多的负载均衡策略可以实现\",{\"1\":{\"130\":1}}],[\"更加稳定\",{\"1\":{\"128\":1}}],[\"紧凑\",{\"1\":{\"129\":1}}],[\"且网络环境较为稳定\",{\"1\":{\"128\":1}}],[\"且要求可逆\",{\"1\":{\"43\":1}}],[\"与指数退避相比\",{\"1\":{\"128\":1}}],[\"与指数退避重试策略保持一致\",{\"1\":{\"128\":1}}],[\"与其他重试策略配合使用\",{\"1\":{\"122\":1}}],[\"退避时间都会增加\",{\"1\":{\"128\":1}}],[\"退出时自动销毁注册中心实例\",{\"1\":{\"26\":1}}],[\"退出时执行擦欧总\",{\"1\":{\"26\":1,\"86\":1}}],[\"线性重试可能无法有效地抑制重试请求\",{\"1\":{\"128\":1}}],[\"线性重试的优点是\",{\"1\":{\"128\":1}}],[\"线性重试策略是一个不错的选择\",{\"1\":{\"128\":1}}],[\"线性重试策略\",{\"0\":{\"128\":1},\"1\":{\"122\":1}}],[\"线性增加退避时间\",{\"1\":{\"128\":1}}],[\"线性增加\",{\"1\":{\"128\":1}}],[\"表达式或方法引用来创建任务对象\",{\"1\":{\"127\":1}}],[\"表示需要重试的方法调用\",{\"1\":{\"124\":1}}],[\"表示请求在哈希环上的位置\",{\"1\":{\"116\":1}}],[\"表示该注解会在运行时被\",{\"1\":{\"14\":1}}],[\"灵活性\",{\"1\":{\"127\":1}}],[\"灵活地配置不同的序列化\",{\"1\":{\"25\":1}}],[\"毫秒\",{\"1\":{\"127\":1}}],[\"初始值为\",{\"1\":{\"128\":1}}],[\"初始退避时间1秒\",{\"1\":{\"128\":1}}],[\"初始退避时间100毫秒\",{\"1\":{\"127\":1}}],[\"初始退避时间为\",{\"1\":{\"127\":1}}],[\"初始化权重\",{\"1\":{\"118\":1}}],[\"初始化主要是为了创建etcd的client和kvclient对象\",{\"1\":{\"82\":1}}],[\"初始化方法\",{\"1\":{\"26\":1}}],[\"初始化\",{\"0\":{\"82\":1},\"1\":{\"26\":1,\"29\":2,\"79\":2,\"108\":1}}],[\"初始化rpc配置信息\",{\"1\":{\"25\":1}}],[\"初始化rpc框架\",{\"1\":{\"18\":1}}],[\"计算本次重试的退避时间\",{\"1\":{\"127\":1}}],[\"计数器\",{\"1\":{\"115\":1,\"117\":1,\"118\":1}}],[\"记录当前重试次数\",{\"1\":{\"127\":1}}],[\"添加了重试监听器\",{\"1\":{\"126\":1}}],[\"添加了一个重试监听器\",{\"1\":{\"126\":1}}],[\"添加监听\",{\"1\":{\"88\":1}}],[\"次\",{\"1\":{\"126\":3,\"127\":1}}],[\"遇到任何异常类型都进行重试\",{\"1\":{\"126\":1}}],[\"引入google的guava\",{\"1\":{\"124\":1}}],[\"引入框架的项目应该能够通过配置文件自定义\",{\"1\":{\"24\":1}}],[\"决定是否需要重试\",{\"1\":{\"124\":1}}],[\"包括以下方法\",{\"1\":{\"124\":1}}],[\"包含服务名称\",{\"1\":{\"77\":1}}],[\"包含了服务名\",{\"1\":{\"4\":1}}],[\"什么条件停止重试\",{\"1\":{\"123\":1}}],[\"什么条件重试\",{\"1\":{\"123\":1}}],[\"什么时候\",{\"1\":{\"123\":2}}],[\"什么是重试机制\",{\"0\":{\"120\":1}}],[\"什么是半包粘包\",{\"0\":{\"105\":1}}],[\"什么是注册中心\",{\"0\":{\"72\":1}}],[\"什么是接口mock服务\",{\"0\":{\"68\":1}}],[\"什么是容错机制\",{\"0\":{\"32\":1}}],[\"什么是spi机制\",{\"0\":{\"7\":1}}],[\"什么是代理\",{\"0\":{\"2\":1}}],[\"什么是负载均衡\",{\"0\":{\"110\":1},\"1\":{\"0\":2}}],[\"断路器重试策略\",{\"1\":{\"122\":1}}],[\"介于固定间隔和指数退避之间\",{\"1\":{\"122\":1}}],[\"秒的固定时间间隔\",{\"1\":{\"126\":1}}],[\"秒等\",{\"1\":{\"122\":2}}],[\"秒\",{\"1\":{\"122\":6,\"126\":1,\"128\":2}}],[\"固定时间间隔重试策略\",{\"1\":{\"126\":1}}],[\"固定时间间隔\",{\"1\":{\"126\":1}}],[\"固定重试间隔策略\",{\"0\":{\"126\":1}}],[\"固定间隔重试策略\",{\"1\":{\"122\":1}}],[\"固定权重\",{\"1\":{\"118\":1}}],[\"另外\",{\"1\":{\"121\":1}}],[\"符合条件的进行重试\",{\"1\":{\"121\":1}}],[\"试机制要求被调用的服务具有幂等性\",{\"1\":{\"121\":1}}],[\"之后它会向这个节点发送请求信息\",{\"1\":{\"120\":1}}],[\"之间未被监听\",{\"1\":{\"88\":1}}],[\"选出最大的权重\",{\"1\":{\"118\":1}}],[\"选择合适的重试策略或者组合使用多种策略\",{\"1\":{\"122\":1}}],[\"选择一个节点\",{\"1\":{\"120\":1}}],[\"选择最接近且大于hash的节点\",{\"1\":{\"116\":1}}],[\"选择服务调用\",{\"1\":{\"113\":1}}],[\"选择当前连接数最小的服务实例进行分配\",{\"1\":{\"112\":1}}],[\"9\",{\"1\":{\"118\":1}}],[\"9<\",{\"1\":{\"12\":1}}],[\"轮次\",{\"1\":{\"118\":1}}],[\"轮询算法的实现\",{\"1\":{\"115\":1}}],[\"轮询负载均衡器\",{\"0\":{\"115\":1},\"1\":{\"115\":1}}],[\"轮询\",{\"1\":{\"74\":1,\"112\":1}}],[\"平滑加权轮询\",{\"0\":{\"118\":1}}],[\"继续循环\",{\"1\":{\"117\":1}}],[\"继续重试下一个\",{\"1\":{\"40\":1,\"41\":1}}],[\"否则我们需要重置下这个请求的超时时间\",{\"1\":{\"121\":1}}],[\"否则就一直重试下去\",{\"1\":{\"120\":1}}],[\"否则减去权重值\",{\"1\":{\"117\":1}}],[\"否则将找不到实现类\",{\"1\":{\"3\":1}}],[\"总权重\",{\"1\":{\"117\":1,\"118\":1}}],[\"总的来说\",{\"1\":{\"16\":1,\"37\":1}}],[\"说白了就是求6在数组2\",{\"1\":{\"117\":1}}],[\"算出来pos=6\",{\"1\":{\"117\":1}}],[\"剩下的就是b了\",{\"1\":{\"117\":1}}],[\"小于2那么就是a\",{\"1\":{\"117\":1}}],[\"问题是\",{\"1\":{\"117\":1}}],[\"进去\",{\"1\":{\"117\":1}}],[\"进行退避延迟\",{\"1\":{\"127\":1}}],[\"进行更精细的分发\",{\"1\":{\"111\":1}}],[\"进行分发\",{\"1\":{\"111\":1}}],[\"进行处理\",{\"1\":{\"108\":1}}],[\"进行动态加载类\",{\"1\":{\"10\":1}}],[\"把a放两个进去\",{\"1\":{\"117\":1}}],[\"把二进制的消息体逆向还原成请求对象\",{\"1\":{\"43\":1}}],[\"权重越大的实例\",{\"1\":{\"117\":1}}],[\"权重占比为\",{\"1\":{\"117\":1}}],[\"权重等关键属性\",{\"1\":{\"77\":1}}],[\"冷启动问题\",{\"1\":{\"116\":1}}],[\"往往会路由到同一个服务实例上\",{\"1\":{\"116\":1}}],[\"往往同步开始开发\",{\"1\":{\"69\":1}}],[\"个虚拟节点\",{\"1\":{\"116\":1}}],[\"虚拟节点数\",{\"1\":{\"116\":1}}],[\"虚拟节点环的构建\",{\"1\":{\"116\":1}}],[\"虚拟机等技术\",{\"1\":{\"32\":1}}],[\"大于\",{\"1\":{\"127\":1}}],[\"大于等于该哈希值的点即可\",{\"1\":{\"116\":1}}],[\"大多数请求都要跟着变\",{\"1\":{\"116\":1}}],[\"好处在于\",{\"1\":{\"116\":1}}],[\"放入到环上面\",{\"1\":{\"116\":1}}],[\"放入serviceregisterinfos里面\",{\"1\":{\"29\":1}}],[\"取模\",{\"1\":{\"117\":1}}],[\"取模轮询\",{\"1\":{\"115\":1}}],[\"取消注册服务\",{\"1\":{\"79\":1}}],[\"随机重试策略\",{\"1\":{\"122\":1}}],[\"随机负载均衡器\",{\"0\":{\"114\":1},\"1\":{\"114\":1}}],[\"随机选择一个服务实例进行分配\",{\"1\":{\"112\":1}}],[\"随机\",{\"0\":{\"117\":1},\"1\":{\"112\":1}}],[\"随机等不同形式\",{\"1\":{\"32\":1}}],[\"随机等\",{\"1\":{\"25\":1}}],[\"按照请求顺序依次分配到各个服务实例\",{\"1\":{\"112\":1}}],[\"按照消息协议的格式进行解析\",{\"1\":{\"108\":1}}],[\"七层通过虚拟的\",{\"1\":{\"111\":1}}],[\"七层负载均衡根据应用层信息\",{\"1\":{\"111\":1}}],[\"四层通过虚拟\",{\"1\":{\"111\":1}}],[\"四层负载均衡直接根据传输层信息\",{\"1\":{\"111\":1}}],[\"三层负载均衡会通过一个虚拟\",{\"1\":{\"111\":1}}],[\"二层负载均衡会通过一个虚拟\",{\"1\":{\"111\":1}}],[\"二进制序列化\",{\"1\":{\"44\":1}}],[\"尽量保证接口能够成功执行\",{\"1\":{\"121\":1}}],[\"尽量要选择使用byte\",{\"1\":{\"94\":1}}],[\"尽管七层负载均衡需要更多时间和计算资源\",{\"1\":{\"111\":1}}],[\"端口接收请求\",{\"1\":{\"111\":1}}],[\"端口\",{\"1\":{\"111\":1}}],[\"端口等\",{\"1\":{\"29\":1,\"72\":1}}],[\"诸如cdn\",{\"1\":{\"111\":1}}],[\"连接异常等\",{\"1\":{\"121\":1}}],[\"连接中接收到的二进制数据流\",{\"1\":{\"108\":1}}],[\"连接中接收到的二进制数据\",{\"1\":{\"108\":1}}],[\"连接检测等方式实现\",{\"1\":{\"74\":1}}],[\"判断每次消息的长度是否符合我们的预期\",{\"1\":{\"107\":1}}],[\"收到消息多了\",{\"1\":{\"105\":1}}],[\"收到消息少了\",{\"1\":{\"105\":1}}],[\"粘包\",{\"1\":{\"105\":1}}],[\"粘包等问题的处理\",{\"1\":{\"100\":1}}],[\"半包\",{\"1\":{\"105\":1}}],[\"半包粘包\",{\"0\":{\"104\":1}}],[\"举例\",{\"1\":{\"105\":1}}],[\"直到拿到了结果才会继续往下执行\",{\"1\":{\"103\":1}}],[\"直接返回失败结果\",{\"1\":{\"122\":1}}],[\"直接返回一个安全的默认值或者空值\",{\"1\":{\"34\":1}}],[\"直接抛异常出去\",{\"1\":{\"38\":1}}],[\"直接new出userserviceproxy对象进行调用\",{\"1\":{\"3\":1}}],[\"阻塞代码responsefuture\",{\"1\":{\"103\":1}}],[\"阻止其扩散\",{\"1\":{\"33\":1}}],[\"反应式的\",{\"1\":{\"103\":1}}],[\"反序列化的性能\",{\"1\":{\"49\":1}}],[\"反序列化任何类型的对象\",{\"1\":{\"49\":1}}],[\"反序列化则从字节数组中重新构建java对象\",{\"1\":{\"47\":1}}],[\"反序列化异常\",{\"1\":{\"46\":1}}],[\"反序列化后的对象\",{\"1\":{\"46\":1}}],[\"反序列化\",{\"1\":{\"43\":2,\"46\":1}}],[\"得到实际的索引位置\",{\"1\":{\"115\":1}}],[\"得到\",{\"1\":{\"102\":1}}],[\"封装返回结果\",{\"1\":{\"102\":1}}],[\"处理临时性的错误\",{\"1\":{\"121\":1}}],[\"处理请求\",{\"1\":{\"102\":2}}],[\"处理连接请求\",{\"1\":{\"100\":1}}],[\"校验魔数\",{\"1\":{\"99\":1}}],[\"404\",{\"1\":{\"131\":1}}],[\"40856284\",{\"1\":{\"0\":1}}],[\"4\",{\"1\":{\"99\":1,\"118\":10,\"122\":1}}],[\"4个字节\",{\"1\":{\"98\":1}}],[\"字段\",{\"1\":{\"98\":1}}],[\"字节\",{\"1\":{\"94\":1}}],[\"字节数组\",{\"1\":{\"46\":1}}],[\"长度\",{\"1\":{\"98\":1,\"108\":1}}],[\"长时间没有处理完成\",{\"1\":{\"36\":1}}],[\"依次从中读取对应的数据\",{\"1\":{\"99\":1}}],[\"依次向缓冲区写入字节\",{\"1\":{\"98\":1}}],[\"依赖安装\",{\"1\":{\"70\":1}}],[\"编码器\",{\"1\":{\"129\":1}}],[\"编码请求\",{\"1\":{\"101\":1}}],[\"编码\",{\"1\":{\"98\":1,\"102\":1}}],[\"编写相应的容错逻辑\",{\"1\":{\"37\":1}}],[\"编写工具类\",{\"1\":{\"10\":1}}],[\"携带实际的业务数据\",{\"1\":{\"94\":1}}],[\"便于接收方准确获取完整的消息内容\",{\"1\":{\"94\":1}}],[\"便于接收方与对应的请求进行关联\",{\"1\":{\"94\":1}}],[\"便于接收方进行正确的反序列化\",{\"1\":{\"94\":1}}],[\"请求粘性\",{\"1\":{\"116\":1}}],[\"请求路由\",{\"1\":{\"116\":1}}],[\"请求参数\",{\"1\":{\"113\":1,\"116\":1}}],[\"请求头\",{\"1\":{\"111\":1}}],[\"请求头的大小$=1+1+1+1+1+8+4=17字节$\",{\"1\":{\"94\":1}}],[\"请求发送\",{\"0\":{\"103\":1}}],[\"请求处理器的主要作用是接受请求\",{\"1\":{\"102\":1}}],[\"请求处理器\",{\"0\":{\"102\":1}}],[\"请求\",{\"1\":{\"96\":2}}],[\"请求或响应对象\",{\"1\":{\"96\":1}}],[\"请求id\",{\"1\":{\"94\":1}}],[\"请求重试和超时控制\",{\"1\":{\"32\":1}}],[\"状态\",{\"1\":{\"94\":1,\"96\":1}}],[\"状态检查等手段来检测故障\",{\"1\":{\"32\":1}}],[\"响应时间更短\",{\"1\":{\"128\":1}}],[\"响应等\",{\"1\":{\"98\":1}}],[\"响应\",{\"1\":{\"94\":1,\"96\":1}}],[\"魔数\",{\"1\":{\"94\":1,\"96\":1,\"98\":1}}],[\"位\",{\"1\":{\"94\":1}}],[\"消息解码\",{\"0\":{\"99\":1}}],[\"消息的请求\",{\"1\":{\"98\":1}}],[\"消息的状态\",{\"1\":{\"98\":1}}],[\"消息的类型\",{\"1\":{\"98\":1}}],[\"消息协议的版本号\",{\"1\":{\"98\":1}}],[\"消息编码\",{\"0\":{\"97\":1,\"98\":1}}],[\"消息类型\",{\"1\":{\"96\":1}}],[\"消息头长度\",{\"1\":{\"108\":1}}],[\"消息头的\",{\"1\":{\"98\":1}}],[\"消息头\",{\"1\":{\"96\":1}}],[\"消息结构写入buffer\",{\"1\":{\"129\":1}}],[\"消息结构代码\",{\"0\":{\"96\":1},\"1\":{\"108\":1}}],[\"消息结构设计\",{\"0\":{\"94\":1},\"1\":{\"94\":1,\"129\":1}}],[\"消息体的序列化方式\",{\"1\":{\"98\":1}}],[\"消息体\",{\"1\":{\"96\":1}}],[\"消息体内容\",{\"1\":{\"94\":1}}],[\"消息体长度\",{\"1\":{\"94\":1,\"96\":1}}],[\"消费端使用\",{\"1\":{\"113\":1,\"114\":1,\"115\":1,\"116\":1}}],[\"消费端\",{\"1\":{\"79\":1}}],[\"消费者去注册中心服务发现\",{\"1\":{\"72\":1}}],[\"消费者\",{\"1\":{\"28\":1,\"56\":1}}],[\"消费者启动只需要初始化配置\",{\"1\":{\"30\":1}}],[\"消费者启动\",{\"0\":{\"20\":1}}],[\"传输信息不完整\",{\"1\":{\"94\":1}}],[\"传输效率高\",{\"1\":{\"93\":1}}],[\"传输控制协议\",{\"1\":{\"90\":1}}],[\"场景\",{\"1\":{\"91\":1}}],[\"标识消息体的长度\",{\"1\":{\"94\":1}}],[\"标识消息体采用的序列化方式\",{\"1\":{\"94\":1}}],[\"标识当前消息的唯一标识符\",{\"1\":{\"94\":1}}],[\"标识当前消息的状态\",{\"1\":{\"94\":1}}],[\"标识当前消息的类型\",{\"1\":{\"94\":1}}],[\"标识当前消息是\",{\"1\":{\"94\":1}}],[\"标准的\",{\"1\":{\"91\":1}}],[\"标记语言序列化\",{\"1\":{\"44\":1}}],[\"范式\",{\"1\":{\"90\":1}}],[\"基于字节流的传输层通信协议\",{\"1\":{\"90\":1}}],[\"基于动态代理\",{\"1\":{\"0\":1}}],[\"超过则停止重试\",{\"1\":{\"126\":2}}],[\"超过限制则放弃重试\",{\"1\":{\"122\":1}}],[\"超过的长度留到下一次接收消息的时候再读取\",{\"1\":{\"108\":1}}],[\"超文本传输协议\",{\"1\":{\"90\":1}}],[\"超时时间\",{\"1\":{\"78\":2}}],[\"超时控制\",{\"1\":{\"36\":1}}],[\"超时后放弃重试\",{\"1\":{\"32\":1}}],[\"续约失败\",{\"1\":{\"87\":1}}],[\"节点数一变\",{\"1\":{\"116\":1}}],[\"节点没有过期\",{\"1\":{\"87\":1}}],[\"节点已经过期了\",{\"1\":{\"87\":1}}],[\"节点监听功能\",{\"1\":{\"79\":1}}],[\"每个请求也可以计算哈希值映射到环上一个点\",{\"1\":{\"116\":1}}],[\"每个节点计算哈希值\",{\"1\":{\"116\":1}}],[\"每个类都要去写实现类\",{\"1\":{\"3\":1}}],[\"每次重试时退避时间翻倍\",{\"1\":{\"127\":1}}],[\"每次重试的时间间隔增长较缓慢\",{\"1\":{\"128\":1}}],[\"每次重试的时间间隔是随机的\",{\"1\":{\"122\":1}}],[\"每次重试的时间间隔呈指数增长\",{\"1\":{\"122\":1}}],[\"每次重试之间都有\",{\"1\":{\"126\":1}}],[\"每次重试之间固定间隔\",{\"1\":{\"126\":1}}],[\"每次重试之间固定一个时间间隔\",{\"1\":{\"122\":1}}],[\"每次重试之间的时间间隔是线性增加的\",{\"1\":{\"122\":1}}],[\"每次都重新构建\",{\"1\":{\"116\":1}}],[\"每次调用\",{\"1\":{\"115\":1}}],[\"每次调用随机函数\",{\"1\":{\"114\":1}}],[\"每次维护集合的信息\",{\"1\":{\"87\":1}}],[\"重置\",{\"1\":{\"108\":1}}],[\"重置parser\",{\"1\":{\"108\":2}}],[\"重置过期时间\",{\"1\":{\"87\":1}}],[\"重点\",{\"0\":{\"89\":1}}],[\"重新通过负载均衡选择一个节点发送请求消息\",{\"1\":{\"120\":1}}],[\"重新\",{\"1\":{\"87\":1}}],[\"重试间隔变化平缓\",{\"1\":{\"128\":1}}],[\"重试第\",{\"1\":{\"126\":1}}],[\"重试监听\",{\"1\":{\"126\":1}}],[\"重试的方法\",{\"1\":{\"124\":1,\"125\":1,\"126\":1}}],[\"重试之后要做什么\",{\"1\":{\"123\":1}}],[\"重试时间\",{\"1\":{\"123\":1}}],[\"重试次数限制策略\",{\"1\":{\"122\":1}}],[\"重试次数等\",{\"1\":{\"37\":1}}],[\"重试机制有哪些\",{\"0\":{\"122\":1}}],[\"重试机制是提高分布式系统可用性和容错性的一种有效手段\",{\"1\":{\"121\":1}}],[\"重试机制可以将这部分逻辑封装在rpc框架内部\",{\"1\":{\"121\":1}}],[\"重试机制可以自动处理这类临时性错误\",{\"1\":{\"121\":1}}],[\"重试机制可以让系统自动重新发起请求\",{\"1\":{\"121\":1}}],[\"重试机制的主要原因有以下几点\",{\"1\":{\"121\":1}}],[\"重试机制\",{\"1\":{\"120\":1}}],[\"重试机制实现\",{\"0\":{\"119\":1}}],[\"重试metainfo之外的其他服务\",{\"1\":{\"40\":1,\"41\":1}}],[\"重试其他服务\",{\"1\":{\"40\":1,\"41\":1}}],[\"重试本身就是容错的降级策略\",{\"1\":{\"36\":1}}],[\"重试策略接口\",{\"1\":{\"124\":1}}],[\"重试策略接口定义\",{\"0\":{\"124\":1}}],[\"重试策略实现\",{\"0\":{\"123\":1}}],[\"重试策略可以是固定时间间隔\",{\"1\":{\"32\":1}}],[\"重试策略\",{\"1\":{\"16\":1,\"26\":1,\"124\":1}}],[\"重试\",{\"1\":{\"2\":1,\"16\":1,\"36\":1,\"40\":1,\"41\":1,\"124\":1,\"125\":1,\"126\":1}}],[\"重试与容错\",{\"1\":{\"0\":1}}],[\"认为目标系统故障或者不可用了\",{\"1\":{\"87\":1}}],[\"执行远程调用\",{\"1\":{\"127\":1}}],[\"执行重试操作\",{\"1\":{\"126\":1}}],[\"执行处理\",{\"1\":{\"108\":2}}],[\"执行操作呢\",{\"1\":{\"86\":1}}],[\"执行注册服务等操作了\",{\"1\":{\"19\":1}}],[\"被动下线\",{\"1\":{\"86\":1}}],[\"删除所有注册的服务\",{\"1\":{\"86\":1}}],[\"下一次重试时间\",{\"1\":{\"123\":1}}],[\"下发的所有服务节点建立长连接\",{\"1\":{\"110\":1}}],[\"下线失败\",{\"1\":{\"86\":1}}],[\"下线时\",{\"1\":{\"86\":1}}],[\"下面是provider提供的具体代码\",{\"1\":{\"3\":1}}],[\"前缀搜索\",{\"1\":{\"85\":1}}],[\"前端\",{\"1\":{\"69\":1}}],[\"前端开发中使用\",{\"1\":{\"69\":1}}],[\"前端和后端一般定好\",{\"1\":{\"69\":1}}],[\"写入体信息到结果\",{\"1\":{\"108\":2}}],[\"写入头信息到结果\",{\"1\":{\"108\":2}}],[\"写入\",{\"1\":{\"98\":1}}],[\"写入缓存\",{\"1\":{\"85\":1}}],[\"写入缓存中\",{\"1\":{\"85\":1}}],[\"写缓存\",{\"1\":{\"85\":1}}],[\"拿到结果之后再把服务进行解析为list<servicemetainfo>的样子\",{\"1\":{\"85\":1}}],[\"清空缓存\",{\"1\":{\"85\":1}}],[\"8个字节\",{\"1\":{\"98\":1}}],[\"8个bit位\",{\"1\":{\"94\":1}}],[\"8bit\",{\"1\":{\"94\":1}}],[\"8082\",{\"1\":{\"101\":1}}],[\"8080\",{\"1\":{\"3\":2,\"26\":1,\"100\":1}}],[\"80\",{\"1\":{\"90\":1}}],[\"8\",{\"1\":{\"83\":2,\"84\":1,\"85\":2,\"86\":1,\"87\":2,\"88\":1,\"118\":1,\"122\":1}}],[\"值是\",{\"1\":{\"83\":1}}],[\"键是\",{\"1\":{\"83\":1}}],[\"根节点\",{\"1\":{\"81\":1}}],[\"根据异常触发重试\",{\"1\":{\"120\":1}}],[\"根据每个服务实例的权重\",{\"1\":{\"117\":1}}],[\"根据服务实例的权重进行轮询分配\",{\"1\":{\"112\":1}}],[\"根据服务类\",{\"1\":{\"5\":1,\"70\":1}}],[\"根据服务类获取代理对象\",{\"1\":{\"5\":1}}],[\"根据网络层协议类型\",{\"1\":{\"111\":1}}],[\"根据前缀搜索\",{\"1\":{\"85\":1}}],[\"根据方法的返回值类型\",{\"1\":{\"70\":1}}],[\"根据\",{\"1\":{\"29\":1,\"111\":1}}],[\"监听key的变化\",{\"1\":{\"85\":1}}],[\"监听的key集合\",{\"1\":{\"81\":1}}],[\"监听服务节点\",{\"1\":{\"79\":1}}],[\"监控报警和自愈机制\",{\"1\":{\"32\":1}}],[\"监控等场景中使用\",{\"1\":{\"25\":1}}],[\"监控等\",{\"1\":{\"2\":1}}],[\"密码\",{\"1\":{\"78\":2}}],[\"发起\",{\"1\":{\"110\":1}}],[\"发现等功能提供了基础数据模型\",{\"1\":{\"77\":1}}],[\"发送响应\",{\"1\":{\"102\":1}}],[\"发送数据\",{\"1\":{\"101\":1}}],[\"发送tcp请求\",{\"1\":{\"4\":1,\"40\":1,\"101\":1,\"103\":1}}],[\"发送请求\",{\"1\":{\"3\":2}}],[\"云原生应用可以保持更为一致的运行时间\",{\"1\":{\"76\":1}}],[\"协调向主机调度的工作\",{\"1\":{\"76\":1}}],[\"协议版本\",{\"1\":{\"96\":1}}],[\"协议消息编码错误\",{\"1\":{\"102\":1}}],[\"协议消息解码错误\",{\"1\":{\"102\":1}}],[\"协议消息解码器\",{\"1\":{\"99\":1}}],[\"协议消息码错误\",{\"1\":{\"101\":1}}],[\"协议消息头\",{\"1\":{\"96\":1}}],[\"协议消息结构\",{\"1\":{\"96\":1}}],[\"协议的版本\",{\"1\":{\"94\":1}}],[\"协议的消息\",{\"1\":{\"94\":1}}],[\"协议虽然使用广泛\",{\"1\":{\"91\":1}}],[\"协议\",{\"1\":{\"2\":1}}],[\"读完了之后再重置一下\",{\"1\":{\"108\":1}}],[\"读一个int\",{\"1\":{\"108\":1}}],[\"读缓存\",{\"1\":{\"85\":1}}],[\"读作\",{\"1\":{\"76\":1}}],[\"读取消息体的长度\",{\"1\":{\"108\":2}}],[\"读取数据并写入到其中\",{\"1\":{\"76\":1}}],[\"读取\",{\"1\":{\"26\":2}}],[\"读取配置文件的完整代码如下\",{\"1\":{\"26\":1}}],[\"读取配置文件失败\",{\"1\":{\"26\":1}}],[\"读取yml文件需要引入依赖\",{\"1\":{\"26\":1}}],[\"读取和使用\",{\"1\":{\"14\":1,\"15\":1,\"16\":1}}],[\"读取每个资源文件\",{\"1\":{\"10\":1}}],[\"稳定性\",{\"1\":{\"75\":1}}],[\"技术选型etcd\",{\"0\":{\"75\":1}}],[\"技术都可以算得上是容错\",{\"1\":{\"36\":1}}],[\"心跳检测\",{\"0\":{\"87\":1},\"1\":{\"74\":1,\"79\":2,\"83\":1}}],[\"异步等手段来提高注册中心的吞吐量和响应速度\",{\"1\":{\"74\":1}}],[\"异常处理\",{\"1\":{\"127\":1,\"128\":1}}],[\"异常捕获\",{\"1\":{\"126\":1}}],[\"异常信息仅仅通过日志的形式记录下来\",{\"1\":{\"39\":1}}],[\"异常\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1}}],[\"具备良好的性能表现\",{\"1\":{\"74\":1}}],[\"具体计算方式为\",{\"1\":{\"128\":1}}],[\"具体工作流程如下\",{\"1\":{\"127\":1}}],[\"具体使用\",{\"1\":{\"108\":1}}],[\"具体为\",{\"1\":{\"108\":1}}],[\"具体的自定义的注册逻辑写在registerbeandefinitions方法里面\",{\"1\":{\"18\":1}}],[\"具体的代码如下\",{\"1\":{\"10\":1}}],[\"具体应用场景\",{\"1\":{\"9\":1}}],[\"具体实现如下为consistenthashloadbalancer\",{\"1\":{\"116\":1}}],[\"具体实现如下\",{\"1\":{\"29\":1,\"126\":1}}],[\"具体实现\",{\"1\":{\"4\":1}}],[\"具体在设置methodname为调用的函数\",{\"1\":{\"3\":1}}],[\"流量控制等\",{\"1\":{\"74\":1}}],[\"流行的开源日志框架\",{\"1\":{\"9\":1}}],[\"路由规则等高级服务治理功能\",{\"1\":{\"74\":1}}],[\"版本\",{\"1\":{\"74\":1,\"77\":1}}],[\"版本号\",{\"1\":{\"26\":1,\"94\":1}}],[\"最多重试\",{\"1\":{\"126\":2}}],[\"最简单的办法\",{\"1\":{\"117\":1}}],[\"最终返回对应虚拟节点所映射的服务实例\",{\"1\":{\"116\":1}}],[\"最小连接数\",{\"1\":{\"112\":1}}],[\"最小活跃连接数等\",{\"1\":{\"74\":1}}],[\"最值得注意的是\",{\"1\":{\"76\":1}}],[\"最后调用\",{\"1\":{\"126\":1}}],[\"最后1<5符合\",{\"1\":{\"117\":1}}],[\"最后还可以\",{\"1\":{\"85\":1}}],[\"最后还需要在启动类上面使用\",{\"1\":{\"21\":1}}],[\"最后返回类型为t的rpcresponse对象\",{\"1\":{\"48\":1}}],[\"最后将反序列化后的对象设置回rpcresponse的data字段\",{\"1\":{\"48\":1}}],[\"最后将这个代理对象强制转换为目标类型\",{\"1\":{\"5\":1}}],[\"最后注册一个\",{\"1\":{\"26\":1}}],[\"最后\",{\"1\":{\"4\":1,\"20\":1,\"48\":1}}],[\"健康检查可以通过心跳机制\",{\"1\":{\"74\":1}}],[\"及时剔除下线或故障的服务\",{\"1\":{\"74\":1}}],[\"及时发现并报警异常\",{\"1\":{\"32\":1}}],[\"生态\",{\"1\":{\"73\":1}}],[\"生成特定的默认值对象\",{\"1\":{\"70\":1}}],[\"生成类可读性差\",{\"1\":{\"44\":2}}],[\"生成代理对象失败\",{\"1\":{\"20\":1}}],[\"生成代理对象\",{\"1\":{\"20\":2}}],[\"曾广泛应用于\",{\"1\":{\"73\":1}}],[\"开源的应用管理与服务治理平台\",{\"1\":{\"73\":1}}],[\"开源的服务注册中心\",{\"1\":{\"73\":1}}],[\"开发者只需要简单地在入口类上添加该注解\",{\"1\":{\"14\":1}}],[\"开发者可以根据具体需求\",{\"1\":{\"25\":1}}],[\"开发者可以通过设置注解属性来配置负载均衡\",{\"1\":{\"16\":1}}],[\"开发者可以通过设置这个属性的值来决定是否需要启动\",{\"1\":{\"14\":1}}],[\"开发者可以在自己的应用程序中开启\",{\"1\":{\"14\":1}}],[\"集合\",{\"1\":{\"81\":1}}],[\"集成了注册中心\",{\"1\":{\"73\":2}}],[\"集群容错\",{\"1\":{\"34\":1}}],[\"公司开源的分布式键值存储\",{\"1\":{\"73\":1}}],[\"公司开源的服务网格解决方案\",{\"1\":{\"73\":1}}],[\"公司内的服务化平台已经提供了较为完善的接口测试工具\",{\"1\":{\"69\":1}}],[\"广泛应用于\",{\"1\":{\"73\":1}}],[\"广播调用\",{\"1\":{\"34\":1}}],[\"灰度发布等高级特性\",{\"1\":{\"72\":1}}],[\"地址接收请求\",{\"1\":{\"111\":2}}],[\"地址\",{\"1\":{\"72\":1,\"77\":1,\"78\":1,\"111\":3}}],[\"工具来实现重试逻辑\",{\"1\":{\"126\":1}}],[\"工具进行接口的\",{\"1\":{\"69\":1}}],[\"工作在osi的第七层\",{\"1\":{\"90\":1}}],[\"工作在\",{\"1\":{\"90\":1}}],[\"工厂\",{\"1\":{\"70\":1}}],[\"帮助开发人员进行容错性测试\",{\"1\":{\"69\":1}}],[\"错误码等\",{\"1\":{\"69\":1}}],[\"错误信息等\",{\"1\":{\"37\":1}}],[\"未知\",{\"1\":{\"98\":1}}],[\"未提供\",{\"1\":{\"69\":1}}],[\"未加载\",{\"1\":{\"10\":1}}],[\"层和依赖的\",{\"1\":{\"69\":1}}],[\"各服务之间通过\",{\"1\":{\"69\":1}}],[\"各种json库直接使用\",{\"1\":{\"44\":1}}],[\"后端通过\",{\"1\":{\"69\":1}}],[\"​\",{\"1\":{\"69\":4}}],[\"要使用的\",{\"1\":{\"64\":1}}],[\"分配到的请求也越多\",{\"1\":{\"117\":1}}],[\"分配不同的请求量\",{\"1\":{\"117\":1}}],[\"分别从指定位置读出buffer\",{\"1\":{\"99\":1}}],[\"分别是\",{\"1\":{\"56\":1}}],[\"分布式\",{\"1\":{\"130\":1}}],[\"分布式部署等方式来提高可用性\",{\"1\":{\"74\":1}}],[\"分布式协调服务\",{\"1\":{\"73\":1}}],[\"分布式系统通常需要支持高并发访问和动态扩展\",{\"1\":{\"33\":1}}],[\"分布式系统面临各种不确定因素\",{\"1\":{\"33\":1}}],[\"分布式系统由多个独立组件构成\",{\"1\":{\"33\":1}}],[\"分布式系统需要使用容错机制主要有以下几个原因\",{\"1\":{\"33\":1}}],[\"项目创建\",{\"0\":{\"56\":1}}],[\"项目初始化\",{\"0\":{\"12\":1}}],[\"缓存\",{\"1\":{\"74\":1}}],[\"缓存schema\",{\"1\":{\"51\":1}}],[\"缓存预热等\",{\"1\":{\"34\":1,\"39\":1}}],[\"结合断路器模式\",{\"1\":{\"122\":1}}],[\"结合其他容错手段\",{\"1\":{\"32\":1}}],[\"结尾一定要加\",{\"1\":{\"85\":1}}],[\"结构如下\",{\"1\":{\"94\":1}}],[\"结构\",{\"1\":{\"51\":1}}],[\"6\",{\"1\":{\"51\":2,\"118\":7}}],[\"66<\",{\"1\":{\"50\":1}}],[\"6992867064952127524\",{\"1\":{\"0\":1}}],[\"尤其是当应用程序需要处理大量不同的类型时\",{\"1\":{\"49\":1}}],[\"因为服务列表可能会变化\",{\"1\":{\"116\":1}}],[\"因为我们在消息结构是这样设计的\",{\"1\":{\"108\":1}}],[\"因为我们设置了parser\",{\"1\":{\"108\":1}}],[\"因为etcd自带了key过期的机制\",{\"1\":{\"87\":1}}],[\"因为只有被注册的类型才能被序列化和反序列化\",{\"1\":{\"49\":1}}],[\"因为可能会反序列化未知或恶意的类型\",{\"1\":{\"49\":1}}],[\"因此定义如下\",{\"1\":{\"113\":1}}],[\"因此要尽量凑到整个字节\",{\"1\":{\"94\":1}}],[\"因此对于高性能的追求\",{\"1\":{\"93\":1}}],[\"因此我们的心跳检测只需要去定期的续约即可\",{\"1\":{\"87\":1}}],[\"因此使用threadlocal来保证每个线程都有一个独立的kryo实例\",{\"1\":{\"49\":1}}],[\"因此使用\",{\"1\":{\"49\":1}}],[\"因此需要一个统一的全局配置对象\",{\"1\":{\"24\":1}}],[\"时\",{\"1\":{\"49\":2}}],[\"设置最大重试次数\",{\"1\":{\"122\":1}}],[\"设置\",{\"1\":{\"108\":1}}],[\"设置要存储的键值对\",{\"1\":{\"83\":1}}],[\"设置为动态序列化和反序列化\",{\"1\":{\"49\":1}}],[\"设置动态序列化和反序列化类\",{\"1\":{\"49\":1}}],[\"设计自动化的故障修复和自愈流程\",{\"1\":{\"32\":1}}],[\"5是第几个服务器\",{\"1\":{\"117\":1}}],[\"5\",{\"1\":{\"49\":1,\"99\":1,\"101\":1,\"103\":1,\"117\":6,\"118\":18,\"127\":2,\"128\":1}}],[\"51cto\",{\"1\":{\"0\":2}}],[\"检查其实际类型是否与声明的类型不同\",{\"1\":{\"48\":1}}],[\"检查这些\",{\"1\":{\"20\":1}}],[\"同一个客户端的请求\",{\"1\":{\"116\":1}}],[\"同理\",{\"1\":{\"48\":1}}],[\"同时为了解决粘包的问题\",{\"1\":{\"99\":1}}],[\"同时我们需要设置过期时间30s\",{\"1\":{\"83\":1}}],[\"同时根据请求类型和序列化类型\",{\"1\":{\"43\":1}}],[\"同时向多个服务提供者发起并行调用\",{\"1\":{\"34\":1}}],[\"同时需要设置合理的超时时间\",{\"1\":{\"32\":1}}],[\"同时还负责初始化注册中心实例并确保其生命周期与\",{\"1\":{\"26\":1}}],[\"同时也要删除本地即集合\",{\"1\":{\"86\":1}}],[\"同时也会提取服务接口类和版本号等元信息\",{\"1\":{\"15\":1}}],[\"同时也可以获取\",{\"1\":{\"10\":1}}],[\"同时\",{\"1\":{\"5\":1}}],[\"所以就是第三个位置\",{\"1\":{\"117\":1}}],[\"所以\",{\"1\":{\"69\":1}}],[\"所以无法直接将linkedhashmap转换回原来的对象类型\",{\"1\":{\"48\":1}}],[\"所有服务都重试失败\",{\"1\":{\"40\":1,\"41\":1}}],[\"所有提供者的响应都会被收集和合并\",{\"1\":{\"34\":1}}],[\"原始类型信息在编译时会被擦除掉\",{\"1\":{\"48\":1}}],[\"原始对象类型信息在编译时已经丢失\",{\"1\":{\"48\":1}}],[\"原始对象\",{\"1\":{\"48\":2}}],[\"由于http本身是应用层协议\",{\"1\":{\"93\":1}}],[\"由于泛型擦除\",{\"1\":{\"48\":2}}],[\"由于泛型擦除的原因\",{\"1\":{\"48\":1}}],[\"由于object\",{\"1\":{\"48\":2}}],[\"循环处理每个参数的类型\",{\"1\":{\"48\":1}}],[\"导致反序列化时\",{\"1\":{\"48\":2}}],[\"导致级联故障\",{\"1\":{\"33\":1}}],[\"导入依赖\",{\"0\":{\"57\":1},\"1\":{\"48\":1,\"49\":1,\"50\":1,\"51\":1}}],[\"待序列化的对象\",{\"1\":{\"46\":1}}],[\"几种常见的序列化和反序列化协议\",{\"0\":{\"45\":1}}],[\"几乎所有编程语言都有json的解析和生成库\",{\"1\":{\"44\":1}}],[\"压缩效果好\",{\"1\":{\"44\":1}}],[\"安全改进\",{\"1\":{\"44\":1}}],[\"速度更快\",{\"1\":{\"117\":1}}],[\"速度快\",{\"1\":{\"44\":1}}],[\"速度慢\",{\"1\":{\"44\":2}}],[\"做一张表总结\",{\"1\":{\"44\":1}}],[\"调试较困难\",{\"1\":{\"44\":1}}],[\"调用端需要自行捕获异常\",{\"1\":{\"121\":1}}],[\"调用端在发起\",{\"1\":{\"120\":1}}],[\"调用请求\",{\"1\":{\"110\":1}}],[\"调用时\",{\"1\":{\"110\":1,\"120\":1}}],[\"调用时使用\",{\"1\":{\"29\":1}}],[\"调用存在于远程计算机上的某个对象\",{\"1\":{\"90\":1}}],[\"调用代理\",{\"1\":{\"70\":1}}],[\"调用链路信息\",{\"1\":{\"37\":1}}],[\"调用父类\",{\"1\":{\"20\":1}}],[\"调用中\",{\"1\":{\"19\":1}}],[\"调用\",{\"1\":{\"16\":1,\"29\":2}}],[\"调用的各种细节\",{\"1\":{\"4\":1}}],[\"调用等功能\",{\"1\":{\"4\":1}}],[\"文档相对较少\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"26\":4}}],[\"跨平台支持\",{\"1\":{\"44\":1}}],[\"跨语言支持一般\",{\"1\":{\"44\":1}}],[\"跨语言支持较复杂\",{\"1\":{\"44\":1}}],[\"跨语言\",{\"1\":{\"44\":9}}],[\"利用一致性哈希算法将请求均匀地分布到不同的服务实例上\",{\"1\":{\"112\":1}}],[\"利用jvm的shutdownhook来实现\",{\"1\":{\"86\":1}}],[\"利用spring\",{\"1\":{\"0\":1}}],[\"利于人工维护和调试\",{\"1\":{\"44\":1}}],[\"性能不如底层\",{\"1\":{\"93\":1}}],[\"性能优化\",{\"1\":{\"91\":1}}],[\"性能和扩展性\",{\"1\":{\"74\":1}}],[\"性能高\",{\"1\":{\"44\":2}}],[\"性能较高\",{\"1\":{\"44\":1}}],[\"性能相对较差\",{\"1\":{\"44\":1}}],[\"性能比json低\",{\"1\":{\"44\":1}}],[\"性能一般\",{\"1\":{\"44\":2}}],[\"适合高性能分布式rpc场景\",{\"1\":{\"44\":1}}],[\"适合大数据场景\",{\"1\":{\"44\":1}}],[\"适合分布式\",{\"1\":{\"44\":4}}],[\"适用场景\",{\"1\":{\"39\":1}}],[\"适用于比较通用的重试场景\",{\"1\":{\"126\":1}}],[\"适用于依赖服务不稳定的场景\",{\"1\":{\"122\":1}}],[\"适用于避免重试请求同步的场景\",{\"1\":{\"122\":1}}],[\"适用于一般的网络环境\",{\"1\":{\"122\":1}}],[\"适用于网络波动较大的场景\",{\"1\":{\"122\":1}}],[\"适用于对响应时间要求不太严格的场景\",{\"1\":{\"122\":1}}],[\"适用于对响应时间有严格要求的场景\",{\"1\":{\"34\":1}}],[\"适用于需要聚合多个服务结果的场景\",{\"1\":{\"34\":1}}],[\"高可扩展性\",{\"1\":{\"116\":1}}],[\"高可用性\",{\"1\":{\"75\":1}}],[\"高可用和容错\",{\"1\":{\"74\":1}}],[\"高可靠和高可用非要重要\",{\"1\":{\"75\":1}}],[\"高可靠性\",{\"1\":{\"75\":1}}],[\"高可靠分布式系统的关键所在\",{\"1\":{\"33\":1}}],[\"高可靠的分布式系统非常关键\",{\"1\":{\"32\":1}}],[\"高性能的rpc框架\",{\"1\":{\"44\":1}}],[\"高性能二进制序列化\",{\"1\":{\"44\":1}}],[\"高性能\",{\"1\":{\"44\":3}}],[\"格式可读\",{\"1\":{\"44\":2}}],[\"格式为\",{\"1\":{\"10\":1}}],[\"给予攻击者在服务器上运行代码的能力\",{\"1\":{\"44\":1}}],[\"答\",{\"1\":{\"44\":1}}],[\"已拼接为完整的buffer\",{\"1\":{\"108\":2}}],[\"已不再推荐使用\",{\"1\":{\"44\":2}}],[\"已经出现部分错误\",{\"1\":{\"36\":1}}],[\"有点类似于前缀和的思想\",{\"1\":{\"117\":1}}],[\"有多少个权重就添加多少个\",{\"1\":{\"117\":1}}],[\"有利于保持会话状态\",{\"1\":{\"116\":1}}],[\"有助于促进更加安全的自动更新\",{\"1\":{\"76\":1}}],[\"有助于实现更全面的自动化测试\",{\"1\":{\"69\":1}}],[\"有必要尝试探索一套\",{\"1\":{\"69\":1}}],[\"有限重试次数\",{\"1\":{\"126\":1}}],[\"有限重试等\",{\"1\":{\"25\":1}}],[\"有限制\",{\"1\":{\"44\":1}}],[\"有安全问题\",{\"1\":{\"44\":2}}],[\"占空间\",{\"1\":{\"44\":2}}],[\"缺点\",{\"1\":{\"44\":9}}],[\"缺点是\",{\"1\":{\"116\":1,\"128\":1}}],[\"缺点是容易受到syn\",{\"1\":{\"111\":1}}],[\"缺点是可能会丢失一些有价值的业务信息\",{\"1\":{\"39\":1}}],[\"缺点是实现相对复杂\",{\"1\":{\"4\":1}}],[\"缺点是如果目标类有变化\",{\"1\":{\"3\":1}}],[\"常见的重试策略主要包括以下几种\",{\"1\":{\"122\":1}}],[\"常见的负载均衡算法主要有以下几种\",{\"1\":{\"112\":1}}],[\"常见的负载均衡策略包括随机\",{\"1\":{\"74\":1}}],[\"常见的如haproxy\",{\"1\":{\"111\":1}}],[\"常见的序列化器对比情况如下\",{\"1\":{\"44\":1}}],[\"常见序列化器对比\",{\"0\":{\"44\":1}}],[\"经调查\",{\"1\":{\"44\":1}}],[\"整体的rpc框架如图\",{\"1\":{\"43\":1}}],[\"需提前转成可传输的二进制\",{\"1\":{\"43\":1}}],[\"需要维护虚拟节点环\",{\"1\":{\"116\":1}}],[\"需要重启节点才能重新注册\",{\"1\":{\"87\":1}}],[\"需要重新转换\",{\"1\":{\"48\":1}}],[\"需要让consumer和provider都导入如下依赖\",{\"1\":{\"57\":1}}],[\"需要定义idl\",{\"1\":{\"44\":1}}],[\"需要定义schema\",{\"1\":{\"44\":1}}],[\"需要先定义数据结构消息格式\",{\"1\":{\"44\":1}}],[\"需要工具辅助\",{\"1\":{\"44\":2}}],[\"需要实现serializable接口\",{\"1\":{\"44\":1}}],[\"需要实现与目标类相同的接口\",{\"1\":{\"3\":1}}],[\"需要注意的是\",{\"1\":{\"28\":1}}],[\"需要注册服务\",{\"1\":{\"19\":1}}],[\"需要启动server\",{\"1\":{\"14\":1,\"21\":1}}],[\"需要使用\",{\"1\":{\"10\":1}}],[\"需要使用反射等高级编程技术\",{\"1\":{\"4\":1}}],[\"需要在classpath下的meta\",{\"1\":{\"7\":1}}],[\"网络层区分负载均衡\",{\"1\":{\"111\":1}}],[\"网络传输设计\",{\"0\":{\"93\":1}}],[\"网络传输速度快\",{\"1\":{\"44\":1}}],[\"网络传输的数据须是二进制数据\",{\"1\":{\"43\":1}}],[\"网络服务端口号等\",{\"1\":{\"24\":1}}],[\"那么我就可以前缀和先预处理\",{\"1\":{\"117\":1}}],[\"那么我们可以引入虚拟节点\",{\"1\":{\"116\":1}}],[\"那么我们就读取从位置13开始的数据\",{\"1\":{\"108\":1}}],[\"那么我们就留到下一次再读取\",{\"1\":{\"107\":1}}],[\"那么我们需要更新消费端缓存\",{\"1\":{\"88\":1}}],[\"那么4\",{\"1\":{\"117\":1}}],[\"那么6\",{\"1\":{\"117\":1}}],[\"那么他应该是c服务器\",{\"1\":{\"117\":1}}],[\"那么它会动态计算哈希值\",{\"1\":{\"116\":1}}],[\"那么etcd会自动删除过期key\",{\"1\":{\"87\":1}}],[\"那么就\",{\"1\":{\"87\":1}}],[\"那么就去搜索\",{\"1\":{\"85\":1}}],[\"那么直接获取\",{\"1\":{\"85\":1}}],[\"那么会影响到所有服务调用\",{\"1\":{\"75\":1}}],[\"那么可以限制请求的频率数量来进行保护\",{\"1\":{\"36\":1}}],[\"那就直接抛异常\",{\"1\":{\"40\":1}}],[\"都会使用\",{\"1\":{\"115\":1}}],[\"都需要有代理服务器\",{\"1\":{\"111\":1}}],[\"都应该可以支持使用java的spi机制进行动态加载\",{\"1\":{\"79\":1}}],[\"都是尝试其他服务\",{\"1\":{\"41\":1}}],[\"都可以重试一次\",{\"1\":{\"40\":1}}],[\"都采用了spi机制\",{\"1\":{\"9\":1}}],[\"能够提高系统的整体可靠性\",{\"1\":{\"121\":1}}],[\"能够快速恢复服务的正常运行\",{\"1\":{\"40\":1}}],[\"能够获取\",{\"1\":{\"18\":1}}],[\"故障转移\",{\"1\":{\"40\":2}}],[\"故障恢复是容错机制的一个重要组成部分\",{\"1\":{\"40\":1}}],[\"故障恢复策略\",{\"0\":{\"40\":1}}],[\"故障检测和隔离\",{\"1\":{\"32\":1}}],[\"无论是哪层负载均衡\",{\"1\":{\"111\":1}}],[\"无法返回结果\",{\"1\":{\"127\":1}}],[\"无法转换为\",{\"1\":{\"48\":2}}],[\"无法保证最终一致性\",{\"1\":{\"39\":1}}],[\"无需轮询\",{\"1\":{\"115\":1}}],[\"无需担心类型是否已被注册\",{\"1\":{\"49\":1}}],[\"无需提前注册\",{\"1\":{\"49\":1}}],[\"无需实现serializable接口\",{\"1\":{\"44\":1}}],[\"无需引入额外依赖\",{\"1\":{\"44\":2}}],[\"无需关心代理对象的具体实现细节\",{\"1\":{\"5\":1}}],[\"再逐步恢复对该服务的调用\",{\"1\":{\"122\":1}}],[\"再重新发送请求\",{\"1\":{\"120\":1}}],[\"再让节点定期去续期\",{\"1\":{\"87\":1}}],[\"再需要容错的时候\",{\"1\":{\"39\":1}}],[\"再扫描用户目录\",{\"1\":{\"10\":1}}],[\"静默处理\",{\"1\":{\"39\":2}}],[\"静默处理策略的特点是\",{\"1\":{\"39\":1}}],[\"静默处理策略提供了一种安静而高效的容错处理方式\",{\"1\":{\"39\":1}}],[\"静默处理策略\",{\"0\":{\"39\":1}}],[\"静态代理的优点是实现简单\",{\"1\":{\"3\":1}}],[\"静态代理是在编译时就已经生成代理类的字节码文件\",{\"1\":{\"3\":1}}],[\"静态代理就是自己去写一个实现类\",{\"1\":{\"3\":1}}],[\"静态代理\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"立刻通知调用方失败\",{\"1\":{\"38\":1}}],[\"立即抛出异常\",{\"1\":{\"34\":1}}],[\"打印一个日志\",{\"1\":{\"38\":1}}],[\"上下文\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1}}],[\"上面这些只是rpc的配置\",{\"1\":{\"25\":1}}],[\"上面的代码是通过http来请求拿到provider提供者的实现函数\",{\"1\":{\"3\":1}}],[\"制定出适合自己系统的容错机制\",{\"1\":{\"37\":1}}],[\"作为需要重试的任务\",{\"1\":{\"126\":1}}],[\"作为虚拟节点在哈希环上的位置\",{\"1\":{\"116\":1}}],[\"作为备用方案提高整体系统的可用性\",{\"1\":{\"69\":1}}],[\"作为处理结果\",{\"1\":{\"37\":1}}],[\"作为服务提供者或消费者\",{\"1\":{\"24\":1}}],[\"暂时断开对该服务的调用\",{\"1\":{\"122\":1}}],[\"暂时未实现其他注册中心\",{\"1\":{\"55\":1}}],[\"暂未实现\",{\"1\":{\"77\":1}}],[\"暂停服务\",{\"1\":{\"36\":1}}],[\"暂无可用服务提供者\",{\"1\":{\"4\":1,\"103\":1}}],[\"出现故障或者异常\",{\"1\":{\"36\":1}}],[\"出现错误之后\",{\"1\":{\"36\":1}}],[\"降级到其他服务\",{\"1\":{\"41\":2}}],[\"降级\",{\"1\":{\"36\":1}}],[\"降低调用端的开发难度\",{\"1\":{\"121\":1}}],[\"降低调用端的复杂度\",{\"1\":{\"121\":1}}],[\"降低成本和风险\",{\"1\":{\"69\":1}}],[\"降低运维成本\",{\"1\":{\"33\":1}}],[\"降低故障对整个系统的影响\",{\"1\":{\"33\":1}}],[\"降低故障影响\",{\"1\":{\"33\":1}}],[\"限流\",{\"1\":{\"36\":1}}],[\"很多\",{\"1\":{\"36\":1}}],[\"除了上述的策略之外\",{\"1\":{\"36\":1}}],[\"除此之外\",{\"1\":{\"25\":1,\"69\":1}}],[\"先调用\",{\"1\":{\"127\":1}}],[\"先6>2不符合\",{\"1\":{\"117\":1}}],[\"先将rpcresponse\",{\"1\":{\"48\":1}}],[\"先定义序列化器的接口\",{\"1\":{\"46\":1}}],[\"先重试再容错\",{\"1\":{\"35\":1}}],[\"先容错再重试\",{\"1\":{\"35\":1}}],[\"向所有已知的服务提供者发起调用\",{\"1\":{\"34\":1}}],[\"但对现代机器性能而言影响已经很小了\",{\"1\":{\"111\":1}}],[\"但需要额外的tcp连接层\",{\"1\":{\"111\":1}}],[\"但需要在上层进行更好的异常处理\",{\"1\":{\"34\":1}}],[\"但由于其报文头部开销较大\",{\"1\":{\"91\":1}}],[\"但目前却没有一个比较完善的\",{\"1\":{\"69\":1}}],[\"但是java中bit运算麻烦\",{\"1\":{\"94\":1}}],[\"但是接口调用方依然有\",{\"1\":{\"69\":1}}],[\"但是这种办法缺点很明显\",{\"1\":{\"3\":1}}],[\"但缺点是需要提前知道所有可能使用的类型\",{\"1\":{\"49\":1}}],[\"但同时也存在一定的安全隐患\",{\"1\":{\"49\":1}}],[\"但可能存在一定的安全隐患\",{\"1\":{\"49\":1}}],[\"但调用方请求的出入参数都是对象\",{\"1\":{\"43\":1}}],[\"但不会将异常信息直接返回给调用方\",{\"1\":{\"39\":1}}],[\"但会增加网络开销\",{\"1\":{\"34\":1}}],[\"但会增加资源消耗\",{\"1\":{\"34\":1}}],[\"快速失败策略\",{\"0\":{\"38\":1}}],[\"快速失败可以减少系统资源的占用\",{\"1\":{\"34\":1}}],[\"快速失败\",{\"1\":{\"34\":1,\"38\":2}}],[\"快速入门\",{\"0\":{\"55\":1},\"1\":{\"22\":1}}],[\"比如网络超时\",{\"1\":{\"121\":1}}],[\"比如网络抖动导致请求失败\",{\"1\":{\"121\":1}}],[\"比如现在权重\",{\"1\":{\"117\":1}}],[\"比如现在有三台服务器a\",{\"1\":{\"117\":1}}],[\"比如读magic\",{\"1\":{\"94\":1}}],[\"比如用户交互界面\",{\"1\":{\"34\":1}}],[\"比如日志记录\",{\"1\":{\"34\":1,\"39\":1}}],[\"比如java\",{\"1\":{\"7\":1}}],[\"减少等待实际服务开发完成的时间\",{\"1\":{\"69\":1}}],[\"减少人工介入\",{\"1\":{\"33\":1}}],[\"减少业务中断时间\",{\"1\":{\"40\":1}}],[\"减少业务中断\",{\"1\":{\"33\":1}}],[\"许多关键业务系统需要实现7\",{\"1\":{\"33\":1}}],[\"满足业务连续性要求\",{\"1\":{\"33\":1}}],[\"仍能保持稳定和可靠的运行\",{\"1\":{\"33\":1}}],[\"仍能保证系统整体的正常运转和服务可用性\",{\"1\":{\"32\":1}}],[\"增强系统弹性\",{\"1\":{\"33\":1}}],[\"增加额外的功能\",{\"1\":{\"2\":1}}],[\"任何一个组件的故障都可能导致整个系统不可用\",{\"1\":{\"33\":1}}],[\"建立完善的监控体系\",{\"1\":{\"32\":1}}],[\"建三个类\",{\"1\":{\"8\":1}}],[\"日志记录等\",{\"1\":{\"128\":1}}],[\"日志备份\",{\"1\":{\"32\":1}}],[\"日志框架的实现\",{\"1\":{\"9\":1}}],[\"备份方案包括数据备份\",{\"1\":{\"32\":1}}],[\"定制化的应用请求负载\",{\"1\":{\"111\":1}}],[\"定义最大重试次数\",{\"1\":{\"127\":1}}],[\"定义好\",{\"1\":{\"69\":1}}],[\"定义了\",{\"1\":{\"25\":1}}],[\"定期备份系统状态和业务数据\",{\"1\":{\"32\":1}}],[\"数据\",{\"1\":{\"98\":1}}],[\"数据一致性等内容\",{\"1\":{\"75\":1}}],[\"数据存储\",{\"1\":{\"74\":1}}],[\"数据序列化系统\",{\"1\":{\"44\":1}}],[\"数据量哓\",{\"1\":{\"44\":1}}],[\"数据备份和恢复\",{\"1\":{\"32\":1}}],[\"数据库驱动程序加载\",{\"1\":{\"9\":1}}],[\"资源隔离和限流\",{\"1\":{\"32\":1}}],[\"保证线程安全\",{\"1\":{\"49\":1}}],[\"保证服务的可用性\",{\"1\":{\"34\":1}}],[\"保证系统整体仍能正常提供服务\",{\"1\":{\"33\":1}}],[\"保证核心功能的可用性\",{\"1\":{\"32\":1}}],[\"保持一致\",{\"1\":{\"26\":1}}],[\"临时使用备用方案或返回默认响应\",{\"1\":{\"32\":1}}],[\"防止因为多次重试而导致这个请求的处理时间超过用户配置的超时时间\",{\"1\":{\"121\":1}}],[\"防止阻塞和资源占用\",{\"1\":{\"36\":1}}],[\"防止被大量请求冲垮\",{\"1\":{\"32\":1}}],[\"防止无限重试耗尽资源\",{\"1\":{\"32\":1,\"122\":1}}],[\"防止故障扩散\",{\"1\":{\"32\":1}}],[\"指数退避重试策略\",{\"0\":{\"127\":1},\"1\":{\"122\":1}}],[\"指数退避\",{\"1\":{\"32\":1,\"127\":1}}],[\"指定的类型\",{\"1\":{\"48\":1}}],[\"指定spi的配置目录位置\",{\"1\":{\"10\":1}}],[\"指定序列化器\",{\"1\":{\"4\":1,\"103\":1}}],[\"指定序列化方式\",{\"1\":{\"3\":1}}],[\"即多次执行同一个操作\",{\"1\":{\"121\":1}}],[\"即使只有3个节点也可以分配均匀\",{\"1\":{\"116\":1}}],[\"即使服务调用失败\",{\"1\":{\"39\":1}}],[\"即用户数据报协议\",{\"1\":{\"90\":1}}],[\"即从etcd中删除对应的服务节点信息\",{\"1\":{\"84\":1}}],[\"即\",{\"1\":{\"43\":2}}],[\"即可\",{\"1\":{\"29\":1,\"94\":1}}],[\"即为客户端提供一个透明的代理层\",{\"1\":{\"4\":1}}],[\"x中\",{\"1\":{\"108\":1}}],[\"x提供的请求处理器是异步的\",{\"1\":{\"103\":1}}],[\"x提供的handler<netsocket>接口\",{\"1\":{\"102\":1}}],[\"x创建一个tcp服务\",{\"1\":{\"100\":1}}],[\"x的tcp服务器收发消息都是buffer类型\",{\"1\":{\"97\":1}}],[\"xml\",{\"0\":{\"53\":1},\"1\":{\"44\":2}}],[\"x\",{\"1\":{\"29\":1,\"102\":1,\"108\":1}}],[\"xian\",{\"1\":{\"0\":1}}],[\"启动tcp服务器并监听指定端口\",{\"1\":{\"100\":1}}],[\"启动\",{\"1\":{\"29\":2}}],[\"启动服务器\",{\"1\":{\"18\":1}}],[\"启动服务\",{\"1\":{\"3\":1,\"29\":1}}],[\"供\",{\"1\":{\"29\":1}}],[\"列表\",{\"1\":{\"29\":1}}],[\"遍历每个参数\",{\"1\":{\"48\":1}}],[\"遍历传入的\",{\"1\":{\"29\":1}}],[\"遍历对象的所有属性\",{\"1\":{\"20\":1}}],[\"找不到再加载\",{\"1\":{\"26\":4}}],[\"自主选择一个服务节点\",{\"1\":{\"110\":1}}],[\"自测都会被阻塞\",{\"1\":{\"69\":1}}],[\"自己实现一个相对也比较容易\",{\"1\":{\"69\":1}}],[\"自动切换回正常的服务节点\",{\"1\":{\"34\":1}}],[\"自动切换到备用的服务提供者\",{\"1\":{\"34\":1}}],[\"自动恢复对该服务的调用\",{\"1\":{\"34\":1}}],[\"自动初始化\",{\"1\":{\"26\":1}}],[\"自定义消息结构\",{\"1\":{\"92\":1}}],[\"自定义网络传输\",{\"1\":{\"92\":1}}],[\"自定义rpc协议两大核心部分\",{\"1\":{\"92\":1}}],[\"自定义rpc协议设计\",{\"0\":{\"92\":1}}],[\"自定义的二进制协议\",{\"1\":{\"91\":1}}],[\"自定义协议\",{\"0\":{\"89\":1}}],[\"自定义\",{\"1\":{\"10\":1}}],[\"自定义spi机制实现\",{\"0\":{\"10\":1}}],[\"关闭客户端\",{\"1\":{\"86\":1}}],[\"关闭钩子\",{\"1\":{\"26\":1}}],[\"关于rpc的一些问题\",{\"1\":{\"0\":1}}],[\"接受请求\",{\"1\":{\"102\":1}}],[\"接受一个\",{\"1\":{\"26\":1}}],[\"接收客户端连接请求\",{\"1\":{\"102\":1}}],[\"接收数据\",{\"1\":{\"101\":1}}],[\"接收响应\",{\"1\":{\"101\":1,\"103\":1,\"108\":1}}],[\"接口规范+序列化反序列化规范+通信协议等\",{\"1\":{\"90\":1}}],[\"接口主要提供\",{\"1\":{\"79\":1}}],[\"接口主要有两个参数\",{\"1\":{\"37\":1}}],[\"接口提供方也有着自测接口的需求\",{\"1\":{\"69\":1}}],[\"接口后就各自进行开发\",{\"1\":{\"69\":1}}],[\"接口与实现代码\",{\"0\":{\"58\":1}}],[\"接口定义了重试策略的标准\",{\"1\":{\"124\":1}}],[\"接口定义\",{\"0\":{\"46\":1}}],[\"接口为容错处理提供了一个标准的抽象和扩展点\",{\"1\":{\"37\":1}}],[\"接口或枚举\",{\"1\":{\"14\":1,\"15\":1}}],[\"接口=>实现类的映射\",{\"1\":{\"10\":1}}],[\"接口名=>\",{\"1\":{\"10\":2}}],[\"接口的定义\",{\"1\":{\"127\":1}}],[\"接口的一个方法\",{\"1\":{\"127\":1}}],[\"接口的实现\",{\"1\":{\"126\":1}}],[\"接口的实现由provider实现\",{\"1\":{\"8\":1}}],[\"接口的需求\",{\"1\":{\"69\":1}}],[\"接口的代理类实例\",{\"1\":{\"5\":1}}],[\"接口\",{\"1\":{\"4\":1,\"20\":1,\"68\":1,\"69\":1}}],[\"接口mock服务\",{\"0\":{\"67\":1}}],[\"接口mock服务方案设计\",{\"1\":{\"0\":1}}],[\"接口mock部分\",{\"1\":{\"0\":1}}],[\"确保服务发现的性能\",{\"1\":{\"74\":1}}],[\"确保服务质量不会下降\",{\"1\":{\"33\":1}}],[\"确保能够正确地还原原始对象类型\",{\"1\":{\"48\":1}}],[\"确保流量能够自动分配到可用的节点上\",{\"1\":{\"34\":1}}],[\"确保业务连续性\",{\"1\":{\"33\":1}}],[\"确保\",{\"1\":{\"26\":1}}],[\"确保其他\",{\"1\":{\"20\":1}}],[\"变量记录当前轮询到的索引位置\",{\"1\":{\"115\":1}}],[\"变量\",{\"1\":{\"26\":1}}],[\"双检锁实现单例\",{\"1\":{\"26\":1}}],[\"存放虚拟节点\",{\"1\":{\"116\":1}}],[\"存放了项目全局用到的变量\",{\"1\":{\"26\":1}}],[\"存储已加载的类\",{\"1\":{\"10\":2}}],[\"相当于续约\",{\"1\":{\"87\":1}}],[\"相当于一个唯一标识\",{\"1\":{\"83\":1}}],[\"相当于holder\",{\"1\":{\"26\":1}}],[\"相关的配置和初始化\",{\"1\":{\"14\":1}}],[\"相关的功能\",{\"1\":{\"14\":1}}],[\"代表一个任务\",{\"1\":{\"124\":1,\"125\":1,\"126\":1}}],[\"代码如下\",{\"1\":{\"124\":1}}],[\"代码优化说明\",{\"0\":{\"28\":1}}],[\"代码解释\",{\"1\":{\"26\":1,\"48\":1}}],[\"代码实现\",{\"0\":{\"26\":1,\"95\":1},\"1\":{\"49\":1,\"50\":1,\"51\":1}}],[\"代理类的实现是手动编写的\",{\"1\":{\"3\":1}}],[\"代理对象\",{\"1\":{\"5\":1}}],[\"代理对象通常是由客户端动态生成的\",{\"1\":{\"2\":1}}],[\"代理对象可以在转发请求和响应的过程中\",{\"1\":{\"2\":1}}],[\"代理对象会负责将客户端的请求转换为远程服务能够理解的格式\",{\"1\":{\"2\":1}}],[\"代理对象扮演着这样的角色\",{\"1\":{\"2\":1}}],[\"代理对象是客户端用来调用远程服务的中间层\",{\"1\":{\"2\":1}}],[\"代理模式是一种常见的设计模式\",{\"1\":{\"2\":1}}],[\"代理\",{\"0\":{\"1\":1},\"1\":{\"2\":1,\"30\":1,\"70\":1}}],[\"使得java对象和buffer之间可以相互转换\",{\"1\":{\"97\":1}}],[\"使得依赖该接口的其他团队或系统可以独立进行开发和测试工作\",{\"1\":{\"68\":1}}],[\"使得整个框架的配置管理更加集中和便捷\",{\"1\":{\"25\":1}}],[\"使用recordparser来对原来的buffer处理器功能进行增强\",{\"1\":{\"108\":1}}],[\"使用序列化器将\",{\"1\":{\"98\":1}}],[\"使用这种方式\",{\"1\":{\"94\":1}}],[\"使用接口\",{\"1\":{\"69\":1}}],[\"使用相对麻烦\",{\"1\":{\"51\":1}}],[\"使用jackson库的objectmapper来完成序列化和反序列化的功能\",{\"1\":{\"48\":1}}],[\"使用jdk提供的objectoutputstream和objectinputstream类来完成序列化和反序列化的功能\",{\"1\":{\"47\":1}}],[\"使用复杂\",{\"1\":{\"44\":2}}],[\"使用不够友好\",{\"1\":{\"44\":2}}],[\"使用简单\",{\"1\":{\"44\":2}}],[\"使用方便\",{\"1\":{\"44\":2}}],[\"使用默认配置\",{\"1\":{\"26\":1}}],[\"使用通用的配置读取工具\",{\"1\":{\"24\":1}}],[\"使用服务接口类的名称作为\",{\"1\":{\"19\":1}}],[\"使用重试策略和容错策略执行\",{\"1\":{\"4\":1}}],[\"使用重试策略\",{\"1\":{\"4\":1,\"40\":1,\"103\":1}}],[\"使用字节码技术在运行时动态生成代理类\",{\"1\":{\"4\":1}}],[\"使用\",{\"1\":{\"4\":1,\"5\":1,\"19\":1,\"20\":1,\"29\":1,\"76\":1,\"102\":2,\"115\":1,\"127\":2}}],[\"使用了动态代理的技术\",{\"1\":{\"2\":1}}],[\"使用步骤\",{\"1\":{\"0\":1}}],[\"凭证等\",{\"1\":{\"25\":1}}],[\"等不同类型\",{\"1\":{\"111\":1}}],[\"等到下次size不等于\",{\"1\":{\"108\":1}}],[\"等工具进行接口的自测\",{\"1\":{\"69\":1}}],[\"等平台\",{\"1\":{\"69\":1}}],[\"等\",{\"1\":{\"25\":1,\"73\":1,\"91\":1,\"94\":1,\"111\":1}}],[\"模型之上\",{\"1\":{\"90\":1}}],[\"模拟各种异常情况\",{\"1\":{\"69\":1}}],[\"模拟异常场景\",{\"1\":{\"69\":1}}],[\"模拟调用\",{\"1\":{\"25\":1,\"26\":1}}],[\"模式\",{\"1\":{\"5\":4,\"16\":1}}],[\"和七层负载\",{\"1\":{\"111\":1}}],[\"和kv客户端\",{\"1\":{\"83\":1}}],[\"和前端的开发\",{\"1\":{\"69\":1}}],[\"和实际参数数组\",{\"1\":{\"48\":1}}],[\"和消费者\",{\"1\":{\"28\":1}}],[\"和\",{\"1\":{\"25\":2,\"98\":1}}],[\"名称\",{\"1\":{\"26\":1}}],[\"名称和版本\",{\"1\":{\"25\":1}}],[\"名为\",{\"1\":{\"14\":1}}],[\"参数列表\",{\"1\":{\"94\":1}}],[\"参数类型和参数值等信息\",{\"1\":{\"4\":1}}],[\"参考链接\",{\"1\":{\"94\":1}}],[\"参考dubbo的实现\",{\"1\":{\"34\":1}}],[\"参考dubbo的设计方案\",{\"1\":{\"25\":1}}],[\"参考\",{\"1\":{\"26\":1}}],[\"方案\",{\"1\":{\"69\":1}}],[\"方便问题排查\",{\"1\":{\"126\":1}}],[\"方便事后排查问题\",{\"1\":{\"39\":1}}],[\"方便管理和扩展\",{\"1\":{\"29\":1}}],[\"方便框架内部各组件快速获取一致的配置信息\",{\"1\":{\"24\":1}}],[\"方法不能抛出异常\",{\"1\":{\"127\":1}}],[\"方法可以声明抛出异常\",{\"1\":{\"127\":1}}],[\"方法可能会抛出任何类型的异常\",{\"1\":{\"127\":1}}],[\"方法抛出异常\",{\"1\":{\"127\":1}}],[\"方法执行成功\",{\"1\":{\"127\":1}}],[\"方法内部\",{\"1\":{\"127\":1}}],[\"方法是\",{\"1\":{\"126\":1}}],[\"方法实现需要根据具体的重试策略\",{\"1\":{\"124\":1}}],[\"方法进行服务实例的选择\",{\"1\":{\"116\":1}}],[\"方法进行全局初始化\",{\"1\":{\"29\":1}}],[\"方法被调用时\",{\"1\":{\"116\":1,\"127\":1}}],[\"方法获取当前索引\",{\"1\":{\"115\":1}}],[\"方法时\",{\"1\":{\"115\":1}}],[\"方法写回给客户端\",{\"1\":{\"102\":1}}],[\"方法将\",{\"1\":{\"102\":1}}],[\"方法将服务元信息\",{\"1\":{\"29\":1}}],[\"方法将服务信息注册到本地注册表中\",{\"1\":{\"19\":1}}],[\"方法将服务提供者返回的\",{\"1\":{\"4\":1}}],[\"方法解码接收到的数据\",{\"1\":{\"102\":1}}],[\"方法从默认的配置文件路径加载\",{\"1\":{\"26\":1}}],[\"方法用于自动初始化\",{\"1\":{\"26\":1}}],[\"方法用于初始化\",{\"1\":{\"26\":1}}],[\"方法使用了双重检查锁的单例模式实现\",{\"1\":{\"26\":1}}],[\"方法为服务接口生成代理对象\",{\"1\":{\"20\":1}}],[\"方法或通过构造函数反射来实例化\",{\"1\":{\"10\":1}}],[\"方法只是加载并返回\",{\"1\":{\"10\":1}}],[\"方法只是返回一个表示指定类的\",{\"1\":{\"10\":1}}],[\"方法会根据传入的类名动态加载并返回一个\",{\"1\":{\"10\":1}}],[\"方法返回一个动态生成的代理对象\",{\"1\":{\"5\":1}}],[\"方法创建动态代理实例\",{\"1\":{\"5\":1}}],[\"方法生成一个\",{\"1\":{\"5\":1}}],[\"方法中实现了\",{\"1\":{\"108\":1}}],[\"方法中完成的\",{\"1\":{\"10\":1}}],[\"方法中\",{\"1\":{\"4\":1,\"127\":1}}],[\"方法名\",{\"1\":{\"4\":1}}],[\"方法的实现\",{\"1\":{\"4\":1}}],[\"方法\",{\"1\":{\"4\":1,\"5\":2,\"20\":1,\"29\":1,\"48\":1,\"108\":1}}],[\"统一配置管理\",{\"1\":{\"24\":1}}],[\"不进行任何重试\",{\"1\":{\"122\":1}}],[\"不进行重试或降级\",{\"1\":{\"34\":1}}],[\"不重试策略\",{\"0\":{\"125\":1}}],[\"不重试\",{\"1\":{\"122\":1}}],[\"不重试了\",{\"1\":{\"40\":1}}],[\"不处理应用层数据内容\",{\"1\":{\"111\":1}}],[\"不支持的消息类型\",{\"1\":{\"99\":1}}],[\"不支持的序列化器\",{\"1\":{\"98\":1}}],[\"不支持无参构造函数\",{\"1\":{\"44\":1}}],[\"不可以直接写入java对象\",{\"1\":{\"97\":1}}],[\"不适合高性能的\",{\"1\":{\"91\":1}}],[\"不是一个完整的远程调用方案\",{\"1\":{\"90\":1}}],[\"不过\",{\"1\":{\"51\":1}}],[\"不需要使用数组了\",{\"1\":{\"117\":1}}],[\"不需要提前注册类\",{\"1\":{\"49\":1}}],[\"不需要初始化web服务器\",{\"1\":{\"28\":1}}],[\"不能提前注册类\",{\"1\":{\"49\":1}}],[\"不能很好地处理复杂的数据结构和循环引用\",{\"1\":{\"44\":1}}],[\"不够灵活\",{\"1\":{\"44\":1}}],[\"不跨语言\",{\"1\":{\"44\":1}}],[\"不会出现大幅波动\",{\"1\":{\"128\":1}}],[\"不会像指数退避那样导致重试间隔时间过长\",{\"1\":{\"128\":1}}],[\"不会产生副作用\",{\"1\":{\"121\":1}}],[\"不会导致整体负载的重大变化\",{\"1\":{\"116\":1}}],[\"不会抛出异常\",{\"1\":{\"39\":1}}],[\"不会实例化对象\",{\"1\":{\"10\":1}}],[\"不通知调用方失败\",{\"1\":{\"39\":2}}],[\"不利于后期维护和扩展\",{\"1\":{\"24\":1}}],[\"见快速入门\",{\"1\":{\"22\":1}}],[\"将最大的权重减去总权重\",{\"1\":{\"118\":1}}],[\"将权重值加上动态权重\",{\"1\":{\"118\":1}}],[\"将请求分发给这个集群下的每个服务节点\",{\"1\":{\"110\":1}}],[\"将整个消息写入\",{\"1\":{\"108\":1}}],[\"将消息头部分数据写入临时缓冲区\",{\"1\":{\"108\":1}}],[\"将接收到的二进制数据传递给\",{\"1\":{\"108\":1}}],[\"将执行结果封装其中\",{\"1\":{\"102\":1}}],[\"将字节数组的长度写入\",{\"1\":{\"98\":1}}],[\"将字节数组反序列化为rpcresponse\",{\"1\":{\"48\":1}}],[\"将键值对与租约绑定\",{\"1\":{\"83\":1}}],[\"将处理后的rpcrequest对象强制转换为目标类型t\",{\"1\":{\"48\":1}}],[\"将二进制转换为对象\",{\"1\":{\"43\":1}}],[\"将对象转换成二进制数据\",{\"1\":{\"43\":1}}],[\"将不同服务或模块的资源进行隔离\",{\"1\":{\"32\":1}}],[\"将服务实现类注册到本地注册表\",{\"1\":{\"29\":1}}],[\"将serviceregisterinfo注册到注册中心\",{\"1\":{\"29\":1}}],[\"将生成的代理对象设置到当前\",{\"1\":{\"20\":1}}],[\"将装配的控制权移交到了程序之外\",{\"1\":{\"7\":1}}],[\"于是取当前\",{\"1\":{\"19\":1}}],[\"首先创建了一个\",{\"1\":{\"126\":1}}],[\"首先创建三个模块\",{\"1\":{\"56\":1}}],[\"首先根据请求参数计算出一个哈希值\",{\"1\":{\"116\":1}}],[\"首先根据反射获取到的方法信息\",{\"1\":{\"4\":1}}],[\"首先读取消息体的长度\",{\"1\":{\"108\":1}}],[\"首先编码器按照顺序向缓冲区buffer写入这些数据\",{\"1\":{\"94\":1}}],[\"首先尝试使用\",{\"1\":{\"26\":1}}],[\"首先从\",{\"1\":{\"19\":1}}],[\"全局变量\",{\"0\":{\"81\":1}}],[\"全局配置加载\",{\"0\":{\"23\":1}}],[\"全局配置\",{\"1\":{\"19\":1,\"29\":1}}],[\"全局启动类\",{\"0\":{\"18\":1}}],[\"本篇主要分析软件负载均衡\",{\"1\":{\"111\":1}}],[\"本地集合\",{\"1\":{\"84\":1}}],[\"本地注册节点\",{\"1\":{\"81\":1}}],[\"本地注册服务\",{\"1\":{\"19\":1}}],[\"本地注册\",{\"1\":{\"19\":1,\"29\":1}}],[\"本次手写rpc框架参考了许多优秀的设计\",{\"1\":{\"0\":1}}],[\"注销服务\",{\"1\":{\"79\":1}}],[\"注意需要自己启动etcd作为注册中心\",{\"1\":{\"55\":1}}],[\"注册\",{\"1\":{\"87\":1}}],[\"注册的时候把key加入到集合中\",{\"1\":{\"87\":1}}],[\"注册信息\",{\"1\":{\"77\":1}}],[\"注册shutdown\",{\"1\":{\"26\":1,\"86\":1}}],[\"注册中心缓存\",{\"1\":{\"81\":1}}],[\"注册中心接口\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"注册中心地址\",{\"1\":{\"78\":1}}],[\"注册中心类别\",{\"1\":{\"78\":2}}],[\"注册中心可以暂时不实现\",{\"1\":{\"74\":1}}],[\"注册中心可以提供服务分组\",{\"1\":{\"72\":1,\"74\":1}}],[\"注册中心的架构还需要具备良好的扩展性\",{\"1\":{\"74\":1}}],[\"注册中心还需要考虑服务发现的容错性\",{\"1\":{\"74\":1}}],[\"注册中心自身需要具备高可用性\",{\"1\":{\"74\":1}}],[\"注册中心需要支撑大规模的服务注册和发现\",{\"1\":{\"74\":1}}],[\"注册中心需要设计可扩展的架构\",{\"1\":{\"74\":1}}],[\"注册中心需要提供元数据的增删改查等管理功能\",{\"1\":{\"74\":1}}],[\"注册中心需要提供高效的查询和路由机制\",{\"1\":{\"74\":1}}],[\"注册中心需要存储服务提供者的详细元数据信息\",{\"1\":{\"74\":1}}],[\"注册中心需要根据服务实例的负载情况动态调整负载均衡策略\",{\"1\":{\"74\":1}}],[\"注册中心需要根据负载均衡策略选择合适的实例\",{\"1\":{\"74\":1}}],[\"注册中心需要处理服务实例的上下线事件\",{\"1\":{\"74\":1}}],[\"注册中心需要定期检查服务实例的健康状态\",{\"1\":{\"74\":1}}],[\"注册中心设计\",{\"0\":{\"74\":1}}],[\"注册中心作为\",{\"1\":{\"73\":1}}],[\"注册中心有哪些\",{\"0\":{\"73\":1}}],[\"注册中心会将其从服务列表中剔除\",{\"1\":{\"72\":1}}],[\"注册中心会定期检查服务实例的健康状态\",{\"1\":{\"72\":1}}],[\"注册中心根据负载均衡策略选择合适的服务实例\",{\"1\":{\"72\":1}}],[\"注册中心负责维护这些服务的注册信息\",{\"1\":{\"72\":1}}],[\"注册中心\",{\"1\":{\"72\":1,\"110\":1}}],[\"注册中心实现\",{\"0\":{\"71\":1}}],[\"注册中心初始化\",{\"1\":{\"26\":1,\"86\":1}}],[\"注册中心配置主要包括\",{\"1\":{\"78\":1}}],[\"注册中心配置\",{\"0\":{\"78\":1},\"1\":{\"25\":1,\"26\":1}}],[\"注册已编写的启动类\",{\"0\":{\"21\":1}}],[\"注册到注册中心\",{\"1\":{\"19\":1,\"29\":2,\"72\":1}}],[\"注册服务\",{\"1\":{\"19\":1,\"79\":1}}],[\"注解\",{\"1\":{\"65\":1}}],[\"注解添加\",{\"0\":{\"62\":1}}],[\"注解标注\",{\"1\":{\"20\":2}}],[\"注解标注的字段\",{\"1\":{\"20\":1}}],[\"注解标记为\",{\"1\":{\"15\":1}}],[\"注解中获取\",{\"1\":{\"19\":2}}],[\"注解中的\",{\"1\":{\"18\":1}}],[\"注解中定义的一个属性\",{\"1\":{\"14\":1}}],[\"注解驱动\",{\"0\":{\"17\":1}}],[\"注解只能被应用在字段\",{\"1\":{\"16\":1}}],[\"注解是用于标注\",{\"1\":{\"16\":1}}],[\"注解是一个基于\",{\"1\":{\"14\":1}}],[\"注解定义的另一个属性\",{\"1\":{\"15\":1,\"16\":1}}],[\"注解定义的一个属性\",{\"1\":{\"15\":1,\"16\":5}}],[\"注解本身的声明\",{\"1\":{\"15\":1,\"16\":1}}],[\"注解可以被应用于类型\",{\"1\":{\"15\":1}}],[\"注解可以被应用于哪些程序元素\",{\"1\":{\"14\":1}}],[\"注解主要用于标注\",{\"1\":{\"15\":1}}],[\"注解被应用到一个类上时\",{\"1\":{\"14\":1}}],[\"注解的属性值\",{\"1\":{\"18\":1}}],[\"注解的保留策略是在运行时被\",{\"1\":{\"15\":1,\"16\":1}}],[\"注解的保留策略\",{\"1\":{\"14\":1}}],[\"注解的设计目的是为了简化\",{\"1\":{\"15\":1,\"16\":1}}],[\"注解的设计\",{\"1\":{\"14\":1}}],[\"注解设计\",{\"0\":{\"13\":1}}],[\"默认值\",{\"1\":{\"19\":1}}],[\"默认值处理\",{\"1\":{\"19\":1}}],[\"默认值为\",{\"1\":{\"14\":1,\"15\":2,\"16\":6}}],[\"完成服务信息的注册\",{\"1\":{\"19\":1}}],[\"完整的rpc实现思路\",{\"1\":{\"0\":1}}],[\"来执行这个任务\",{\"1\":{\"127\":1}}],[\"来记录每次重试的耗时\",{\"1\":{\"127\":1}}],[\"来存储虚拟节点和对应的服务实例信息\",{\"1\":{\"116\":1}}],[\"来保证线程安全\",{\"1\":{\"49\":1}}],[\"来决定采取什么样的容错措施\",{\"1\":{\"37\":1}}],[\"来决定是否需要启动\",{\"1\":{\"18\":1}}],[\"来调用即可\",{\"1\":{\"28\":1}}],[\"来实现tcp请求处理器\",{\"1\":{\"102\":1}}],[\"来实现输入输出格式的灵活配置和切换\",{\"1\":{\"9\":1}}],[\"来实现插件的加载和执行\",{\"1\":{\"9\":1}}],[\"来实现扩展点的动态加载\",{\"1\":{\"9\":1}}],[\"属性序列化为字节数组\",{\"1\":{\"98\":1}}],[\"属性指定了默认的负载均衡策略\",{\"1\":{\"25\":1}}],[\"属性指定了默认的序列化实现\",{\"1\":{\"25\":1}}],[\"属性包含了服务注册中心的配置信息\",{\"1\":{\"25\":1}}],[\"属性用于配置服务调用的容错策略\",{\"1\":{\"25\":1}}],[\"属性用于配置服务调用的重试策略\",{\"1\":{\"25\":1}}],[\"属性用于控制是否开启模拟调用模式\",{\"1\":{\"25\":1}}],[\"属性用于标识\",{\"1\":{\"25\":1}}],[\"属性的值\",{\"1\":{\"19\":2}}],[\"属性\",{\"1\":{\"18\":1,\"98\":1}}],[\"此接口用于在\",{\"1\":{\"18\":1}}],[\"容错处理\",{\"1\":{\"37\":1}}],[\"容错方案的设计\",{\"0\":{\"35\":1}}],[\"容错路由和负载均衡\",{\"1\":{\"32\":1}}],[\"容错机制有哪些\",{\"0\":{\"34\":1}}],[\"容错机制是构建高可用\",{\"1\":{\"33\":1}}],[\"容错机制是分布式系统设计中非常重要的一部分\",{\"1\":{\"32\":1}}],[\"容错机制可以自动化地处理和修复故障\",{\"1\":{\"33\":1}}],[\"容错机制可以确保业务在出现故障时仍能快速恢复\",{\"1\":{\"33\":1}}],[\"容错机制可以在系统扩展或负载增大时\",{\"1\":{\"33\":1}}],[\"容错机制可以在部分组件出现故障时\",{\"1\":{\"33\":1}}],[\"容错机制可以让系统在面对这些不确定性时\",{\"1\":{\"33\":1}}],[\"容错机制可以及时隔离故障\",{\"1\":{\"33\":1}}],[\"容错机制主要包括以下几个方面\",{\"1\":{\"32\":1}}],[\"容错机制实现\",{\"0\":{\"31\":1,\"36\":1}}],[\"容错等策略\",{\"1\":{\"16\":1,\"25\":1}}],[\"容错策略的实现者可以更灵活地根据不同的场景\",{\"1\":{\"37\":1}}],[\"容错策略的实现者需要根据具体的业务需求和故障情况\",{\"1\":{\"37\":1}}],[\"容错策略可以更有针对性地进行容错处理\",{\"1\":{\"37\":1}}],[\"容错策略需要根据异常的类型\",{\"1\":{\"37\":1}}],[\"容错策略实现可以获取到更丰富的信息\",{\"1\":{\"37\":1}}],[\"容错策略接口定义\",{\"0\":{\"37\":1}}],[\"容错策略配置\",{\"1\":{\"25\":1}}],[\"容错策略\",{\"1\":{\"16\":1,\"26\":1}}],[\"容器隔离等方式将故障节点隔离\",{\"1\":{\"32\":1}}],[\"容器初始化\",{\"1\":{\"20\":1}}],[\"容器初始化时执行\",{\"1\":{\"18\":1}}],[\"容器初始化时执行自定义的注册逻辑\",{\"1\":{\"18\":1}}],[\"容器会自动注入一个代理对象\",{\"1\":{\"16\":1}}],[\"容器会自动注册这三个引导类\",{\"1\":{\"14\":1}}],[\"容器会自动扫描并注册该服务\",{\"1\":{\"15\":1}}],[\"容器自动扫描和注册\",{\"1\":{\"15\":1}}],[\"意味着被这个注解标注的类会被\",{\"1\":{\"15\":1}}],[\"组件\",{\"1\":{\"15\":1}}],[\"功能\",{\"1\":{\"14\":1}}],[\"功能即可\",{\"1\":{\"5\":1}}],[\"级别\",{\"1\":{\"14\":1,\"15\":1,\"16\":1}}],[\"插件\",{\"1\":{\"12\":1}}],[\"加权轮询负载均衡\",{\"1\":{\"117\":1,\"118\":1}}],[\"加权轮询\",{\"0\":{\"117\":1},\"1\":{\"74\":1,\"112\":1}}],[\"加入相关依赖\",{\"1\":{\"12\":1}}],[\"加载配置\",{\"1\":{\"26\":2}}],[\"加载配置文件规则\",{\"1\":{\"26\":1}}],[\"加载器更加灵活和高效\",{\"1\":{\"10\":1}}],[\"加载器的实现中\",{\"1\":{\"10\":1}}],[\"加载spi配置文件失败\",{\"1\":{\"10\":1}}],[\"加载\",{\"1\":{\"10\":1,\"26\":6}}],[\"加载类型为\",{\"1\":{\"10\":1}}],[\"加载某个类型\",{\"1\":{\"10\":1}}],[\"加载所有的spi\",{\"1\":{\"10\":1}}],[\"加载所有类型\",{\"1\":{\"10\":1}}],[\"新建一个springboot项目\",{\"1\":{\"12\":1}}],[\"也要删\",{\"1\":{\"84\":1}}],[\"也可以超时自动移除\",{\"1\":{\"83\":1}}],[\"也可用作注册中心\",{\"1\":{\"73\":1}}],[\"也是容器编排的实际标准系统\",{\"1\":{\"76\":1}}],[\"也需要进行类似的处理\",{\"1\":{\"48\":1}}],[\"也不会影响业务的核心逻辑\",{\"1\":{\"39\":1}}],[\"也不会返回错误响应\",{\"1\":{\"39\":1}}],[\"也称兜底\",{\"1\":{\"36\":1}}],[\"也就是下次一定可以读取到整个消息体内容\",{\"1\":{\"108\":1}}],[\"也就是这个接口最后是需要提供服务的\",{\"1\":{\"60\":1}}],[\"也就是我们的rpc框架依赖yunfei\",{\"1\":{\"57\":1}}],[\"也就是类\",{\"1\":{\"14\":1,\"15\":1}}],[\"也就是具体的操作\",{\"1\":{\"3\":1}}],[\"也开发这样三个注解就可以使用整个rpc框架\",{\"1\":{\"11\":1}}],[\"针对serializer使用工厂单例模式\",{\"1\":{\"10\":1}}],[\"到实例对象\",{\"1\":{\"10\":1}}],[\"会传入一个\",{\"1\":{\"127\":1}}],[\"会经过负载均衡\",{\"1\":{\"120\":1}}],[\"会调用\",{\"1\":{\"116\":1}}],[\"会创建\",{\"1\":{\"116\":1}}],[\"会首先遍历服务实例列表\",{\"1\":{\"116\":1}}],[\"会略微增加网络性能损耗\",{\"1\":{\"111\":1}}],[\"会查询注册中心获取可用的服务提供者信息\",{\"1\":{\"72\":1}}],[\"会将自己的服务信息\",{\"1\":{\"72\":1}}],[\"会覆盖系统设置\",{\"1\":{\"10\":1}}],[\"会自动调用这个方法\",{\"1\":{\"4\":1}}],[\"测试结果\",{\"1\":{\"66\":1}}],[\"测试\",{\"0\":{\"22\":1,\"66\":1},\"1\":{\"10\":1,\"26\":1,\"70\":1}}],[\"避免在短时间内大量重复请求\",{\"1\":{\"127\":1}}],[\"避免短时间内发送大量重复请求\",{\"1\":{\"122\":1}}],[\"避免与其他协议的消息混淆\",{\"1\":{\"94\":1}}],[\"避免单点故障\",{\"1\":{\"74\":1}}],[\"避免后期集成时出现的问题\",{\"1\":{\"69\":1}}],[\"避免每次序列化都重新申请buffer空间\",{\"1\":{\"51\":1}}],[\"避免连锁故障\",{\"1\":{\"36\":1}}],[\"避免了不必要的资源消耗\",{\"1\":{\"10\":1}}],[\"避免重放new\",{\"1\":{\"10\":2}}],[\"才会触发实例化操作\",{\"1\":{\"10\":1}}],[\"真正的实例化操作是在\",{\"1\":{\"10\":1}}],[\"只能执行一个任务\",{\"1\":{\"127\":1}}],[\"只会影响部分请求的路由\",{\"1\":{\"116\":1}}],[\"只读取指定长度的数据\",{\"1\":{\"99\":1}}],[\"只有一个服务\",{\"1\":{\"115\":1}}],[\"只有java\",{\"1\":{\"44\":1}}],[\"只有当需要使用\",{\"1\":{\"10\":1}}],[\"只不过这个在故障服务恢复正常后触发\",{\"1\":{\"41\":1}}],[\"只要依赖的\",{\"1\":{\"69\":1}}],[\"只要服务端反序列化数据\",{\"1\":{\"44\":1}}],[\"只要不是当前的服务\",{\"1\":{\"40\":1}}],[\"只要有一个调用成功\",{\"1\":{\"34\":1}}],[\"只记录日志\",{\"1\":{\"39\":2}}],[\"只是用来加载\",{\"1\":{\"10\":1}}],[\"只需要找第一个\",{\"1\":{\"116\":1}}],[\"只需要读第一个\",{\"1\":{\"94\":1}}],[\"只需要在本地维护一个注册节点信息集合\",{\"1\":{\"87\":1}}],[\"只需要在配置中开启\",{\"1\":{\"5\":1}}],[\"只需要先创建要注册的实现类\",{\"1\":{\"29\":1}}],[\"只需要把启动的代码封装为一个专门的启动类或者函数\",{\"1\":{\"28\":1}}],[\"只需要调用代理对象的方法即可\",{\"1\":{\"4\":1}}],[\"对网络抖动不太敏感\",{\"1\":{\"128\":1}}],[\"对响应时间要求也不太严格\",{\"1\":{\"128\":1}}],[\"对任何异常类型都进行捕获并重试\",{\"1\":{\"126\":1}}],[\"对异常进行判定\",{\"1\":{\"121\":1}}],[\"对代码的解释\",{\"1\":{\"49\":1}}],[\"对代码的一些解释\",{\"1\":{\"10\":1}}],[\"对系统负载影响小\",{\"1\":{\"39\":1}}],[\"对关键服务实施限流\",{\"1\":{\"32\":1}}],[\"对于每个服务实例\",{\"1\":{\"116\":1}}],[\"对于注册中心的技术选型\",{\"1\":{\"75\":1}}],[\"对于习惯静态类型语言的工程师来说\",{\"1\":{\"44\":1}}],[\"对于网络异常可以选择重试\",{\"1\":{\"37\":1}}],[\"对于临时性的网络或服务异常\",{\"1\":{\"32\":1}}],[\"对于propertities文件的读取比较\",{\"1\":{\"26\":1}}],[\"对象代表了需要执行的远程调用任务\",{\"1\":{\"127\":1}}],[\"对象编码为字节序列\",{\"1\":{\"102\":1}}],[\"对象处理接收的数据\",{\"1\":{\"102\":1}}],[\"对象中\",{\"1\":{\"98\":1}}],[\"对象不是线程安全的\",{\"1\":{\"49\":1}}],[\"对象不能直接在网络传输\",{\"1\":{\"43\":1}}],[\"对象类型\",{\"1\":{\"46\":3}}],[\"对象作为参数\",{\"1\":{\"26\":1,\"124\":1,\"127\":1}}],[\"对象作为代理\",{\"1\":{\"5\":2}}],[\"对象的唯一性\",{\"1\":{\"26\":1}}],[\"对象的\",{\"1\":{\"10\":1}}],[\"对象可以用来进行各种反射操作\",{\"1\":{\"10\":1}}],[\"对象实例\",{\"1\":{\"10\":2}}],[\"对象实例缓存\",{\"1\":{\"10\":2}}],[\"对象转换为方法调用的返回结果\",{\"1\":{\"4\":1}}],[\"对象就是动态代理要封装和处理的核心请求信息\",{\"1\":{\"4\":1}}],[\"对象\",{\"1\":{\"4\":1,\"10\":5,\"26\":2,\"98\":2,\"102\":3,\"108\":1,\"126\":1}}],[\"失败等\",{\"1\":{\"94\":1,\"98\":1}}],[\"失败恢复策略\",{\"0\":{\"41\":1}}],[\"失败自动恢复\",{\"1\":{\"34\":1}}],[\"失败自动切换\",{\"1\":{\"34\":1}}],[\"失败安全\",{\"1\":{\"34\":1}}],[\"失败\",{\"1\":{\"10\":2}}],[\"失败重试\",{\"1\":{\"4\":1}}],[\"获取执行结果\",{\"1\":{\"102\":1}}],[\"获取对应的序列化器实现\",{\"1\":{\"98\":1}}],[\"获取某服务的所有节点\",{\"1\":{\"79\":1}}],[\"获取某个类型的实例\",{\"1\":{\"10\":1}}],[\"获取完整的服务地址\",{\"1\":{\"77\":1}}],[\"获取要调用的服务实现类\",{\"1\":{\"102\":1}}],[\"获取要调用的服务\",{\"1\":{\"72\":1}}],[\"获取mock代理的\",{\"1\":{\"70\":1}}],[\"获取mock代理对象\",{\"1\":{\"5\":1,\"70\":1}}],[\"获取用户\",{\"1\":{\"59\":1}}],[\"获取rpcrequest中声明的参数类型数组\",{\"1\":{\"48\":1}}],[\"获取\",{\"1\":{\"30\":1,\"70\":1,\"98\":1}}],[\"获取配置\",{\"1\":{\"26\":1}}],[\"获取服务节点键名\",{\"1\":{\"77\":1}}],[\"获取服务键名\",{\"1\":{\"77\":1}}],[\"获取服务名和服务实现类\",{\"1\":{\"29\":1}}],[\"获取服务接口类\",{\"1\":{\"20\":1}}],[\"获取服务基本信息\",{\"1\":{\"19\":2}}],[\"获取到对应的注册信息\",{\"1\":{\"19\":1}}],[\"获取到要加载的实现类型\",{\"1\":{\"10\":2}}],[\"获取enablerpc\",{\"1\":{\"18\":1}}],[\"获取序列化器\",{\"1\":{\"10\":1,\"98\":1}}],[\"0<\",{\"1\":{\"49\":1,\"51\":2,\"70\":1,\"124\":1}}],[\"08\",{\"1\":{\"34\":1}}],[\"0\",{\"1\":{\"10\":2,\"12\":2,\"19\":1,\"26\":1,\"48\":1,\"50\":1,\"57\":2,\"77\":1,\"87\":1,\"99\":1,\"101\":2,\"114\":2,\"115\":2,\"116\":1,\"117\":4,\"118\":20,\"124\":1,\"127\":4,\"128\":3}}],[\"06\",{\"1\":{\"0\":1}}],[\"2=4\",{\"1\":{\"117\":1}}],[\"2380\",{\"1\":{\"78\":1}}],[\"22\",{\"1\":{\"34\":1}}],[\"2018\",{\"1\":{\"34\":1}}],[\"2019\",{\"1\":{\"0\":1}}],[\"24小时的持续运行\",{\"1\":{\"33\":1}}],[\"29<\",{\"1\":{\"26\":1}}],[\"2\",{\"1\":{\"10\":2,\"99\":1,\"117\":3,\"118\":14,\"122\":2,\"127\":1}}],[\"<v>\",{\"1\":{\"126\":1}}],[\"<version>0\",{\"1\":{\"57\":1}}],[\"<version>4\",{\"1\":{\"50\":1,\"70\":1}}],[\"<version>5\",{\"1\":{\"49\":1}}],[\"<version>2\",{\"1\":{\"48\":1,\"124\":1}}],[\"<version>1\",{\"1\":{\"12\":1,\"26\":1,\"51\":2,\"57\":1}}],[\"<version>3\",{\"1\":{\"12\":1}}],[\"<rpcresponse>newbuilder\",{\"1\":{\"126\":1}}],[\"<p>\",{\"1\":{\"26\":3}}],[\"<p>conf\",{\"1\":{\"26\":1}}],[\"<properties>\",{\"1\":{\"12\":1}}],[\"<optional>true<\",{\"1\":{\"12\":2}}],[\"<artifactid>guava\",{\"1\":{\"124\":1}}],[\"<artifactid>jmockdata<\",{\"1\":{\"70\":1}}],[\"<artifactid>jackson\",{\"1\":{\"48\":1}}],[\"<artifactid>example\",{\"1\":{\"57\":1}}],[\"<artifactid>protostuff\",{\"1\":{\"51\":2}}],[\"<artifactid>hessian<\",{\"1\":{\"50\":1}}],[\"<artifactid>kryo<\",{\"1\":{\"49\":1}}],[\"<artifactid>snakeyaml<\",{\"1\":{\"26\":1}}],[\"<artifactid>spring\",{\"1\":{\"12\":3}}],[\"<artifactid>yunfei\",{\"1\":{\"12\":1,\"57\":1}}],[\"<artifactid>dubbo<\",{\"1\":{\"12\":1}}],[\"<groupid>io\",{\"1\":{\"51\":2}}],[\"<groupid>com\",{\"1\":{\"12\":1,\"48\":1,\"49\":1,\"50\":1,\"57\":2,\"70\":1,\"124\":1}}],[\"<groupid>org\",{\"1\":{\"12\":4,\"26\":1}}],[\"<dependency>\",{\"1\":{\"12\":5,\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"57\":2,\"70\":1,\"124\":1}}],[\"<dependencies>\",{\"1\":{\"12\":1,\"57\":1}}],[\"<java\",{\"1\":{\"12\":1}}],[\"<\",{\"1\":{\"10\":2,\"12\":7,\"26\":1,\"48\":2,\"49\":1,\"50\":1,\"51\":2,\"57\":3,\"70\":1,\"101\":1,\"116\":1,\"117\":2,\"124\":2,\"127\":1,\"128\":1}}],[\"<t>\",{\"1\":{\"5\":4,\"10\":2,\"26\":13,\"46\":4,\"47\":2,\"48\":6,\"49\":2,\"50\":2,\"51\":3,\"70\":1}}],[\"优化与改进\",{\"0\":{\"130\":1}}],[\"优化办法\",{\"1\":{\"117\":1}}],[\"优点是简单高效\",{\"1\":{\"111\":1}}],[\"优点是简单易实现\",{\"1\":{\"39\":1}}],[\"优点\",{\"1\":{\"44\":9}}],[\"优先从缓存中获取\",{\"1\":{\"85\":1}}],[\"优先读取\",{\"1\":{\"26\":2}}],[\"优先加载\",{\"1\":{\"26\":3}}],[\"优先级高于系统spi\",{\"1\":{\"10\":1}}],[\"优缺点\",{\"1\":{\"0\":1,\"39\":1}}],[\"动态变化权重\",{\"1\":{\"118\":1}}],[\"动态注册类型\",{\"1\":{\"49\":1}}],[\"动态序列化和反序列化\",{\"1\":{\"49\":1}}],[\"动态调整权重等\",{\"1\":{\"32\":1}}],[\"动态加载的类列表\",{\"1\":{\"10\":1}}],[\"动态代理创建一个\",{\"1\":{\"5\":1}}],[\"动态代理工厂\",{\"0\":{\"5\":1}}],[\"动态代理的实现主要有两个步骤\",{\"1\":{\"5\":1}}],[\"动态代理的方式\",{\"1\":{\"5\":1}}],[\"动态代理的功能实现\",{\"1\":{\"4\":1}}],[\"动态代理的核心接口\",{\"1\":{\"4\":1}}],[\"动态代理的优点是灵活性高\",{\"1\":{\"4\":1}}],[\"动态代理不需要事先编写代理类的源码\",{\"1\":{\"4\":1}}],[\"动态代理是在运行时通过反射机制动态地创建代理类的实例\",{\"1\":{\"4\":1}}],[\"动态代理\",{\"0\":{\"4\":1},\"1\":{\"4\":3,\"103\":1}}],[\"扫描路径为\",{\"1\":{\"10\":1}}],[\"扫描路径\",{\"1\":{\"10\":2}}],[\"单例模式实现\",{\"1\":{\"26\":1}}],[\"单例模式\",{\"1\":{\"10\":2}}],[\"kvclient\",{\"1\":{\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":3,\"87\":1}}],[\"kv\",{\"1\":{\"81\":1}}],[\"kubernetes\",{\"1\":{\"76\":1}}],[\"kafka\",{\"1\":{\"73\":1}}],[\"kryo会要求在使用之前先注册类型\",{\"1\":{\"49\":1}}],[\"kryo会在序列化和反序列化时动态注册类型\",{\"1\":{\"49\":1}}],[\"kryo对象本身不是线程安全的\",{\"1\":{\"49\":1}}],[\"kryoserializer\",{\"1\":{\"49\":1}}],[\"kryo框架\",{\"1\":{\"44\":1}}],[\"kryo\",{\"0\":{\"49\":1},\"1\":{\"25\":1,\"44\":2,\"49\":15}}],[\"kriszhang\",{\"1\":{\"0\":1}}],[\"keyvalue\",{\"1\":{\"85\":2,\"87\":3}}],[\"keyvalues\",{\"1\":{\"85\":2,\"87\":3}}],[\"key\",{\"1\":{\"10\":13,\"81\":1,\"83\":2,\"85\":3,\"86\":3,\"87\":3,\"116\":3}}],[\"keyclassmap\",{\"1\":{\"10\":11}}],[\"key=\",{\"1\":{\"10\":2}}],[\"key=>实现类\",{\"1\":{\"10\":2}}],[\"key=value\",{\"1\":{\"10\":1}}],[\"还可以在这个目录下面继续细分\",{\"1\":{\"10\":1}}],[\"系统设计中\",{\"1\":{\"122\":1}}],[\"系统中的一些结构图\",{\"1\":{\"129\":1}}],[\"系统中\",{\"1\":{\"122\":2}}],[\"系统出现错误后再重试\",{\"1\":{\"36\":1}}],[\"系统需要能够及时发现和定位故障\",{\"1\":{\"32\":1}}],[\"系统\",{\"1\":{\"10\":2}}],[\"系统内置的spi机制会加载resources\",{\"1\":{\"10\":1}}],[\"系统spi实现\",{\"0\":{\"8\":1}}],[\"提升\",{\"1\":{\"91\":1}}],[\"提前注册类型\",{\"1\":{\"49\":1}}],[\"提供的\",{\"1\":{\"126\":1}}],[\"提供可控的测试环境\",{\"1\":{\"69\":1}}],[\"提供模拟的接口数据\",{\"1\":{\"68\":1}}],[\"提供consumer和provider之间需要使用的接口\",{\"1\":{\"56\":1}}],[\"提供者主动从注册中心删除\",{\"1\":{\"86\":1}}],[\"提供者\",{\"1\":{\"56\":1}}],[\"提供者需要获取到所有包含\",{\"1\":{\"19\":1}}],[\"提供者启动\",{\"0\":{\"19\":1}}],[\"提供了更多扩展点\",{\"1\":{\"9\":1}}],[\"提高性能\",{\"1\":{\"130\":1}}],[\"提高成功率\",{\"1\":{\"121\":1}}],[\"提高接口的可用性和可靠性\",{\"1\":{\"121\":1}}],[\"提高消息的可靠性\",{\"1\":{\"94\":1}}],[\"提高开发效率\",{\"1\":{\"69\":1}}],[\"提高可用性\",{\"1\":{\"33\":1}}],[\"提高系统的整体可用性\",{\"1\":{\"34\":1}}],[\"提高系统的灵活性和可维护性\",{\"1\":{\"2\":1}}],[\"提高系统可用性\",{\"1\":{\"33\":1,\"69\":1}}],[\"提高代码复用性\",{\"1\":{\"24\":1}}],[\"提高代码的可维护性和扩展性\",{\"1\":{\"5\":1}}],[\"提高了系统的可靠性和可扩展性\",{\"1\":{\"2\":1,\"4\":1}}],[\"例如防止雪崩效应\",{\"1\":{\"122\":1}}],[\"例如hello\",{\"1\":{\"105\":2}}],[\"例如注册中心我们可以在配置文件中设置\",{\"1\":{\"79\":1}}],[\"例如使用容器\",{\"1\":{\"32\":1}}],[\"例如剔除故障节点\",{\"1\":{\"32\":1}}],[\"例如在仅作为\",{\"1\":{\"14\":1}}],[\"例如读取到的结果为\",{\"1\":{\"10\":1}}],[\"例如beanpostprocessor\",{\"1\":{\"9\":1}}],[\"例如\",{\"1\":{\"9\":1,\"25\":1,\"36\":1,\"37\":2,\"122\":4}}],[\"支持秒级别定时任务\",{\"1\":{\"87\":1}}],[\"支持服务治理功能的灵活配置和动态调整\",{\"1\":{\"74\":1}}],[\"支持更细粒度的服务治理\",{\"1\":{\"72\":1}}],[\"支持动态类型\",{\"1\":{\"44\":1}}],[\"支持动态替换\",{\"1\":{\"9\":1}}],[\"支持schema演化\",{\"1\":{\"44\":2}}],[\"支持跨语言\",{\"1\":{\"44\":1}}],[\"支持高并发和扩展性\",{\"1\":{\"33\":1}}],[\"支持自动化测试\",{\"1\":{\"69\":1}}],[\"支持自动装配\",{\"1\":{\"9\":1}}],[\"支持自定义配置\",{\"1\":{\"24\":1}}],[\"支持键值对映射\",{\"1\":{\"10\":1}}],[\"支持多个实现类\",{\"1\":{\"9\":1}}],[\"支持中间件功能\",{\"1\":{\"2\":1}}],[\"让服务变得均匀\",{\"1\":{\"116\":1}}],[\"让我们逐步解析这个类的实现\",{\"1\":{\"20\":1}}],[\"让用户可以根据自己的需求选择合适的网络协议实现方式\",{\"1\":{\"9\":1}}],[\"让客户端可以像调用本地方法一样使用远程服务\",{\"1\":{\"4\":1}}],[\"用一张图来表示注册中心要实现的功能\",{\"1\":{\"74\":1}}],[\"用一张图来表示在本rpc项目中注册中心的作用\",{\"1\":{\"72\":1}}],[\"用于执行需要重试的远程调用任务\",{\"1\":{\"127\":1}}],[\"用于执行一个可以返回结果的任务\",{\"1\":{\"127\":1}}],[\"用于轮询\",{\"1\":{\"117\":1,\"118\":1}}],[\"用于解析接收到的数据\",{\"1\":{\"108\":1}}],[\"用于处理从\",{\"1\":{\"108\":1}}],[\"用于处理rpcrequest对象的参数列表\",{\"1\":{\"48\":1}}],[\"用于标识消息协议\",{\"1\":{\"98\":1}}],[\"用于标识当前\",{\"1\":{\"94\":1}}],[\"用于剔除过期节点\",{\"1\":{\"83\":1}}],[\"用于维护续期\",{\"1\":{\"81\":1}}],[\"用于分布式系统或计算机集群的共享配置\",{\"1\":{\"76\":1}}],[\"用于传递数据\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1}}],[\"用于在容错处理过程中传递一些数据\",{\"1\":{\"37\":1}}],[\"用于存储全局的\",{\"1\":{\"26\":1}}],[\"用于指定是否使用\",{\"1\":{\"16\":1}}],[\"用于指定容错策略\",{\"1\":{\"16\":1}}],[\"用于指定重试策略\",{\"1\":{\"16\":1}}],[\"用于指定负载均衡策略\",{\"1\":{\"16\":1}}],[\"用于指定服务的版本号\",{\"1\":{\"15\":1,\"16\":1}}],[\"用于指定服务接口类\",{\"1\":{\"15\":1,\"16\":1}}],[\"用于生成\",{\"1\":{\"5\":1}}],[\"用=分割\",{\"1\":{\"10\":1}}],[\"用来读取配置并加载实现类的方法\",{\"1\":{\"10\":1}}],[\"用户可以自行设置是否开启重试以及重试次数\",{\"1\":{\"120\":1}}],[\"用户可以根据自己的需求选择合适的日志实现\",{\"1\":{\"9\":1}}],[\"用户名\",{\"1\":{\"78\":2}}],[\"用户在使用的时候\",{\"1\":{\"29\":1}}],[\"用户自定义的spi\",{\"1\":{\"10\":1}}],[\"用户自定义spi目录\",{\"1\":{\"10\":1}}],[\"用户自定义spirpc\",{\"1\":{\"10\":1}}],[\"应用层协议\",{\"1\":{\"93\":1}}],[\"应用从\",{\"1\":{\"76\":1}}],[\"应用程序\",{\"1\":{\"29\":1}}],[\"应用程序的初始化引导类\",{\"1\":{\"14\":1}}],[\"应用\",{\"1\":{\"26\":2}}],[\"应用中更加灵活和可配置\",{\"1\":{\"18\":1}}],[\"应用名称\",{\"1\":{\"9\":1}}],[\"应用场景\",{\"1\":{\"0\":1}}],[\"以下是\",{\"1\":{\"127\":1}}],[\"以下为一些具体的应用场景\",{\"1\":{\"9\":1}}],[\"以兼顾服务的可靠性和性能\",{\"1\":{\"122\":1}}],[\"以提高系统的可用性和性能\",{\"1\":{\"110\":1}}],[\"以提供自己的数据库驱动程序\",{\"1\":{\"9\":1}}],[\"以便于后续的协议升级和兼容性管理\",{\"1\":{\"94\":1}}],[\"以便在发生故障时快速恢复\",{\"1\":{\"32\":1}}],[\"以应对不断增长的服务规模\",{\"1\":{\"74\":1}}],[\"以上两点便是我们这个rpc框架要实现序列化和反序列化的原因\",{\"1\":{\"43\":1}}],[\"以保证网络通信的一致性\",{\"1\":{\"24\":1}}],[\"以满足不同的业务需求\",{\"1\":{\"16\":1}}],[\"以及build都不需要\",{\"1\":{\"12\":1}}],[\"以控制对这个对象的访问\",{\"1\":{\"2\":1}}],[\"运行结果\",{\"1\":{\"8\":1,\"10\":1,\"26\":1,\"70\":1}}],[\"现在就是两个类都可以加载了\",{\"1\":{\"8\":1}}],[\"现在\",{\"1\":{\"8\":1}}],[\"成功加载\",{\"1\":{\"8\":1}}],[\"我画了一张框架图\",{\"1\":{\"25\":1}}],[\"我在里面写两个实现类\",{\"1\":{\"8\":1}}],[\"我在这里写的是狗\",{\"1\":{\"8\":1}}],[\"我们将退避时间\",{\"1\":{\"128\":1}}],[\"我们将整个结构拼接在一起成紧凑的数据\",{\"1\":{\"94\":1}}],[\"我们会调用\",{\"1\":{\"127\":1}}],[\"我们直接返回即可\",{\"1\":{\"125\":1}}],[\"我们直接随机10以内的数字\",{\"1\":{\"117\":1}}],[\"我们要确保被调用的服务的业务逻辑是幂等的\",{\"1\":{\"121\":1}}],[\"我们应该去掉重试之前出现过问题的那个节点\",{\"1\":{\"121\":1}}],[\"我们开一个数组\",{\"1\":{\"117\":1}}],[\"我们开发中国呢经常用到的框架基本都使用了java的spi机制\",{\"1\":{\"9\":1}}],[\"我们现在将空间划分为一个环形结构\",{\"1\":{\"116\":1}}],[\"我们现在要设计的rpc协议也是\",{\"1\":{\"93\":1}}],[\"我们封装一个tcpbufferhandlerwrapper类\",{\"1\":{\"108\":1}}],[\"我们每次只读取指定长度的数据\",{\"1\":{\"108\":1}}],[\"我们使用了\",{\"1\":{\"126\":1}}],[\"我们使用completablefuture将异步转为同步\",{\"1\":{\"103\":1}}],[\"我们使用vert\",{\"1\":{\"100\":1}}],[\"我们通过vert\",{\"1\":{\"102\":1}}],[\"我们读取的body的大小应该是bodylength的值\",{\"1\":{\"99\":1}}],[\"我们就可以捕获异常\",{\"1\":{\"120\":1}}],[\"我们就可以参考上面的图了\",{\"1\":{\"99\":1}}],[\"我们就不用使用key=value的格式\",{\"1\":{\"94\":1}}],[\"我们的负载均衡器算法的作用主要就是从注册服务中去选出一个服务来使用\",{\"1\":{\"113\":1}}],[\"我们的\",{\"1\":{\"102\":1}}],[\"我们的rpc消息所需要的信息\",{\"1\":{\"94\":1}}],[\"我们的注册中心需要实现几个关键的能力\",{\"1\":{\"74\":1}}],[\"我们设计消息结构的目的是为了用最少的空间来传输需要的信息\",{\"1\":{\"94\":1}}],[\"我们选择使用tcp协议进行网络传输\",{\"1\":{\"93\":1}}],[\"我们怎么知道服务提供者要去维护哪些节点呢\",{\"1\":{\"87\":1}}],[\"我们给节点注册的时候加上了过期时间\",{\"1\":{\"87\":1}}],[\"我们向etcd定期发送心跳信号来检测目标是否存活\",{\"1\":{\"87\":1}}],[\"我们有一个本地缓存数组servicecache\",{\"1\":{\"85\":1}}],[\"我们可以实现一个指数退避重试策略\",{\"1\":{\"127\":1}}],[\"我们可以使用内置的recordparser来解决半包和粘包问题\",{\"1\":{\"108\":1}}],[\"我们可以使用动态代理\",{\"1\":{\"70\":1}}],[\"我们可以\",{\"1\":{\"86\":1}}],[\"我们可能会有多个注册中心\",{\"1\":{\"79\":1}}],[\"我们实现etcd作为注册中心\",{\"1\":{\"75\":1}}],[\"我们实现静态代理userserviceproxy\",{\"1\":{\"3\":1}}],[\"我们需要搞清楚几个问题\",{\"1\":{\"123\":1}}],[\"我们需要先判定下这个请求是否已经超时\",{\"1\":{\"121\":1}}],[\"我们需要实现一个编码器和解码器\",{\"1\":{\"97\":1}}],[\"我们需要关闭所有注册的服务\",{\"1\":{\"86\":1}}],[\"我们需要考虑它的性能\",{\"1\":{\"75\":1}}],[\"我们需要根据当前的上下文信息来决定如何进行容错处理\",{\"1\":{\"37\":1}}],[\"我们是通过jmockdata来实现模拟数据的获取\",{\"1\":{\"70\":1}}],[\"我们写了一个类\",{\"1\":{\"61\":1}}],[\"我们为什么要实现序列化\",{\"0\":{\"43\":1}}],[\"我们在消息头中已经设置了请求体的长度\",{\"1\":{\"107\":1}}],[\"我们在重试策略失败的时候\",{\"1\":{\"40\":1}}],[\"我们在com\",{\"1\":{\"8\":1}}],[\"我们返回一个默认的rpcresponse即可\",{\"1\":{\"39\":1}}],[\"我们定义的\",{\"1\":{\"37\":1}}],[\"我们定一个接口userservice\",{\"1\":{\"3\":1}}],[\"我们再来看看如何从配置文件中读取信息\",{\"1\":{\"26\":1}}],[\"我们希望在里面可以集中管理这些配置选项\",{\"1\":{\"25\":1}}],[\"我们希望在spring框架初始化的时候\",{\"1\":{\"18\":1}}],[\"我们还需要一个rpcapplication\",{\"1\":{\"25\":1}}],[\"我们主要做了以下一些配置\",{\"1\":{\"25\":1}}],[\"我们让启动类实现beanpostprocessor接口里的postprocessafterinitialization方法\",{\"1\":{\"19\":1}}],[\"我们参考dubbo\",{\"1\":{\"11\":1}}],[\"我们想要开发者可以用更少的代码就可以使用我们的rpc框架\",{\"1\":{\"28\":1}}],[\"我们想要使用dubbo框架的rpc远程调用功能\",{\"1\":{\"11\":1}}],[\"我们想要用动态代理\",{\"1\":{\"4\":1}}],[\"我们系统内置的spi\",{\"1\":{\"10\":1}}],[\"我们自定义的目录位置可以放在resources\",{\"1\":{\"10\":1}}],[\"我们发现\",{\"1\":{\"8\":1}}],[\"我们看到了从注册中心查询服务提供者信息\",{\"1\":{\"4\":1}}],[\"里面放上我们需要用到的实现类\",{\"1\":{\"8\":1}}],[\"然后二分求位置\",{\"1\":{\"117\":1}}],[\"然后4>=3不符合\",{\"1\":{\"117\":1}}],[\"然后在\",{\"1\":{\"116\":1}}],[\"然后将这些虚拟节点及对应的服务实例信息存储到\",{\"1\":{\"116\":1}}],[\"然后将字节数组本身也写入\",{\"1\":{\"98\":1}}],[\"然后分配到其他节点上\",{\"1\":{\"116\":1}}],[\"然后可以获取消息体的长度\",{\"1\":{\"108\":1}}],[\"然后再轮询\",{\"1\":{\"117\":1}}],[\"然后再分配到真实的服务器\",{\"1\":{\"111\":2}}],[\"然后再分配到真实的\",{\"1\":{\"111\":2}}],[\"然后再向服务提供者发起调用\",{\"1\":{\"72\":1}}],[\"然后再实现具体的序列化器\",{\"1\":{\"46\":1}}],[\"然后反序列化为声明的类型\",{\"1\":{\"48\":1}}],[\"然后使用取模运算\",{\"1\":{\"115\":1}}],[\"然后使用objectmapper\",{\"1\":{\"48\":1}}],[\"然后使用class\",{\"1\":{\"10\":1}}],[\"然后去获取所有的服务列表\",{\"1\":{\"40\":1}}],[\"然后调用\",{\"1\":{\"29\":1}}],[\"然后让提供者\",{\"1\":{\"28\":1}}],[\"然后根据算法将请求转发到目标服务器\",{\"1\":{\"111\":1}}],[\"然后根据\",{\"1\":{\"26\":1,\"98\":1}}],[\"然后利用反射机制\",{\"1\":{\"19\":1}}],[\"然后编写测试代码\",{\"1\":{\"8\":1}}],[\"然后我们在meta\",{\"1\":{\"8\":1}}],[\"然后实现invoke方法\",{\"1\":{\"4\":1}}],[\"的好处是\",{\"1\":{\"127\":1}}],[\"的方法\",{\"1\":{\"127\":1}}],[\"的方案\",{\"1\":{\"69\":1}}],[\"的服务调用者会与\",{\"1\":{\"110\":1}}],[\"的负载均衡完全由\",{\"1\":{\"110\":1}}],[\"的固定长度模式为消息头长度\",{\"1\":{\"108\":1}}],[\"的固定长度模式为该长度\",{\"1\":{\"108\":1}}],[\"的输出处理器\",{\"1\":{\"108\":1}}],[\"的初始化逻辑\",{\"1\":{\"108\":1}}],[\"的吞吐量和延迟\",{\"1\":{\"91\":1}}],[\"的首要数据存储\",{\"1\":{\"76\":1}}],[\"的类上加yunrpcservice\",{\"1\":{\"63\":1}}],[\"的原始对象会被擦除\",{\"1\":{\"48\":2}}],[\"的操作\",{\"1\":{\"36\":1}}],[\"的关键功能之一\",{\"1\":{\"25\":1}}],[\"的值为\",{\"1\":{\"19\":1}}],[\"的注解驱动设计模式\",{\"1\":{\"14\":1}}],[\"的\",{\"1\":{\"10\":1,\"20\":2,\"98\":2,\"102\":1,\"108\":1,\"127\":2}}],[\"的spi\",{\"1\":{\"10\":1}}],[\"的思想\",{\"1\":{\"7\":1}}],[\"的meta\",{\"1\":{\"7\":1}}],[\"为\",{\"1\":{\"127\":1}}],[\"为服务注册\",{\"1\":{\"77\":1}}],[\"为服务消费者提供查询\",{\"1\":{\"72\":1}}],[\"为节点配置提供冗余和弹性\",{\"1\":{\"76\":1}}],[\"为了能够在约定的时间内进行安全可靠的重试\",{\"1\":{\"121\":1}}],[\"为了能够及时感知到服务的变化\",{\"1\":{\"116\":1}}],[\"为了更方便的获取结果\",{\"1\":{\"103\":1}}],[\"为了更直观表示我们整个系统的配置\",{\"1\":{\"25\":1}}],[\"为了解决这个问题\",{\"1\":{\"48\":1}}],[\"为什么会有安全问题\",{\"1\":{\"44\":1}}],[\"为什么要重试机制\",{\"0\":{\"121\":1}}],[\"为什么要自定义rpc协议\",{\"0\":{\"91\":1}}],[\"为什么要接口mock服务\",{\"0\":{\"69\":1}}],[\"为什么要容错机制\",{\"0\":{\"33\":1}}],[\"为什么要全局配置加载\",{\"0\":{\"24\":1}}],[\"为用户提供稳定可靠的服务\",{\"1\":{\"33\":1}}],[\"为属性生成代理对象\",{\"1\":{\"20\":1}}],[\"为某个接口寻找服务实现的机制\",{\"1\":{\"7\":1}}],[\"为客户端提供一个简单\",{\"1\":{\"2\":1}}],[\"配置管理等功能\",{\"1\":{\"73\":1}}],[\"配置复杂\",{\"1\":{\"44\":1}}],[\"配置备份等\",{\"1\":{\"32\":1}}],[\"配置读取等常见的\",{\"1\":{\"29\":1}}],[\"配置中指定的服务端口\",{\"1\":{\"29\":1}}],[\"配置中的注册中心信息\",{\"1\":{\"29\":1}}],[\"配置\",{\"1\":{\"26\":4}}],[\"配置工具类\",{\"1\":{\"26\":1}}],[\"配置对象\",{\"1\":{\"26\":2}}],[\"配置文件读取\",{\"1\":{\"24\":1}}],[\"配置文件中有接口的具体实现类名\",{\"1\":{\"7\":1}}],[\"配置信息繁多\",{\"1\":{\"24\":1}}],[\"配置和注册中心\",{\"1\":{\"18\":1}}],[\"配置是否开启了\",{\"1\":{\"5\":1}}],[\"一致性hash环\",{\"1\":{\"116\":1}}],[\"一致性哈希算法的实现相比轮询算法要复杂一些\",{\"1\":{\"116\":1}}],[\"一致性哈希负载均衡器\",{\"0\":{\"116\":1},\"1\":{\"116\":1}}],[\"一致性哈希\",{\"1\":{\"112\":1}}],[\"一个通俗的描述是\",{\"1\":{\"90\":1}}],[\"一个故障可能会通过调用链在系统中传播\",{\"1\":{\"33\":1}}],[\"一些临时性的错误\",{\"1\":{\"121\":1}}],[\"一些协议概念\",{\"0\":{\"90\":1}}],[\"一些功能如\",{\"1\":{\"74\":1}}],[\"一直不去续期\",{\"1\":{\"87\":1}}],[\"一般都是以jar包做依赖\",{\"1\":{\"7\":1}}],[\"一起写个dubbo\",{\"1\":{\"0\":1}}],[\"目的是将流量切换回原来的服务实例\",{\"1\":{\"41\":1}}],[\"目录\",{\"1\":{\"10\":1}}],[\"目录里创建一个以服务接口命名的文件\",{\"1\":{\"7\":1}}],[\"目标类实现的接口数组\",{\"1\":{\"5\":1}}],[\"目标类的类加载器\",{\"1\":{\"5\":1}}],[\"解码\",{\"1\":{\"102\":1}}],[\"解码器在按照这个顺序依次读取\",{\"1\":{\"94\":1}}],[\"解析消息体\",{\"1\":{\"99\":1}}],[\"解析服务\",{\"1\":{\"85\":1}}],[\"解析效率低\",{\"1\":{\"44\":1}}],[\"解决思路类似\",{\"1\":{\"108\":1}}],[\"解决粘包问题\",{\"1\":{\"99\":1}}],[\"解决上述问题\",{\"1\":{\"69\":1}}],[\"解决这个问题\",{\"1\":{\"51\":1}}],[\"解耦\",{\"1\":{\"7\":1}}],[\"解释\",{\"1\":{\"4\":1,\"98\":1,\"124\":1}}],[\"其中处理连接请求在后面\",{\"1\":{\"100\":1}}],[\"其实rpc不是一种协议\",{\"1\":{\"90\":1}}],[\"其次加载\",{\"1\":{\"26\":1}}],[\"其核心思想就是\",{\"1\":{\"7\":1}}],[\"其他部分\",{\"1\":{\"128\":1}}],[\"其他的调用则会被取消\",{\"1\":{\"34\":1}}],[\"其他不同厂商可以针对同一接口做出不同的实现\",{\"1\":{\"7\":1}}],[\"其他\",{\"1\":{\"0\":1}}],[\"主动下线\",{\"1\":{\"86\":1}}],[\"主机\",{\"1\":{\"29\":1}}],[\"主要区别在于退避时间的计算方式\",{\"1\":{\"128\":1}}],[\"主要步骤如下\",{\"1\":{\"127\":1}}],[\"主要实现了以下功能\",{\"1\":{\"102\":1}}],[\"主要实现几个核心的\",{\"1\":{\"74\":1}}],[\"主要涉及半包\",{\"1\":{\"100\":1}}],[\"主要有三步\",{\"1\":{\"11\":1}}],[\"主要体现在以下几个方面\",{\"1\":{\"9\":1}}],[\"主要是被框架的开发人员使用\",{\"1\":{\"7\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"通知\",{\"1\":{\"94\":1}}],[\"通常使用端口\",{\"1\":{\"90\":1}}],[\"通常会根据业务特点和性能需求\",{\"1\":{\"122\":1}}],[\"通常会配合负载均衡策略使用\",{\"1\":{\"34\":1}}],[\"通常会采用动态代理的方式来实现客户端的代理对象\",{\"1\":{\"4\":1}}],[\"通过轮询的方式\",{\"1\":{\"117\":1}}],[\"通过将请求映射到虚拟节点上\",{\"1\":{\"116\":1}}],[\"通过将引导类的注册和初始化过程封装在这个注解中\",{\"1\":{\"14\":1}}],[\"通过负载均衡\",{\"1\":{\"110\":1}}],[\"通过反射调用\",{\"1\":{\"102\":1}}],[\"通过反射调用对应的服务实现类方法\",{\"1\":{\"102\":1}}],[\"通过反射调用对应的服务实现类\",{\"1\":{\"102\":1}}],[\"通过分散配置数据\",{\"1\":{\"76\":1}}],[\"通过分析异常信息\",{\"1\":{\"37\":1}}],[\"通过注册中心\",{\"1\":{\"72\":1}}],[\"通过手动控制反序列化的过程\",{\"1\":{\"48\":1}}],[\"通过传入上下文信息和异常对象\",{\"1\":{\"37\":1}}],[\"通过快速返回\",{\"1\":{\"34\":1}}],[\"通过业务层面的兜底措施\",{\"1\":{\"32\":1}}],[\"通过单例模式来获取上述的rpc配置信息\",{\"1\":{\"25\":1}}],[\"通过\",{\"1\":{\"10\":1}}],[\"通过在classpath下的meta\",{\"1\":{\"9\":2}}],[\"通过接口注解\",{\"1\":{\"9\":1}}],[\"通过读取classpath下的meta\",{\"1\":{\"9\":1}}],[\"通过这个上下文对象\",{\"1\":{\"37\":1}}],[\"通过这个注解\",{\"1\":{\"14\":1}}],[\"通过这个\",{\"1\":{\"5\":1}}],[\"该负载均衡器使用一个\",{\"1\":{\"116\":1}}],[\"该处理器内部实现了以下逻辑\",{\"1\":{\"108\":1}}],[\"该代理对象会负责执行\",{\"1\":{\"16\":1}}],[\"该对象实现了目标类的所有接口方法\",{\"1\":{\"5\":1}}],[\"该方法声明为\",{\"1\":{\"127\":1}}],[\"该方法接受一个\",{\"1\":{\"124\":1}}],[\"该方法需要传入三个参数\",{\"1\":{\"5\":1}}],[\"该方法使用\",{\"1\":{\"5\":1}}],[\"该方法首先检查\",{\"1\":{\"5\":1}}],[\"返回结果\",{\"1\":{\"127\":1}}],[\"返回结果处理\",{\"1\":{\"4\":1}}],[\"返回最大权重对应的服务\",{\"1\":{\"118\":1}}],[\"返回当前服务\",{\"1\":{\"117\":1}}],[\"返回处理结果\",{\"1\":{\"103\":1}}],[\"返回值等\",{\"1\":{\"94\":1}}],[\"返回给消费者\",{\"1\":{\"72\":1}}],[\"返回给调用方\",{\"1\":{\"34\":1}}],[\"返回\",{\"1\":{\"10\":1}}],[\"返回代理对象\",{\"1\":{\"5\":1}}],[\"或者对于一些幂等性较强的操作\",{\"1\":{\"122\":1}}],[\"或者\",{\"1\":{\"117\":1}}],[\"或主机名接收请求\",{\"1\":{\"111\":1}}],[\"或反射的方式创建\",{\"1\":{\"10\":1}}],[\"或\",{\"1\":{\"5\":1}}],[\"创建租约\",{\"1\":{\"83\":1}}],[\"创建lease\",{\"1\":{\"83\":1}}],[\"创建\",{\"1\":{\"29\":1,\"102\":1}}],[\"创建对应的注册中心实例\",{\"1\":{\"29\":1}}],[\"创建并初始化注册中心实例\",{\"1\":{\"26\":1}}],[\"创建并\",{\"1\":{\"26\":1,\"86\":1}}],[\"创建实例等\",{\"1\":{\"10\":1}}],[\"创建动态代理实例\",{\"1\":{\"5\":1}}],[\"创建一个新的\",{\"1\":{\"108\":1}}],[\"创建一个tcp服务器\",{\"1\":{\"100\":1}}],[\"创建一个vertx实例\",{\"1\":{\"100\":1}}],[\"创建一个\",{\"1\":{\"5\":1}}],[\"则进入重试流程\",{\"1\":{\"127\":1}}],[\"则进行重试处理\",{\"1\":{\"127\":1}}],[\"则直接返回结果\",{\"1\":{\"127\":2}}],[\"则通过\",{\"1\":{\"127\":1}}],[\"则抛出异常\",{\"1\":{\"124\":1,\"127\":1}}],[\"则返回调用结果\",{\"1\":{\"124\":1}}],[\"则可以考虑使用断路器重试策略\",{\"1\":{\"122\":1}}],[\"则选择环上的第一个虚拟节点\",{\"1\":{\"116\":1}}],[\"则将异常信息设置到\",{\"1\":{\"102\":1}}],[\"则创建一个默认的\",{\"1\":{\"26\":1}}],[\"则执行以下逻辑\",{\"1\":{\"20\":1}}],[\"则获取该注解实例\",{\"1\":{\"20\":1}}],[\"则为这些字段生成代理对象并注入\",{\"1\":{\"20\":1}}],[\"则说明开发者没有手动指定接口类\",{\"1\":{\"19\":1}}],[\"则使用objectmapper重新将参数对象序列化为字节数组\",{\"1\":{\"48\":1}}],[\"则使用\",{\"1\":{\"5\":1}}],[\"则调用\",{\"1\":{\"5\":1}}],[\"则需要修改代理类的代码\",{\"1\":{\"3\":1}}],[\"客户端在不知道调用细节的情况下\",{\"1\":{\"90\":1}}],[\"客户端\",{\"1\":{\"79\":1}}],[\"客户端没有更新会失败\",{\"1\":{\"44\":1}}],[\"客户端传递类的readobject中代码会自动执行\",{\"1\":{\"44\":1}}],[\"客户端的场景下\",{\"1\":{\"14\":1}}],[\"客户端的代理对象\",{\"1\":{\"5\":1}}],[\"客户端可以非常方便地获取到\",{\"1\":{\"5\":1}}],[\"客户端调用时无需关心这些细节\",{\"1\":{\"4\":1}}],[\"客户端只需要依赖目标服务的接口\",{\"1\":{\"5\":1}}],[\"客户端只需要依赖代理对象\",{\"1\":{\"2\":1}}],[\"客户端只需要调用代理对象的方法\",{\"1\":{\"2\":1}}],[\"构建\",{\"1\":{\"117\":1}}],[\"构建虚拟节点环\",{\"1\":{\"116\":1}}],[\"构建配置文件路径\",{\"1\":{\"26\":1}}],[\"构建了一个\",{\"1\":{\"4\":1}}],[\"构造parser\",{\"1\":{\"108\":1}}],[\"构造响应结果对象\",{\"1\":{\"102\":1}}],[\"构造上下文\",{\"1\":{\"4\":1,\"40\":1,\"103\":1}}],[\"构造请求\",{\"1\":{\"4\":2,\"103\":2}}],[\"当网络环境较差时\",{\"1\":{\"128\":1}}],[\"当远程调用失败时\",{\"1\":{\"122\":1}}],[\"当远程服务调用失败时\",{\"1\":{\"121\":1}}],[\"当调用端发起的请求失败时\",{\"1\":{\"121\":1}}],[\"当调用一个服务时\",{\"1\":{\"34\":2}}],[\"当重试次数达到用户配置的重试次数的时候\",{\"1\":{\"120\":1}}],[\"当消息发送失败或收到异常消息时\",{\"1\":{\"120\":1}}],[\"当增加或删除服务实例时\",{\"1\":{\"116\":1}}],[\"当客户端发起请求时\",{\"1\":{\"116\":1}}],[\"当接收到完整的消息体数据后\",{\"1\":{\"108\":1}}],[\"当前索引\",{\"1\":{\"115\":1}}],[\"当前节点下线\",{\"1\":{\"86\":1}}],[\"当前请求的参数\",{\"1\":{\"37\":1}}],[\"当存在多个可用的服务提供者时\",{\"1\":{\"74\":1}}],[\"当实际服务不可用时\",{\"1\":{\"69\":1}}],[\"当你从字节数组中反序列化一个对象时\",{\"1\":{\"48\":1}}],[\"当你使用泛型类型作为方法参数或返回值时\",{\"1\":{\"48\":1}}],[\"当服务恢复正常后\",{\"1\":{\"122\":1}}],[\"当服务出现多次失败时\",{\"1\":{\"122\":1}}],[\"当服务提供者关闭的时候\",{\"1\":{\"86\":1}}],[\"当服务提供者恢复正常后\",{\"1\":{\"34\":1}}],[\"当服务调用出现异常时\",{\"1\":{\"34\":2,\"39\":1}}],[\"当服务的提供者提供了一种接口的实现之后\",{\"1\":{\"7\":1}}],[\"当某个服务实例下线或者故障时\",{\"1\":{\"72\":1}}],[\"当某个服务提供者出现故障时\",{\"1\":{\"34\":1}}],[\"当某个服务节点出现故障时\",{\"1\":{\"32\":1}}],[\"当依赖的关键服务出现故障时\",{\"1\":{\"32\":1}}],[\"当发现故障时\",{\"1\":{\"32\":1}}],[\"当一个远程调用出现异常时\",{\"1\":{\"37\":1}}],[\"当一个字段被这个注解标注时\",{\"1\":{\"16\":1}}],[\"当一个类被这个注解标注时\",{\"1\":{\"15\":1}}],[\"当\",{\"1\":{\"14\":1,\"49\":2,\"127\":1}}],[\"当其他的程序需要这个服务的时候\",{\"1\":{\"7\":1}}],[\"当代理对象的方法被调用时\",{\"1\":{\"4\":1}}],[\"当然\",{\"1\":{\"3\":1}}],[\"是许多其他项目的核心组件\",{\"1\":{\"76\":1}}],[\"是一种无连接的协议\",{\"1\":{\"90\":1}}],[\"是一种开源的分布式统一键值存储\",{\"1\":{\"76\":1}}],[\"是一个函数式接口\",{\"1\":{\"127\":2}}],[\"是一个静态的\",{\"1\":{\"26\":1}}],[\"是一个非常重要的概念\",{\"1\":{\"2\":1}}],[\"是否mock\",{\"1\":{\"16\":1}}],[\"是按行读取\",{\"1\":{\"10\":1}}],[\"是jdk内置的一种\",{\"1\":{\"7\":1}}],[\"是\",{\"1\":{\"4\":1,\"72\":1,\"127\":1}}],[\"类中\",{\"1\":{\"127\":1}}],[\"类的作用是将从\",{\"1\":{\"108\":1}}],[\"类来管理\",{\"1\":{\"25\":1}}],[\"类将\",{\"1\":{\"25\":1}}],[\"类是一个\",{\"1\":{\"108\":1}}],[\"类是整个\",{\"1\":{\"26\":1}}],[\"类是\",{\"1\":{\"20\":1,\"25\":1}}],[\"类负责在\",{\"1\":{\"18\":1}}],[\"类型的\",{\"1\":{\"115\":1}}],[\"类型\",{\"1\":{\"10\":2,\"94\":1}}],[\"类路径=>\",{\"1\":{\"10\":2}}],[\"类\",{\"1\":{\"5\":1,\"29\":1}}],[\"类提供了两个静态方法\",{\"1\":{\"5\":1}}],[\"类实现了\",{\"1\":{\"4\":1}}],[\"类及其相关接口实现\",{\"1\":{\"4\":1}}],[\"就返回给调用端动态代理一个失败异常\",{\"1\":{\"120\":1}}],[\"就返回结果\",{\"1\":{\"34\":1}}],[\"就是当调用端发起的请求失败时\",{\"1\":{\"120\":1}}],[\"就是保证可以读取size\",{\"1\":{\"108\":1}}],[\"就是提供了这样一个机制\",{\"1\":{\"7\":1}}],[\"就像调用本地应用程序中的对象一样\",{\"1\":{\"90\":1}}],[\"就不用从etcd中获取了\",{\"1\":{\"85\":1}}],[\"就中断\",{\"1\":{\"36\":1}}],[\"就可以从本地注册表中获取到服务的实现类\",{\"1\":{\"19\":1}}],[\"就可以在服务提供者bean初始化之后\",{\"1\":{\"19\":1}}],[\"就可以自动完成\",{\"1\":{\"14\":1}}],[\"就可以使用该服务了\",{\"1\":{\"7\":1}}],[\"就可以通过查找这个jar包\",{\"1\":{\"7\":1}}],[\"就可以为目标服务添加各种中间件功能\",{\"1\":{\"4\":1}}],[\"就需要去继承invocationhandler接口\",{\"1\":{\"4\":1}}],[\">>\",{\"1\":{\"10\":6,\"29\":2,\"51\":2}}],[\">>>\",{\"1\":{\"10\":2}}],[\">\",{\"1\":{\"4\":1,\"10\":5,\"15\":2,\"16\":2,\"19\":2,\"20\":2,\"26\":5,\"29\":2,\"40\":2,\"41\":1,\"48\":2,\"49\":1,\"51\":2,\"70\":1,\"85\":1,\"88\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":4,\"102\":2,\"103\":3,\"108\":3,\"118\":1,\"124\":1,\"127\":1,\"128\":1}}],[\"负载均衡选择节点的时候\",{\"1\":{\"121\":1}}],[\"负载均衡选择服务提供者\",{\"1\":{\"4\":1}}],[\"负载均衡接口定义\",{\"0\":{\"113\":1}}],[\"负载均衡算法实现\",{\"0\":{\"112\":1}}],[\"负载均衡可分为四层负载\",{\"1\":{\"111\":1}}],[\"负载均衡可分为软件负载均衡和硬件负载均衡\",{\"1\":{\"111\":1}}],[\"负载均衡类型\",{\"0\":{\"111\":1}}],[\"负载均衡是一个非常重要的概念\",{\"1\":{\"110\":1}}],[\"负载均衡我们已经在rpc层实现过了\",{\"1\":{\"74\":1}}],[\"负载均衡配置\",{\"1\":{\"25\":1}}],[\"负载均衡策略也需要考虑容错因素\",{\"1\":{\"32\":1}}],[\"负载均衡策略\",{\"1\":{\"16\":1,\"74\":1}}],[\"负载均衡\",{\"1\":{\"4\":1,\"25\":1,\"103\":1,\"116\":1}}],[\"负载均衡器实现\",{\"0\":{\"109\":1}}],[\"负载均衡器\",{\"1\":{\"0\":2,\"26\":1,\"113\":1}}],[\"从列表中随便选一个即可\",{\"1\":{\"114\":1}}],[\"从而降低系统负载\",{\"1\":{\"127\":1}}],[\"从而影响到业务处理的耗时\",{\"1\":{\"121\":1}}],[\"从而实现负载均衡的目标\",{\"1\":{\"117\":1}}],[\"从而实现自动装配和依赖注入\",{\"1\":{\"9\":1}}],[\"从而很好的解决了倾斜问题\",{\"1\":{\"116\":1}}],[\"从而从列表中选择对应的服务实例返回\",{\"1\":{\"115\":1}}],[\"从而达到多个服务节点共同分担请求压力的目的\",{\"1\":{\"110\":1}}],[\"从而加快开发进度\",{\"1\":{\"69\":1}}],[\"从而做出更加合理的容错决策\",{\"1\":{\"37\":1}}],[\"从而满足不同应用场景的需求\",{\"1\":{\"25\":1}}],[\"从\",{\"1\":{\"19\":1,\"102\":1}}],[\"从实例缓存中加载指定类型的实例\",{\"1\":{\"10\":2}}],[\"从注册中心获取服务提供者请求地址\",{\"1\":{\"4\":1,\"103\":1}}],[\"从零开始实现简单\",{\"1\":{\"0\":1}}],[\"v\",{\"1\":{\"127\":1}}],[\"virtualnodes\",{\"1\":{\"116\":6}}],[\"virtual\",{\"1\":{\"116\":3}}],[\"values\",{\"1\":{\"118\":2}}],[\"value\",{\"1\":{\"83\":2,\"87\":2}}],[\"volatile\",{\"1\":{\"26\":2,\"86\":1}}],[\"void\",{\"1\":{\"3\":2,\"8\":4,\"10\":3,\"15\":3,\"16\":3,\"18\":1,\"19\":2,\"20\":1,\"26\":3,\"29\":2,\"30\":2,\"61\":1,\"64\":1,\"65\":2,\"66\":1,\"70\":1,\"79\":6,\"82\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":2,\"87\":2,\"88\":1,\"100\":2,\"101\":2,\"102\":1,\"108\":3,\"117\":1,\"126\":1}}],[\"vert\",{\"1\":{\"29\":1,\"97\":1,\"102\":1,\"103\":1,\"108\":1}}],[\"vertx\",{\"1\":{\"100\":5,\"101\":10}}],[\"vertxtcpserver\",{\"1\":{\"18\":4,\"29\":7,\"100\":2}}],[\"vertxtcpclient\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"101\":2,\"103\":2,\"108\":1}}],[\"vertxhttpserver\",{\"1\":{\"3\":2}}],[\"version>\",{\"1\":{\"12\":3,\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"57\":2,\"70\":1,\"124\":1}}],[\"version>17<\",{\"1\":{\"12\":1}}],[\"version\",{\"1\":{\"4\":1,\"15\":3,\"16\":3,\"25\":1,\"26\":1,\"96\":1,\"98\":1,\"101\":1,\"103\":1}}],[\"+=\",{\"1\":{\"117\":1,\"118\":1,\"128\":2}}],[\"+field\",{\"1\":{\"20\":1}}],[\"+\",{\"1\":{\"3\":1,\"8\":2,\"10\":4,\"20\":2,\"26\":3,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"83\":2,\"84\":1,\"85\":2,\"86\":1,\"87\":1,\"99\":1,\"100\":1,\"101\":3,\"111\":1,\"116\":2,\"118\":1}}],[\"err\",{\"1\":{\"100\":1,\"101\":1}}],[\"error\",{\"1\":{\"10\":3,\"26\":3,\"38\":1,\"40\":2,\"41\":2}}],[\"et\",{\"1\":{\"76\":1}}],[\"etcd注册中心监听机制\",{\"1\":{\"129\":1}}],[\"etcd注册中心实现\",{\"0\":{\"80\":1}}],[\"etcd实现心跳检测比较简单\",{\"1\":{\"87\":1}}],[\"etcd过期机制删除\",{\"1\":{\"86\":1}}],[\"etcd介绍\",{\"0\":{\"76\":1}}],[\"etcd\",{\"0\":{\"71\":1},\"1\":{\"73\":1,\"75\":1,\"76\":5,\"78\":1,\"81\":1,\"83\":2,\"84\":1,\"85\":1}}],[\"eureka\",{\"1\":{\"73\":1}}],[\"esotericsoftware\",{\"1\":{\"49\":3}}],[\"esotericsoftware<\",{\"1\":{\"49\":1}}],[\"empty\",{\"1\":{\"40\":1,\"41\":1}}],[\"event\",{\"1\":{\"88\":2,\"102\":1}}],[\"ev\",{\"1\":{\"26\":1}}],[\"elapsed\",{\"1\":{\"127\":1,\"128\":1}}],[\"elapsedtime\",{\"1\":{\"127\":2,\"128\":2}}],[\"else\",{\"1\":{\"18\":1,\"30\":1,\"100\":1,\"101\":1,\"108\":2}}],[\"elementtype\",{\"1\":{\"14\":2,\"15\":2,\"16\":2,\"21\":1}}],[\"encodebuffer\",{\"1\":{\"101\":2}}],[\"encode\",{\"1\":{\"98\":1,\"101\":1,\"102\":4}}],[\"endpoints\",{\"1\":{\"82\":1}}],[\"env\",{\"1\":{\"26\":35}}],[\"environment\",{\"1\":{\"26\":9}}],[\"enableyunrpc注解\",{\"1\":{\"18\":1}}],[\"enableyunrpc\",{\"0\":{\"14\":1,\"65\":1},\"1\":{\"14\":9,\"18\":2,\"21\":1,\"65\":2}}],[\"enabledubbo\",{\"1\":{\"11\":1}}],[\"entry<integer\",{\"1\":{\"116\":1}}],[\"entry<string\",{\"1\":{\"10\":1}}],[\"entryset\",{\"1\":{\"10\":1}}],[\"entry\",{\"1\":{\"10\":3,\"116\":4}}],[\"equals\",{\"1\":{\"10\":1,\"40\":1,\"41\":1}}],[\"eat\",{\"1\":{\"8\":6}}],[\"easymock\",{\"1\":{\"69\":1}}],[\"easyproviderexample\",{\"1\":{\"3\":1}}],[\"easyconsumerexample\",{\"1\":{\"3\":1}}],[\"exceeded\",{\"1\":{\"127\":1,\"128\":1}}],[\"exception\",{\"1\":{\"4\":1,\"8\":1,\"10\":1,\"19\":1,\"26\":1,\"29\":1,\"37\":3,\"38\":1,\"39\":1,\"40\":3,\"41\":2,\"79\":2,\"83\":1,\"85\":1,\"86\":1,\"87\":1,\"98\":1,\"99\":2,\"101\":3,\"102\":3,\"103\":1,\"124\":2,\"125\":2,\"126\":4,\"127\":7,\"128\":3}}],[\"exponentialbackoffretrystrategy\",{\"1\":{\"127\":2}}],[\"exponential\",{\"1\":{\"122\":1}}],[\"exampleservice\",{\"1\":{\"66\":2}}],[\"exampleserviceimpltest\",{\"1\":{\"66\":1}}],[\"exampleserviceimpl\",{\"1\":{\"61\":1,\"64\":1,\"66\":1}}],[\"examplespringbootconsumerapplication\",{\"1\":{\"65\":2}}],[\"examplespringbootproviderapplication\",{\"1\":{\"65\":2}}],[\"ex\",{\"1\":{\"40\":1,\"41\":1}}],[\"exists\",{\"1\":{\"26\":5}}],[\"extends\",{\"1\":{\"29\":1}}],[\"extension\",{\"1\":{\"26\":2}}],[\"extern\",{\"1\":{\"10\":1,\"26\":1,\"127\":1,\"128\":1}}],[\"ext\",{\"1\":{\"26\":14}}],[\"execute\",{\"1\":{\"3\":1,\"87\":1}}],[\"e\",{\"1\":{\"3\":2,\"4\":2,\"10\":6,\"19\":2,\"20\":2,\"26\":9,\"29\":2,\"37\":4,\"38\":4,\"39\":3,\"40\":4,\"41\":2,\"47\":2,\"85\":2,\"86\":2,\"87\":2,\"101\":3,\"102\":6,\"103\":2,\"127\":2,\"128\":2}}],[\"unable\",{\"1\":{\"127\":2}}],[\"unregister\",{\"1\":{\"79\":1,\"84\":1}}],[\"up\",{\"1\":{\"127\":1,\"128\":1}}],[\"udp\",{\"1\":{\"90\":1,\"111\":1}}],[\"utf\",{\"1\":{\"83\":2,\"84\":1,\"85\":2,\"86\":1,\"87\":2,\"88\":1}}],[\"utils\",{\"1\":{\"26\":1}}],[\"util\",{\"1\":{\"7\":1,\"10\":5,\"26\":2,\"51\":2,\"127\":2,\"128\":2}}],[\"use\",{\"1\":{\"26\":1}}],[\"username\",{\"1\":{\"78\":1}}],[\"username=\",{\"1\":{\"3\":1}}],[\"user==null\",{\"1\":{\"30\":1}}],[\"user1\",{\"1\":{\"30\":3}}],[\"user\",{\"1\":{\"3\":13,\"30\":6,\"59\":4,\"60\":5,\"61\":7,\"63\":5,\"64\":7,\"70\":5,\"90\":1}}],[\"userserviceimpl\",{\"1\":{\"3\":3,\"29\":1,\"60\":1,\"63\":1}}],[\"userservice\",{\"1\":{\"3\":5,\"29\":1,\"30\":4,\"59\":1,\"60\":1,\"61\":3,\"63\":1,\"64\":3,\"70\":5}}],[\"userserviceproxy\",{\"1\":{\"3\":5}}],[\"url\",{\"1\":{\"3\":2,\"10\":2,\"111\":2}}],[\"idutil\",{\"1\":{\"101\":1}}],[\"id\",{\"1\":{\"96\":1,\"98\":1}}],[\"idl\",{\"1\":{\"69\":1}}],[\"ip\",{\"1\":{\"90\":1,\"111\":5}}],[\"i++\",{\"1\":{\"48\":1,\"101\":1,\"116\":1,\"117\":1}}],[\"i\",{\"1\":{\"48\":6,\"101\":2,\"116\":3,\"117\":2}}],[\"illegalaccessexception\",{\"1\":{\"10\":2,\"20\":1}}],[\"implclassname\",{\"1\":{\"10\":10}}],[\"implclass\",{\"1\":{\"10\":6,\"29\":3,\"102\":3}}],[\"implements\",{\"1\":{\"3\":2,\"4\":1,\"8\":2,\"18\":1,\"19\":1,\"20\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"60\":1,\"63\":1,\"70\":1,\"100\":1,\"102\":1,\"103\":1,\"108\":2,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1}}],[\"import到注册我们自定义的启动类\",{\"1\":{\"21\":1}}],[\"importingclassmetadata\",{\"1\":{\"18\":3}}],[\"importbeandefinitionregistrar\",{\"1\":{\"18\":1}}],[\"import\",{\"1\":{\"10\":12,\"14\":2,\"21\":1,\"26\":8,\"46\":1,\"47\":1,\"48\":4,\"49\":6,\"50\":5,\"51\":7,\"78\":2,\"96\":3,\"127\":4,\"128\":4}}],[\"index\",{\"1\":{\"115\":2}}],[\"invalid\",{\"1\":{\"99\":1}}],[\"invoke\",{\"1\":{\"4\":5,\"70\":1,\"102\":1,\"103\":1}}],[\"invocationhandler\",{\"1\":{\"4\":3,\"5\":1,\"70\":1,\"103\":1}}],[\"input\",{\"1\":{\"49\":6}}],[\"inputstream\",{\"1\":{\"47\":2}}],[\"inputstreamreader\",{\"1\":{\"10\":9}}],[\"in\",{\"1\":{\"26\":4}}],[\"int类型\",{\"1\":{\"98\":1}}],[\"int占4个字节\",{\"1\":{\"94\":1}}],[\"interval\",{\"1\":{\"122\":1,\"127\":2,\"128\":4}}],[\"interfaceclass\",{\"1\":{\"15\":2,\"16\":2,\"19\":7,\"20\":8}}],[\"interface\",{\"1\":{\"7\":1,\"8\":1,\"14\":2,\"15\":2,\"16\":2,\"21\":1,\"37\":1,\"46\":1,\"59\":1,\"79\":1,\"113\":1,\"124\":1,\"127\":1}}],[\"integer\",{\"1\":{\"77\":1}}],[\"int\",{\"1\":{\"26\":1,\"48\":1,\"77\":1,\"96\":1,\"100\":1,\"101\":1,\"108\":1,\"114\":1,\"115\":2,\"116\":5,\"117\":5,\"118\":3,\"127\":2,\"128\":2}}],[\"initial\",{\"1\":{\"127\":2,\"128\":4}}],[\"initrecordparser\",{\"1\":{\"108\":3}}],[\"init\",{\"1\":{\"18\":1,\"26\":9,\"29\":5,\"30\":3,\"79\":1,\"82\":1,\"86\":4,\"117\":1}}],[\"instanceof\",{\"1\":{\"48\":2}}],[\"instancecache是存放key对应的类的实例\",{\"1\":{\"10\":1}}],[\"instancecache\",{\"1\":{\"10\":8}}],[\"instantiationexception\",{\"1\":{\"10\":2}}],[\"info\",{\"1\":{\"10\":6,\"18\":1,\"20\":1,\"26\":2,\"39\":1,\"70\":3,\"86\":2,\"118\":1,\"126\":1,\"127\":1,\"128\":1}}],[\"inf\",{\"1\":{\"7\":2,\"8\":2,\"9\":4,\"10\":2}}],[\"isprefix\",{\"1\":{\"85\":1}}],[\"isnotempty\",{\"1\":{\"85\":1}}],[\"isnotblank\",{\"1\":{\"26\":2}}],[\"isassignablefrom\",{\"1\":{\"48\":1}}],[\"is\",{\"1\":{\"18\":1,\"40\":1,\"41\":1,\"100\":1}}],[\"ismock\",{\"1\":{\"5\":1}}],[\"isempty\",{\"1\":{\"4\":1,\"40\":1,\"41\":1,\"87\":1,\"103\":1,\"115\":1,\"116\":1,\"118\":1}}],[\"if\",{\"1\":{\"4\":1,\"5\":1,\"10\":6,\"18\":1,\"19\":2,\"20\":3,\"26\":4,\"30\":1,\"40\":2,\"41\":2,\"48\":3,\"51\":2,\"77\":1,\"85\":1,\"86\":2,\"87\":1,\"88\":1,\"98\":2,\"99\":3,\"100\":1,\"101\":2,\"103\":1,\"108\":2,\"114\":2,\"115\":2,\"116\":2,\"117\":1,\"118\":2,\"127\":3,\"128\":1}}],[\"ioc\",{\"1\":{\"7\":1}}],[\"ioexception\",{\"1\":{\"3\":1,\"10\":1,\"46\":5,\"47\":3,\"48\":6,\"49\":3,\"50\":3,\"51\":2}}],[\"io\",{\"1\":{\"0\":1,\"10\":4,\"26\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":5,\"50\":5,\"51\":5,\"75\":1}}],[\"=sum\",{\"1\":{\"118\":1}}],[\"==\",{\"1\":{\"10\":1,\"19\":1,\"20\":1,\"26\":2,\"40\":1,\"41\":1,\"51\":2,\"98\":3,\"99\":2,\"108\":2,\"114\":2,\"115\":1,\"116\":1,\"118\":1}}],[\"=\",{\"1\":{\"3\":10,\"4\":15,\"8\":1,\"10\":36,\"18\":3,\"19\":11,\"20\":10,\"26\":33,\"29\":9,\"30\":4,\"39\":2,\"40\":9,\"41\":4,\"47\":4,\"48\":9,\"49\":7,\"50\":4,\"51\":9,\"61\":2,\"64\":2,\"65\":2,\"70\":5,\"77\":3,\"78\":3,\"81\":4,\"82\":2,\"83\":6,\"84\":1,\"85\":8,\"86\":5,\"87\":4,\"88\":2,\"98\":5,\"99\":9,\"100\":2,\"101\":16,\"102\":10,\"103\":19,\"108\":12,\"114\":2,\"115\":3,\"116\":7,\"117\":10,\"118\":6,\"126\":1,\"127\":8,\"128\":7}}],[\"可实现更复杂的负载逻辑\",{\"1\":{\"111\":1}}],[\"可靠的\",{\"1\":{\"90\":1}}],[\"可靠的远程调用接口\",{\"1\":{\"2\":1}}],[\"可读性好\",{\"1\":{\"44\":2}}],[\"可能会导致单次请求失败\",{\"1\":{\"121\":1}}],[\"可能会导致负载分布不均匀的问题\",{\"1\":{\"116\":1}}],[\"可能有安全问题\",{\"1\":{\"49\":1}}],[\"可能导致性能下降或者序列化失败\",{\"1\":{\"44\":1}}],[\"可能存在反序列化漏洞\",{\"1\":{\"44\":2}}],[\"可在测试或者特殊场景下使用\",{\"1\":{\"25\":1}}],[\"可以更快地得到服务响应\",{\"1\":{\"128\":1}}],[\"可以方便地使用\",{\"1\":{\"127\":1}}],[\"可以返回一个计算结果\",{\"1\":{\"127\":1}}],[\"可以有效防止级联故障\",{\"1\":{\"122\":1}}],[\"可以保证每个实例都能够得到请求\",{\"1\":{\"117\":1}}],[\"可以防止并发冲突问题\",{\"1\":{\"115\":1}}],[\"可以应对动态扩容缩容场景\",{\"1\":{\"112\":1}}],[\"可以针对不同性能的实例进行加权\",{\"1\":{\"112\":1}}],[\"可以大幅降低数据传输的开销\",{\"1\":{\"91\":1}}],[\"可以选用zookeeper\",{\"1\":{\"79\":1}}],[\"可以选择\",{\"1\":{\"25\":2}}],[\"可以实现服务的权重调整\",{\"1\":{\"72\":1}}],[\"可以无需修改代码就能处理新的类型\",{\"1\":{\"49\":1}}],[\"可以将请求合理地分配到不同的服务实例上\",{\"1\":{\"116\":1}}],[\"可以将序列化数据和schema一起存储\",{\"1\":{\"44\":1}}],[\"可以将其设置为\",{\"1\":{\"14\":1}}],[\"可以把我们的上下文传过来\",{\"1\":{\"40\":1}}],[\"可以变成执行其他更稳定\",{\"1\":{\"36\":1}}],[\"可以避免阻塞调用链\",{\"1\":{\"34\":1}}],[\"可以采用指数退避重试策略\",{\"1\":{\"122\":1}}],[\"可以采用分片\",{\"1\":{\"74\":1}}],[\"可以采用主备复制\",{\"1\":{\"74\":1}}],[\"可以采用服务降级\",{\"1\":{\"32\":1}}],[\"可以采用服务熔断\",{\"1\":{\"32\":1}}],[\"可以采用重试机制来提高成功概率\",{\"1\":{\"32\":1}}],[\"可以使用\",{\"1\":{\"51\":1}}],[\"可以使用心跳监测\",{\"1\":{\"32\":1}}],[\"可以使用spring的importbeandefinitionregistrar接口来实现\",{\"1\":{\"18\":1}}],[\"可以直接使用hutool工具类实现\",{\"1\":{\"26\":1}}],[\"可以简化这个过程\",{\"1\":{\"24\":1}}],[\"可以被反射机制访问\",{\"1\":{\"14\":1}}],[\"可以看到先扫描系统目录\",{\"1\":{\"10\":1}}],[\"可以让\",{\"1\":{\"10\":1}}],[\"可以在每次重试时打印日志\",{\"1\":{\"126\":1}}],[\"可以在多线程环境中共享\",{\"1\":{\"48\":1}}],[\"可以在故障恢复后\",{\"1\":{\"34\":1}}],[\"可以在服务提供者初始化和创建过程中进行自定义操作\",{\"1\":{\"9\":1}}],[\"可以在代理类中添加额外的功能\",{\"1\":{\"3\":1}}],[\"可以通过构造函数传入\",{\"1\":{\"39\":1}}],[\"可以通过容错路由将请求重新分配到其他可用节点\",{\"1\":{\"32\":1}}],[\"可以通过修改配置文件或者其他方式来切换服务提供者\",{\"1\":{\"9\":1}}],[\"可以通过将实现类标记为spring组件\",{\"1\":{\"9\":1}}],[\"可以根据这个类名进行加载实例化\",{\"1\":{\"7\":1}}],[\"可以用来启用框架扩展和替换组件\",{\"1\":{\"7\":1}}],[\"可以很方便地对目标类进行功能增强\",{\"1\":{\"4\":1}}],[\"并配置了以下重试策略\",{\"1\":{\"126\":1}}],[\"并执行重试操作\",{\"1\":{\"124\":1}}],[\"并手动重试\",{\"1\":{\"121\":1}}],[\"并使用服务实例的地址和虚拟节点编号计算出哈希值\",{\"1\":{\"116\":1}}],[\"并清空\",{\"1\":{\"108\":1}}],[\"并通过\",{\"1\":{\"102\":1}}],[\"并通知相关的服务消费者\",{\"1\":{\"74\":1}}],[\"并设置重试次数限制\",{\"1\":{\"122\":1}}],[\"并设置\",{\"1\":{\"108\":1}}],[\"并设置其固定长度为\",{\"1\":{\"108\":1}}],[\"并设置响应状态为成功\",{\"1\":{\"102\":1}}],[\"并设置过期时间\",{\"1\":{\"83\":1}}],[\"并根据其中的服务名称和方法名\",{\"1\":{\"102\":1}}],[\"并创建\",{\"1\":{\"102\":1}}],[\"并帮助设置容器的覆盖网络\",{\"1\":{\"76\":1}}],[\"并及时更新注册信息\",{\"1\":{\"72\":1}}],[\"并显式地注册它们\",{\"1\":{\"49\":1}}],[\"并增强安全性\",{\"1\":{\"49\":1}}],[\"并行调用\",{\"1\":{\"34\":1}}],[\"并传入\",{\"1\":{\"29\":1}}],[\"并缓存起来\",{\"1\":{\"10\":1}}],[\"并将索引值加\",{\"1\":{\"115\":1}}],[\"并将解析后的完整消息传递给外部处理器进行处理\",{\"1\":{\"108\":1}}],[\"并将故障节点或服务隔离\",{\"1\":{\"32\":1}}],[\"并将具体的网络通信细节委托给了\",{\"1\":{\"29\":1}}],[\"并将其传递给外部处理器进行处理\",{\"1\":{\"108\":1}}],[\"并将其各个字段写入到一个新创建的\",{\"1\":{\"98\":1}}],[\"并将其转换为java对象\",{\"1\":{\"24\":1}}],[\"并将其存储在\",{\"1\":{\"10\":1}}],[\"并将结果转换回客户端期望的格式\",{\"1\":{\"2\":1}}],[\"并不会创建该类的实例\",{\"1\":{\"10\":1}}],[\"并不会实例化这个类的对象\",{\"1\":{\"10\":1}}],[\"并且允许用户配置可重试异常的白名单\",{\"1\":{\"121\":1}}],[\"并且记录请求的重试次数\",{\"1\":{\"120\":1}}],[\"并且对外提供唯一的\",{\"1\":{\"111\":1}}],[\"并且可以轻松获取这些选项\",{\"1\":{\"25\":1}}],[\"并且初始化rpc框架\",{\"1\":{\"18\":1}}],[\"并且无法在运行时动态替换\",{\"1\":{\"9\":1}}],[\"并且不需要修改目标类的代码\",{\"1\":{\"4\":1}}],[\"并在classpath下的meta\",{\"1\":{\"9\":1}}],[\"并在内部调用目标类的方法\",{\"1\":{\"3\":1}}],[\"并添加进相应的实现类内容就好\",{\"1\":{\"8\":1}}],[\"并返回最终的调用结果\",{\"1\":{\"126\":1}}],[\"并返回一个合适的响应结果\",{\"1\":{\"37\":1}}],[\"并返回一个\",{\"1\":{\"37\":1}}],[\"并返回\",{\"1\":{\"5\":1,\"48\":1}}],[\"并返回给客户端\",{\"1\":{\"4\":1}}],[\"而\",{\"1\":{\"127\":2}}],[\"而在一个对可用性要求更高的系统中\",{\"1\":{\"122\":1}}],[\"而byte占1个字节\",{\"1\":{\"94\":1}}],[\"而且在个别服务器发生故障时也能正常工作\",{\"1\":{\"76\":1}}],[\"而是直接返回一个默认的响应结果\",{\"1\":{\"39\":1}}],[\"而是在运行时根据需要动态生成代理类的字节码\",{\"1\":{\"4\":1}}],[\"而对于业务异常可能需要降级或返回默认响应\",{\"1\":{\"37\":1}}],[\"而java原生的spi机制只能在启动时加载一次服务提供者\",{\"1\":{\"9\":1}}],[\"而java原生的spi机制只支持单个实现类\",{\"1\":{\"9\":1}}],[\"而java的spi机制可以为某个接口寻找服务实现\",{\"1\":{\"7\":1}}],[\"而具体的数据库厂商则需要实现这个接口\",{\"1\":{\"9\":1}}],[\"而不是简单的linkedhashmap\",{\"1\":{\"48\":1}}],[\"而不是原来的对象类型\",{\"1\":{\"48\":2}}],[\"而不是强制使用框架中的硬编码配置\",{\"1\":{\"24\":1}}],[\"而不是猫\",{\"1\":{\"8\":1}}],[\"而不需要修改代码\",{\"1\":{\"9\":1}}],[\"而不需要依赖具体的代理实现\",{\"1\":{\"5\":1}}],[\"而不需要直接依赖远程服务的接口定义\",{\"1\":{\"2\":1}}],[\"而不需要关心远程服务的地址\",{\"1\":{\"2\":1}}],[\"而代理对象会负责完成各种中间件功能\",{\"1\":{\"2\":1}}],[\"这使得我们可以更好地处理任务执行过程中的异常情况\",{\"1\":{\"127\":1}}],[\"这使得在应用程序中使用spring的spi机制更加灵活和可扩展\",{\"1\":{\"9\":1}}],[\"这会增加调用端代码的复杂度\",{\"1\":{\"121\":1}}],[\"这可以避免无限重试导致资源耗尽的问题\",{\"1\":{\"126\":1}}],[\"这可以进一步提高系统的稳定性和可靠性\",{\"1\":{\"121\":1}}],[\"这可以平衡各个实例的负载\",{\"1\":{\"112\":1}}],[\"这可以降低系统维护的人力和时间成本\",{\"1\":{\"33\":1}}],[\"这在某些场景下可能比较麻烦\",{\"1\":{\"49\":1}}],[\"这在一定程度上简化了应用程序中服务提供者的配置和管理\",{\"1\":{\"9\":1}}],[\"这段代码中引入了handlerequest方法\",{\"1\":{\"48\":1}}],[\"这段代码中引入了handleresponse方法\",{\"1\":{\"48\":1}}],[\"这段代码体现了动态代理的核心思想\",{\"1\":{\"4\":1}}],[\"这意味着你可以序列化\",{\"1\":{\"49\":1}}],[\"这意味着\",{\"1\":{\"48\":1,\"127\":1}}],[\"这对于许多关键性的分布式应用来说是非常必要的\",{\"1\":{\"33\":1}}],[\"这行代码获取当前\",{\"1\":{\"20\":1}}],[\"这些重试策略各有适用场景\",{\"1\":{\"122\":1}}],[\"这些字段包括\",{\"1\":{\"98\":1}}],[\"这些功能可以帮助开发者实现更细粒度的服务管控\",{\"1\":{\"74\":1}}],[\"这些功能都是在动态代理层面实现的\",{\"1\":{\"4\":1}}],[\"这些功能都是在客户端感知不到的情况下完成的\",{\"1\":{\"2\":1}}],[\"这些元数据信息可以帮助服务消费者做更精细的服务选择和调用\",{\"1\":{\"74\":1}}],[\"这些嵌套的json也会被转换为嵌套的java对象和java集合\",{\"1\":{\"48\":1}}],[\"这些嵌套对象也会被转换为嵌套的json对象和json数组\",{\"1\":{\"48\":1}}],[\"这些信息可以在日志\",{\"1\":{\"25\":1}}],[\"这些信息可以在后续的服务发现和调用过程中使用\",{\"1\":{\"15\":1}}],[\"这是最基础的负载均衡算法\",{\"1\":{\"112\":1}}],[\"这是我们后端开发比较经常接触的均衡器\",{\"1\":{\"111\":1}}],[\"这是我们解决半包粘包问题的基础\",{\"1\":{\"108\":1}}],[\"这是因为\",{\"1\":{\"43\":1}}],[\"这是\",{\"1\":{\"14\":1,\"15\":3,\"16\":7,\"25\":2}}],[\"这是一个自定义注解的声明\",{\"1\":{\"14\":1}}],[\"这种线性重试策略适用于网络环境相对较为稳定的场景\",{\"1\":{\"128\":1}}],[\"这种指数退避重试策略可以有效应对网络抖动和服务短暂不可用的情况\",{\"1\":{\"127\":1}}],[\"这种方式适用于对响应时间要求较高的场景\",{\"1\":{\"122\":1}}],[\"这种方式更加灵活\",{\"1\":{\"49\":1}}],[\"这种方式更灵活\",{\"1\":{\"49\":1}}],[\"这种操作就非常浪费性能\",{\"1\":{\"117\":1}}],[\"这种一致性哈希算法的优点包括\",{\"1\":{\"116\":1}}],[\"这种特殊处理是因为java泛型擦除带来的限制而产生的\",{\"1\":{\"48\":1}}],[\"这种策略和故障恢复差不多\",{\"1\":{\"41\":1}}],[\"这种策略可以提高服务的可用性\",{\"1\":{\"34\":1}}],[\"这种策略可以提高服务的可靠性\",{\"1\":{\"34\":1}}],[\"这种策略通常与failover一起使用\",{\"1\":{\"34\":1}}],[\"这种策略适用于对响应时间要求不太严格的场景\",{\"1\":{\"126\":1}}],[\"这种策略适用于对响应时间敏感的场景\",{\"1\":{\"34\":1}}],[\"这种策略适用于对最终结果不太敏感的场景\",{\"1\":{\"39\":1}}],[\"这种策略适用于一些对结果容忍度较高的场景\",{\"1\":{\"34\":1}}],[\"这种能力对于构建高可用\",{\"1\":{\"32\":1}}],[\"这种设计模式能够确保整个\",{\"1\":{\"26\":1}}],[\"这种设计可以让\",{\"1\":{\"18\":1}}],[\"这种分离加载和实例化的设计\",{\"1\":{\"10\":1}}],[\"这种代理工厂的设计模式可以很好地封装动态代理的创建逻辑\",{\"1\":{\"5\":1}}],[\"这里使用juc包下的atomicinteger实现原子\",{\"1\":{\"115\":1}}],[\"这里我们使用了设计模式中的装饰者模式\",{\"1\":{\"108\":1}}],[\"这里是不需要启动服务器\",{\"1\":{\"65\":1}}],[\"这里需要特殊处理\",{\"1\":{\"48\":2}}],[\"这里\",{\"1\":{\"10\":1}}],[\"这里的loadermap是存放\",{\"1\":{\"10\":1}}],[\"这就是spi的思想\",{\"1\":{\"8\":1}}],[\"这有点类似\",{\"1\":{\"7\":1}}],[\"这个实现与之前的指数退避重试策略非常相似\",{\"1\":{\"128\":1}}],[\"这个重试策略的特点如下\",{\"1\":{\"126\":1}}],[\"这个加权轮询算法的核心思想是\",{\"1\":{\"117\":1}}],[\"这个有序\",{\"1\":{\"116\":1}}],[\"这个数据就是消息体的长度\",{\"1\":{\"108\":1}}],[\"这个类中的某些功能需要使用到远程调用的功能\",{\"1\":{\"61\":1}}],[\"这个问题的关键在于\",{\"1\":{\"48\":1}}],[\"这个时候触发容错策略\",{\"1\":{\"40\":1}}],[\"这个方法定义了容错处理的具体实现\",{\"1\":{\"37\":1}}],[\"这个参数表示在执行远程调用时出现的异常\",{\"1\":{\"37\":1}}],[\"这个参数是一个上下文对象\",{\"1\":{\"37\":1}}],[\"这个上下文可以包含一些关键信息\",{\"1\":{\"37\":1}}],[\"这个引导程序的设计目的是将\",{\"1\":{\"29\":1}}],[\"这个属性指定了服务的接口类\",{\"1\":{\"19\":1}}],[\"这个元注解将\",{\"1\":{\"15\":1}}],[\"这个元注解指定了\",{\"1\":{\"15\":2,\"16\":2}}],[\"这个注解用于导入其他配置类\",{\"1\":{\"14\":1}}],[\"这个注解用于指定\",{\"1\":{\"14\":2}}],[\"这个插件的主要作用是用户在写yml的时候可以有注释\",{\"1\":{\"12\":1}}],[\"这个文件是接口全限定名的文件\",{\"1\":{\"8\":1}}],[\"这个文件里的内容就是这个接口的具体的实现类\",{\"1\":{\"7\":1}}],[\"这个\",{\"1\":{\"4\":1,\"5\":1,\"10\":1,\"14\":1,\"16\":1,\"18\":1,\"25\":1,\"26\":1,\"37\":1,\"108\":1,\"127\":1}}],[\"这样每次重试时\",{\"1\":{\"128\":1}}],[\"这样才能考虑是否使用重试\",{\"1\":{\"121\":1}}],[\"这样也可以做到a\",{\"1\":{\"118\":1}}],[\"这样如果服务提供者宕机了\",{\"1\":{\"83\":1}}],[\"这样做的目的是\",{\"1\":{\"48\":1}}],[\"这样在后续的\",{\"1\":{\"19\":1}}],[\"这样可以让rpc框架的异常重试功能变得更加友好\",{\"1\":{\"121\":1}}],[\"这样可以提高重试的成功率\",{\"1\":{\"121\":1}}],[\"这样可以提高序列化\",{\"1\":{\"49\":1}}],[\"这样可以更省内存\",{\"1\":{\"94\":1}}],[\"这样可以最大程度地减少服务中断的时间\",{\"1\":{\"34\":1}}],[\"这样可以在某个节点出现问题时\",{\"1\":{\"34\":1}}],[\"这样可以做到不修改客户端代码的情况下\",{\"1\":{\"4\":1}}],[\"这样可以降低客户端与服务端的耦合度\",{\"1\":{\"2\":1}}],[\"这样客户端可以无感知地调用远程服务\",{\"1\":{\"2\":1}}],[\"抽象客户端与服务端的耦合\",{\"1\":{\"2\":1}}],[\"熔断等\",{\"1\":{\"25\":1}}],[\"熔断保护等\",{\"1\":{\"4\":1}}],[\"熔断\",{\"1\":{\"2\":1,\"36\":1}}],[\"序列化消息的类型不存在\",{\"1\":{\"99\":1}}],[\"序列化消息的协议不存在\",{\"1\":{\"99\":1}}],[\"序列化为字节数组\",{\"1\":{\"48\":1}}],[\"序列化将java对象转换为字节数组\",{\"1\":{\"47\":1}}],[\"序列化异常\",{\"1\":{\"46\":1}}],[\"序列化接口\",{\"1\":{\"46\":1}}],[\"序列化结果大\",{\"1\":{\"44\":1}}],[\"序列化结果大小较大\",{\"1\":{\"44\":2}}],[\"序列化协议\",{\"1\":{\"44\":1}}],[\"序列化数据不可读\",{\"1\":{\"44\":1}}],[\"序列化后的字节数组\",{\"1\":{\"46\":1}}],[\"序列化后数据冗长\",{\"1\":{\"44\":1}}],[\"序列化后体积小\",{\"1\":{\"44\":3}}],[\"序列化格式复杂\",{\"1\":{\"44\":1}}],[\"序列化\",{\"1\":{\"43\":2,\"46\":1,\"129\":1}}],[\"序列化器实现\",{\"0\":{\"42\":1}}],[\"序列化器\",{\"1\":{\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"96\":1}}],[\"序列化配置\",{\"1\":{\"25\":1}}],[\"序列化方式\",{\"1\":{\"24\":1,\"94\":1}}],[\"序列化方式解决方案\",{\"1\":{\"0\":1}}],[\"序列化等细节\",{\"1\":{\"2\":1}}],[\"隐藏远程调用细节\",{\"1\":{\"2\":1}}],[\"它能够提供一个平滑的重试过程\",{\"1\":{\"128\":1}}],[\"它会逐步增加重试间隔\",{\"1\":{\"127\":1}}],[\"它接收一个\",{\"1\":{\"126\":1}}],[\"它接收上下文信息和异常对象作为参数\",{\"1\":{\"37\":1}}],[\"它指的是将请求流量合理地分配到多个服务提供者实例上\",{\"1\":{\"110\":1}}],[\"它包含一个名为\",{\"1\":{\"127\":1}}],[\"它包含了\",{\"1\":{\"25\":1}}],[\"它包括了\",{\"1\":{\"90\":1}}],[\"它和我们的序列化器一样\",{\"1\":{\"79\":1}}],[\"它是\",{\"1\":{\"76\":1}}],[\"它是基于\",{\"1\":{\"29\":1}}],[\"它可以保证下次读取到特定长度的字符\",{\"1\":{\"108\":1}}],[\"它可以显著提高系统的抗风险能力\",{\"1\":{\"33\":1}}],[\"它可以帮助开发者快速地在自己的应用程序中集成\",{\"1\":{\"14\":1}}],[\"它可以帮助客户端屏蔽掉远程调用的细节\",{\"1\":{\"2\":1}}],[\"它的工作原理如下\",{\"1\":{\"116\":1}}],[\"它的实现很简单\",{\"1\":{\"85\":1}}],[\"它的可靠性和性能对整个分布式系统的可用性都有重要影响\",{\"1\":{\"73\":1}}],[\"它的主要功能如下\",{\"1\":{\"108\":1}}],[\"它的主要作用包括以下几点\",{\"1\":{\"72\":1}}],[\"它的主要作用是在\",{\"1\":{\"20\":1}}],[\"它的主要目的是为了在实际服务还未就绪的情况下\",{\"1\":{\"68\":1}}],[\"它的作用是\",{\"1\":{\"48\":1}}],[\"它的目的是在服务出现故障时\",{\"1\":{\"40\":1}}],[\"它的目标是在部分组件或节点出现故障时\",{\"1\":{\"32\":1}}],[\"它处理了服务注册\",{\"1\":{\"29\":1}}],[\"它负责管理全局的\",{\"1\":{\"26\":1}}],[\"它同样实现了\",{\"1\":{\"20\":1}}],[\"它利用\",{\"1\":{\"18\":1}}],[\"它用于指定是否需要启动\",{\"1\":{\"14\":1}}],[\"它导入了三个引导类\",{\"1\":{\"14\":1}}],[\"它被限定为只能应用于类型\",{\"1\":{\"14\":1}}],[\"它也体现了面向接口编程的设计思想\",{\"1\":{\"5\":1}}],[\"它定义了客户端与服务器之间请求和响应的格式\",{\"1\":{\"90\":1}}],[\"它定义了这个注解的名称和作用域\",{\"1\":{\"15\":1,\"16\":1}}],[\"它定义了\",{\"1\":{\"4\":1}}],[\"它为一个对象提供一个替身\",{\"1\":{\"2\":1}}],[\"中查找最接近且大于该哈希值的虚拟节点\",{\"1\":{\"116\":1}}],[\"中获取\",{\"1\":{\"102\":1}}],[\"中实现了以下逻辑\",{\"1\":{\"102\":1}}],[\"中的\",{\"1\":{\"98\":1}}],[\"中的配置文件\",{\"1\":{\"7\":1}}],[\"中间描述型\",{\"1\":{\"44\":1}}],[\"中定义的快速失败\",{\"1\":{\"25\":1}}],[\"中定义的不重试\",{\"1\":{\"25\":1}}],[\"中定义的不同策略\",{\"1\":{\"25\":1}}],[\"中定义的不同序列化方式\",{\"1\":{\"25\":1}}],[\"中是否有被\",{\"1\":{\"20\":1}}],[\"中常见的动态代理实现方式有\",{\"1\":{\"4\":1}}],[\"中\",{\"1\":{\"2\":2,\"10\":1,\"29\":1,\"102\":1,\"116\":1,\"127\":2}}],[\"远程过程调用协议\",{\"1\":{\"90\":1}}],[\"远程过程调用\",{\"1\":{\"2\":1}}],[\"在我们的\",{\"1\":{\"127\":1}}],[\"在方法中\",{\"1\":{\"126\":1}}],[\"在一个对响应时间要求较高的\",{\"1\":{\"122\":1}}],[\"在一定范围内波动\",{\"1\":{\"122\":1}}],[\"在实际的\",{\"1\":{\"122\":1}}],[\"在使用rpc框架的重试机制时\",{\"1\":{\"121\":1}}],[\"在发起重试\",{\"1\":{\"121\":1}}],[\"在每次重试时\",{\"1\":{\"127\":1,\"128\":1}}],[\"在每次重试时打印当前重试次数\",{\"1\":{\"126\":1}}],[\"在每次触发重试之前\",{\"1\":{\"121\":1}}],[\"在每次发起\",{\"1\":{\"110\":1}}],[\"在重试的过程中\",{\"1\":{\"121\":1}}],[\"在系统启动初期\",{\"1\":{\"116\":1}}],[\"在tcpserverhandler进行增强\",{\"1\":{\"108\":1}}],[\"在初始化设置为这样就是为了读取整个消息头的内容\",{\"1\":{\"108\":1}}],[\"在构造函数中初始化一个\",{\"1\":{\"108\":1}}],[\"在vertxtcpclient进行增强\",{\"1\":{\"108\":1}}],[\"在vert\",{\"1\":{\"108\":1}}],[\"在上面已经有了\",{\"1\":{\"103\":1}}],[\"在消息解码的时候\",{\"1\":{\"99\":1}}],[\"在消费者模块\",{\"1\":{\"64\":1}}],[\"在消费者注入的类上加\",{\"1\":{\"11\":1}}],[\"在后续实现消息编码器和消息解码器的时候\",{\"1\":{\"94\":1}}],[\"在网络中它与tcp协议一样用于处理数据包\",{\"1\":{\"90\":1}}],[\"在本章节中\",{\"1\":{\"75\":1}}],[\"在本rpc框架中\",{\"1\":{\"25\":1}}],[\"在注册中心宕机时仍能保证服务调用\",{\"1\":{\"74\":1}}],[\"在创建调用方法的时候返回固定值对象即可\",{\"1\":{\"70\":1}}],[\"在保证开发者使用体验的前提下\",{\"1\":{\"69\":1}}],[\"在侧重数据展示类需求的项目中这种问题更加严重\",{\"1\":{\"69\":1}}],[\"在新项目启动后\",{\"1\":{\"69\":1}}],[\"在微服务场景下\",{\"1\":{\"69\":1}}],[\"在传统前后端分离开发的场景下\",{\"1\":{\"69\":1}}],[\"在服务端接收的时候\",{\"1\":{\"107\":1}}],[\"在服务消费者上加enableyunrpc\",{\"1\":{\"65\":1}}],[\"在服务提供者上加enableyunrpc注解\",{\"1\":{\"65\":1}}],[\"在服务提供者\",{\"1\":{\"63\":1}}],[\"在provider模块我们实现了这个接口的功能\",{\"1\":{\"60\":1}}],[\"在处理rpcrequest对象时\",{\"1\":{\"48\":1}}],[\"在反序列化时\",{\"1\":{\"48\":1}}],[\"在json反序列化过程中\",{\"1\":{\"48\":1}}],[\"在json序列化过程中\",{\"1\":{\"48\":1}}],[\"在java中\",{\"1\":{\"9\":1,\"48\":1}}],[\"在java\",{\"1\":{\"9\":1}}],[\"在分布式系统中\",{\"1\":{\"37\":1}}],[\"在分布式环境下\",{\"1\":{\"33\":1}}],[\"在dubbo的文档中也介绍了这些容错策略\",{\"1\":{\"34\":1}}],[\"在dubbo中\",{\"1\":{\"11\":1}}],[\"在开发早期发现问题\",{\"1\":{\"69\":1}}],[\"在开发\",{\"1\":{\"24\":1}}],[\"在这段代码中\",{\"1\":{\"48\":1,\"108\":1}}],[\"在这里\",{\"1\":{\"14\":2}}],[\"在这个方法中\",{\"1\":{\"4\":1}}],[\"在提供方类上加\",{\"1\":{\"11\":1}}],[\"在启动类上加\",{\"1\":{\"11\":1}}],[\"在配置文件中编写我们之前实现的类\",{\"1\":{\"10\":1}}],[\"在模块化设计中这个机制尤其重要\",{\"1\":{\"7\":1}}],[\"在代理层面封装并处理\",{\"1\":{\"4\":1}}],[\"在consumer模块\",{\"1\":{\"61\":1}}],[\"在consumer模块里面\",{\"1\":{\"3\":1}}],[\"在common模块我们定义了一个getuser的接口\",{\"1\":{\"59\":1}}],[\"在common模块里面\",{\"1\":{\"3\":1}}],[\"在\",{\"1\":{\"2\":3,\"4\":2,\"10\":1,\"26\":1,\"102\":1,\"110\":1,\"116\":1,\"122\":1,\"127\":3}}],[\"zookeeper\",{\"1\":{\"73\":1,\"130\":1}}],[\"zkummft0nweavba2mjijfa\",{\"1\":{\"0\":1}}],[\"zhizhengguan\",{\"1\":{\"121\":1}}],[\"zh\",{\"1\":{\"0\":1,\"25\":1,\"34\":1,\"44\":1}}],[\"||\",{\"1\":{\"40\":1,\"41\":1,\"98\":1,\"118\":1}}],[\"|\",{\"1\":{\"0\":1,\"10\":2}}],[\"剖析\",{\"1\":{\"0\":1}}],[\"服务可以尝试使用netty进行通信\",{\"1\":{\"130\":1}}],[\"服务列表\",{\"1\":{\"113\":1,\"116\":1}}],[\"服务调用者都会通过配置的负载均衡插件\",{\"1\":{\"110\":1}}],[\"服务监听\",{\"0\":{\"88\":1}}],[\"服务下线分为\",{\"1\":{\"86\":1}}],[\"服务缓存\",{\"1\":{\"85\":1}}],[\"服务取消注册\",{\"0\":{\"84\":1}}],[\"服务销毁\",{\"0\":{\"86\":1},\"1\":{\"79\":1}}],[\"服务分组\",{\"1\":{\"77\":1}}],[\"服务地址\",{\"1\":{\"77\":1}}],[\"服务元信息\",{\"1\":{\"77\":1}}],[\"服务元信息设计\",{\"0\":{\"77\":1}}],[\"服务元数据管理\",{\"1\":{\"74\":1}}],[\"服务剔除\",{\"1\":{\"74\":1}}],[\"服务权重\",{\"1\":{\"74\":1,\"77\":1}}],[\"服务健康检查\",{\"1\":{\"74\":1}}],[\"服务治理能力\",{\"1\":{\"74\":1}}],[\"服务治理\",{\"1\":{\"72\":1}}],[\"服务状态管理\",{\"1\":{\"72\":1}}],[\"服务发现失败\",{\"1\":{\"85\":1}}],[\"服务发现和的调度协调\",{\"1\":{\"76\":1}}],[\"服务发现等功能\",{\"1\":{\"73\":1}}],[\"服务发现\",{\"0\":{\"85\":1},\"1\":{\"72\":1,\"74\":1,\"79\":2}}],[\"服务代理\",{\"1\":{\"70\":1}}],[\"服务还主要有以下几个原因\",{\"1\":{\"69\":1}}],[\"服务是一种用于模拟接口行为的技术\",{\"1\":{\"68\":1}}],[\"服务上加yunrpcreference\",{\"1\":{\"64\":1}}],[\"服务实例的元数据\",{\"1\":{\"37\":1}}],[\"服务实现类\",{\"1\":{\"29\":1}}],[\"服务降级和业务兜底\",{\"1\":{\"32\":1}}],[\"服务名\",{\"1\":{\"29\":1}}],[\"服务名称\",{\"1\":{\"29\":1,\"77\":1}}],[\"服务注册中心可以实现redis\",{\"1\":{\"130\":1}}],[\"服务注册主要就是把键值对保存到etcd中\",{\"1\":{\"83\":1}}],[\"服务注册和发现\",{\"1\":{\"74\":1}}],[\"服务注册\",{\"0\":{\"83\":1},\"1\":{\"29\":1,\"72\":1,\"74\":1,\"79\":1}}],[\"服务启动的时候\",{\"1\":{\"29\":1}}],[\"服务器部署需要开放特定端口\",{\"1\":{\"44\":1}}],[\"服务器故障等\",{\"1\":{\"33\":1}}],[\"服务器端口\",{\"1\":{\"26\":1}}],[\"服务器主机\",{\"1\":{\"26\":1}}],[\"服务器的主机和端口信息\",{\"1\":{\"25\":1}}],[\"服务器配置\",{\"1\":{\"25\":1}}],[\"服务消费者\",{\"0\":{\"103\":1}}],[\"服务消费者通过注册中心查找并调用可用的服务提供者\",{\"1\":{\"74\":1}}],[\"服务消费者在需要调用服务时\",{\"1\":{\"72\":1}}],[\"服务消费者初始化启动\",{\"1\":{\"30\":1}}],[\"服务消费者启动类\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"服务消费者的配置\",{\"1\":{\"16\":1}}],[\"服务消费者的引导类\",{\"1\":{\"14\":1,\"20\":1}}],[\"服务消费者端的注解\",{\"1\":{\"16\":1}}],[\"服务版本号\",{\"1\":{\"77\":1}}],[\"服务版本管理等功能\",{\"1\":{\"72\":1}}],[\"服务版本\",{\"1\":{\"15\":1,\"16\":1}}],[\"服务接口类\",{\"1\":{\"15\":1,\"16\":1}}],[\"服务端处理器\",{\"1\":{\"102\":1}}],[\"服务端初始化逻辑\",{\"1\":{\"29\":1}}],[\"服务端的初始化和启动过程集中在一个入口类中\",{\"1\":{\"29\":1}}],[\"服务端\",{\"1\":{\"14\":2,\"18\":1,\"29\":3,\"79\":2}}],[\"服务提供方就能正确从二进制数据中分割出不同请求\",{\"1\":{\"43\":1}}],[\"服务提供者把服务的信息放到注册中心中\",{\"1\":{\"72\":1}}],[\"服务提供者在启动时将自身信息注册到注册中心\",{\"1\":{\"74\":1}}],[\"服务提供者在启动时\",{\"1\":{\"72\":1}}],[\"服务提供者初始化启动\",{\"1\":{\"29\":1}}],[\"服务提供者启动类\",{\"0\":{\"29\":1}}],[\"服务提供者和消费者需要初始化的模块是不同\",{\"1\":{\"28\":1}}],[\"服务提供者和服务消费者需要使用相同的\",{\"1\":{\"24\":1}}],[\"服务提供者端的必要配置\",{\"1\":{\"25\":1}}],[\"服务提供者的配置\",{\"1\":{\"15\":1}}],[\"服务提供者的引导类\",{\"1\":{\"14\":1}}],[\"服务提供者\",{\"0\":{\"102\":1},\"1\":{\"15\":1}}],[\"服务提供者也要提前把对应的实现类进行注册\",{\"1\":{\"3\":1}}],[\"服务提供发现机制\",{\"1\":{\"7\":1}}],[\"服务的元信息servicemetainfo\",{\"1\":{\"83\":1}}],[\"服务的代理对象\",{\"1\":{\"5\":1}}],[\"服务的实现方案\",{\"1\":{\"0\":1}}],[\"服务容错\",{\"1\":{\"0\":1}}],[\"手写rpc框架\",{\"1\":{\"0\":1}}],[\"详解\",{\"1\":{\"0\":1}}],[\"rholder<\",{\"1\":{\"124\":1}}],[\"randomloadbalancer\",{\"1\":{\"114\":1}}],[\"random\",{\"1\":{\"112\":1,\"114\":4,\"122\":1}}],[\"runnable\",{\"1\":{\"127\":2}}],[\"run\",{\"1\":{\"65\":2,\"127\":1}}],[\"runtimeschema\",{\"1\":{\"51\":2}}],[\"runtime<\",{\"1\":{\"51\":1}}],[\"runtime\",{\"1\":{\"14\":3,\"15\":2,\"16\":2,\"21\":1,\"26\":1,\"51\":1,\"86\":1}}],[\"runtimeexception\",{\"1\":{\"4\":1,\"10\":4,\"19\":1,\"20\":1,\"29\":1,\"38\":1,\"40\":1,\"41\":1,\"85\":1,\"86\":1,\"87\":1,\"98\":1,\"99\":3,\"101\":2,\"102\":2,\"103\":1}}],[\"root\",{\"1\":{\"81\":1,\"83\":2,\"84\":1,\"85\":1}}],[\"robin\",{\"1\":{\"16\":3,\"26\":1,\"112\":2}}],[\"roundrobinloadbalancer\",{\"1\":{\"115\":1}}],[\"round\",{\"1\":{\"16\":3,\"26\":1,\"112\":2}}],[\"recordparser\",{\"1\":{\"108\":15}}],[\"received\",{\"1\":{\"60\":1,\"63\":1,\"101\":2}}],[\"remote\",{\"1\":{\"90\":1}}],[\"remove\",{\"1\":{\"84\":1}}],[\"redis中很多数据结构都是这样设计的如\",{\"1\":{\"94\":1}}],[\"redis\",{\"1\":{\"79\":1}}],[\"readcache\",{\"1\":{\"85\":2}}],[\"readvalue\",{\"1\":{\"48\":4}}],[\"readobject\",{\"1\":{\"47\":1,\"49\":1,\"50\":1}}],[\"readline\",{\"1\":{\"10\":2}}],[\"reference\",{\"1\":{\"25\":1,\"44\":1}}],[\"reflect\",{\"1\":{\"4\":1}}],[\"requestid\",{\"1\":{\"96\":1,\"98\":1}}],[\"request\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"99\":3,\"101\":1,\"103\":1}}],[\"requestparams\",{\"1\":{\"4\":3,\"103\":3,\"113\":2,\"114\":1,\"115\":1,\"116\":3,\"117\":2,\"118\":1}}],[\"reset\",{\"1\":{\"127\":1,\"128\":1}}],[\"rest\",{\"1\":{\"91\":1}}],[\"res\",{\"1\":{\"49\":2,\"100\":2,\"101\":7,\"103\":1,\"108\":1}}],[\"resources\",{\"1\":{\"10\":2}}],[\"resourceutil\",{\"1\":{\"10\":2}}],[\"resource\",{\"1\":{\"10\":4,\"26\":1,\"66\":1}}],[\"responseprotocolmessage\",{\"1\":{\"101\":2,\"102\":2,\"103\":1}}],[\"responsefuture\",{\"1\":{\"101\":3,\"103\":3}}],[\"response\",{\"1\":{\"4\":4,\"40\":4,\"88\":2,\"99\":3,\"101\":2,\"102\":1,\"103\":4}}],[\"resultbuffer\",{\"1\":{\"108\":12}}],[\"resultuser\",{\"1\":{\"61\":2,\"64\":2}}],[\"result\",{\"1\":{\"3\":3,\"101\":2,\"102\":2,\"118\":1,\"127\":3}}],[\"registryservicecache\",{\"1\":{\"81\":3,\"85\":3,\"88\":1}}],[\"registrykeys\",{\"1\":{\"78\":2}}],[\"registryconfig\",{\"1\":{\"19\":3,\"25\":1,\"26\":9,\"29\":3,\"78\":1,\"79\":3,\"82\":4,\"86\":5}}],[\"registryfactory\",{\"1\":{\"4\":1,\"19\":1,\"26\":1,\"29\":1,\"86\":1,\"103\":1}}],[\"registry\",{\"1\":{\"4\":3,\"18\":2,\"19\":3,\"26\":5,\"29\":5,\"72\":1,\"78\":2,\"79\":1,\"86\":5,\"103\":3}}],[\"registerkey\",{\"1\":{\"83\":3,\"84\":3}}],[\"registerbeandefinitions\",{\"1\":{\"18\":1}}],[\"register\",{\"1\":{\"3\":1,\"19\":3,\"29\":3,\"79\":1,\"83\":1,\"87\":1}}],[\"retentionpolicy\",{\"1\":{\"14\":2,\"15\":2,\"16\":2,\"21\":1}}],[\"retention\",{\"1\":{\"14\":2,\"15\":2,\"16\":2,\"21\":1}}],[\"returntype\",{\"1\":{\"70\":2}}],[\"return\",{\"1\":{\"3\":3,\"4\":2,\"5\":5,\"10\":5,\"14\":1,\"15\":2,\"16\":6,\"19\":1,\"20\":2,\"21\":1,\"26\":21,\"37\":1,\"38\":1,\"39\":2,\"40\":6,\"41\":4,\"46\":2,\"47\":2,\"48\":8,\"49\":3,\"50\":2,\"51\":3,\"59\":1,\"60\":1,\"63\":1,\"70\":2,\"77\":4,\"79\":1,\"85\":4,\"98\":2,\"99\":2,\"101\":2,\"103\":2,\"108\":1,\"113\":1,\"114\":3,\"115\":3,\"116\":5,\"117\":3,\"118\":1,\"124\":1,\"125\":2,\"126\":2,\"127\":2,\"128\":1}}],[\"retrytimes++\",{\"1\":{\"127\":1,\"128\":1}}],[\"retrytimes\",{\"1\":{\"127\":4,\"128\":3}}],[\"retrylistener\",{\"1\":{\"126\":2}}],[\"retryifexceptionoftype\",{\"1\":{\"126\":2}}],[\"retrying\",{\"1\":{\"127\":1,\"128\":1}}],[\"retrying<\",{\"1\":{\"124\":1}}],[\"retrying库\",{\"1\":{\"124\":1}}],[\"retryerbuilder\",{\"1\":{\"126\":1}}],[\"retryer<rpcresponse>\",{\"1\":{\"126\":1}}],[\"retryer\",{\"1\":{\"126\":5}}],[\"retrystrategykeys\",{\"1\":{\"16\":3,\"25\":1,\"26\":1}}],[\"retrystrategyfactory\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"103\":1}}],[\"retrystrategy\",{\"1\":{\"4\":3,\"16\":2,\"25\":1,\"26\":1,\"40\":6,\"41\":3,\"103\":3,\"124\":2,\"125\":1,\"126\":2,\"127\":1,\"128\":1}}],[\"retry\",{\"1\":{\"0\":1,\"40\":2,\"41\":2,\"122\":7,\"127\":6,\"128\":5}}],[\"retry定制化你的rpc重试\",{\"1\":{\"0\":1}}],[\"rpc基本思路\",{\"1\":{\"129\":1}}],[\"rpc一些结构图介绍\",{\"0\":{\"129\":1}}],[\"rpc是一个完整的远程调用方案\",{\"1\":{\"90\":1}}],[\"rpc是一种调用过程的方案\",{\"1\":{\"90\":1}}],[\"rpc注册中心配置\",{\"1\":{\"78\":1}}],[\"rpc初始化\",{\"1\":{\"29\":1}}],[\"rpc框架结构\",{\"1\":{\"129\":1}}],[\"rpc框架会捕捉异常\",{\"1\":{\"121\":1}}],[\"rpc框架的重试机制\",{\"1\":{\"121\":1}}],[\"rpc框架自身可以进行重试\",{\"1\":{\"120\":1}}],[\"rpc框架如dubbo\",{\"1\":{\"111\":1}}],[\"rpc框架启动机制\",{\"0\":{\"27\":1}}],[\"rpc框架初始化\",{\"1\":{\"18\":1}}],[\"rpc应用\",{\"1\":{\"26\":1}}],[\"rpc配置\",{\"1\":{\"26\":1,\"129\":1}}],[\"rpcservice\",{\"1\":{\"19\":4}}],[\"rpcproviderbootstrap\",{\"1\":{\"14\":3,\"19\":1,\"21\":1}}],[\"rpcinitbootstrap\",{\"1\":{\"14\":3,\"18\":2,\"21\":1}}],[\"rpcconsumerbootstrap\",{\"1\":{\"14\":3,\"20\":2,\"21\":1}}],[\"rpcconstant\",{\"1\":{\"4\":1,\"15\":3,\"16\":3,\"26\":2,\"103\":1}}],[\"rpcconfigprops\",{\"1\":{\"26\":2}}],[\"rpcconfig类代码如下\",{\"1\":{\"26\":1}}],[\"rpcconfig\",{\"1\":{\"4\":6,\"18\":3,\"19\":5,\"25\":2,\"26\":27,\"29\":5,\"40\":2,\"86\":6,\"103\":6}}],[\"rpcapplication类\",{\"1\":{\"26\":1}}],[\"rpcapplication\",{\"1\":{\"4\":2,\"5\":1,\"18\":2,\"19\":1,\"26\":3,\"29\":4,\"30\":1,\"40\":1,\"41\":1,\"86\":1,\"101\":1,\"103\":2}}],[\"rpcreference\",{\"1\":{\"20\":5}}],[\"rpcresponse的data字段被声明为泛型类型t\",{\"1\":{\"48\":1}}],[\"rpcresponse\",{\"1\":{\"3\":4,\"4\":2,\"37\":3,\"38\":1,\"39\":6,\"40\":2,\"41\":1,\"48\":10,\"99\":2,\"101\":5,\"102\":11,\"103\":4,\"124\":2,\"125\":1,\"126\":2,\"127\":3,\"128\":1}}],[\"rpcrequest\",{\"1\":{\"3\":7,\"4\":8,\"40\":6,\"41\":4,\"48\":9,\"99\":2,\"101\":3,\"102\":7,\"103\":7}}],[\"rpc调用\",{\"0\":{\"1\":1}}],[\"rpc\",{\"1\":{\"0\":6,\"2\":3,\"4\":4,\"5\":3,\"8\":2,\"10\":13,\"12\":1,\"14\":9,\"15\":2,\"16\":3,\"18\":4,\"19\":1,\"20\":1,\"24\":6,\"25\":8,\"26\":8,\"29\":7,\"40\":2,\"41\":1,\"48\":2,\"51\":1,\"57\":2,\"69\":3,\"72\":1,\"73\":2,\"78\":2,\"81\":1,\"86\":1,\"90\":1,\"91\":2,\"94\":2,\"96\":1,\"103\":1,\"110\":6,\"120\":1,\"122\":3,\"127\":1,\"128\":1}}],[\"yml<\",{\"1\":{\"26\":1}}],[\"yml\",{\"1\":{\"26\":17}}],[\"yamlutil\",{\"1\":{\"26\":2}}],[\"yaml\",{\"1\":{\"26\":21}}],[\"yaml<\",{\"1\":{\"26\":1}}],[\"yunrpcreference\",{\"0\":{\"16\":1,\"64\":1},\"1\":{\"16\":13,\"20\":7,\"61\":1,\"64\":1}}],[\"yunrpcservice的注解的类\",{\"1\":{\"19\":1}}],[\"yunrpcservice\",{\"0\":{\"15\":1,\"63\":1},\"1\":{\"15\":10,\"19\":4,\"60\":1,\"63\":1}}],[\"yunfeirpc<\",{\"1\":{\"57\":1}}],[\"yunfei<\",{\"1\":{\"12\":1,\"57\":1}}],[\"yunfei\",{\"1\":{\"8\":2,\"10\":4,\"26\":2,\"48\":2,\"51\":1,\"61\":1,\"64\":1,\"78\":2,\"96\":1}}],[\"yu\",{\"1\":{\"0\":1}}],[\"yuan\",{\"1\":{\"0\":1}}],[\"youzan\",{\"1\":{\"0\":1}}],[\"min\",{\"1\":{\"127\":1,\"128\":1}}],[\"milliseconds\",{\"1\":{\"127\":1,\"128\":1}}],[\"ms\",{\"1\":{\"78\":1,\"127\":1,\"128\":1}}],[\"message\",{\"1\":{\"108\":5}}],[\"messagetypeenum\",{\"1\":{\"99\":3}}],[\"mergefrom\",{\"1\":{\"51\":1}}],[\"meta\",{\"1\":{\"10\":4}}],[\"metainfos\",{\"1\":{\"40\":5,\"41\":5}}],[\"metainfo\",{\"1\":{\"4\":3,\"40\":5,\"41\":3,\"101\":3,\"103\":6,\"108\":2}}],[\"method\",{\"1\":{\"4\":6,\"70\":3,\"102\":4,\"103\":6}}],[\"methodname\",{\"1\":{\"3\":2,\"4\":2,\"103\":2}}],[\"model\",{\"1\":{\"48\":2}}],[\"mocktest\",{\"1\":{\"70\":1}}],[\"mockdata\",{\"1\":{\"70\":4}}],[\"mock代理的具体实现\",{\"1\":{\"70\":1}}],[\"mock服务实现\",{\"0\":{\"70\":1}}],[\"mockserviceproxy\",{\"1\":{\"5\":3,\"70\":2}}],[\"mock\",{\"1\":{\"0\":3,\"5\":6,\"16\":3,\"25\":1,\"26\":1,\"68\":1,\"69\":6,\"70\":2}}],[\"mybatis框架中的插件机制也使用了spi思想\",{\"1\":{\"9\":1}}],[\"mybatis框架\",{\"1\":{\"9\":1}}],[\"mysql和postgresql都有不同的实现提供给用户\",{\"1\":{\"7\":1}}],[\"math\",{\"1\":{\"127\":2,\"128\":2}}],[\"maximum\",{\"1\":{\"127\":1,\"128\":1}}],[\"maxweight\",{\"1\":{\"118\":7}}],[\"max\",{\"1\":{\"118\":2,\"127\":4,\"128\":3}}],[\"mac\",{\"1\":{\"111\":2}}],[\"magic\",{\"1\":{\"96\":1,\"98\":1,\"99\":5,\"101\":1}}],[\"manual\",{\"1\":{\"25\":1,\"44\":1}}],[\"mannual\",{\"1\":{\"25\":1,\"44\":1}}],[\"map<servicemetainfo\",{\"1\":{\"118\":1}}],[\"map<string\",{\"1\":{\"4\":1,\"10\":9,\"26\":1,\"37\":3,\"38\":1,\"39\":1,\"40\":2,\"41\":1,\"103\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":1}}],[\"map<class<\",{\"1\":{\"51\":1}}],[\"mapper\",{\"1\":{\"48\":7}}],[\"map\",{\"1\":{\"10\":2,\"26\":1,\"51\":1,\"85\":1,\"116\":2}}],[\"main\",{\"1\":{\"3\":2,\"8\":1,\"29\":1,\"30\":1,\"65\":2,\"70\":1,\"100\":1,\"101\":1}}],[\"mp\",{\"1\":{\"0\":1}}],[\"md\",{\"1\":{\"0\":1}}],[\"7\",{\"1\":{\"0\":1,\"118\":3}}],[\"756685\",{\"1\":{\"0\":1}}],[\"748249\",{\"1\":{\"0\":1}}],[\"实际处理请求的服务器\",{\"1\":{\"111\":1}}],[\"实际上传递或返回的是object类型\",{\"1\":{\"48\":1}}],[\"实时检测系统运行状态\",{\"1\":{\"32\":1}}],[\"实例地址等\",{\"1\":{\"74\":1}}],[\"实例\",{\"1\":{\"29\":1,\"108\":1}}],[\"实例的字段上\",{\"1\":{\"20\":1}}],[\"实例的所有声明字段\",{\"1\":{\"20\":1}}],[\"实例的第一个接口作为服务接口\",{\"1\":{\"19\":1}}],[\"实例后\",{\"1\":{\"20\":1}}],[\"实例化\",{\"1\":{\"10\":2}}],[\"实现幂等性\",{\"1\":{\"121\":1}}],[\"实现复杂度较高\",{\"1\":{\"116\":1}}],[\"实现最简单\",{\"1\":{\"114\":1,\"125\":1}}],[\"实现代码\",{\"1\":{\"48\":1}}],[\"实现也能正确执行\",{\"1\":{\"20\":1}}],[\"实现时\",{\"1\":{\"10\":1}}],[\"实现类的实例\",{\"1\":{\"10\":1}}],[\"实现类的\",{\"1\":{\"10\":1}}],[\"实现\",{\"1\":{\"5\":1,\"90\":1,\"108\":2}}],[\"实现原理\",{\"1\":{\"0\":1}}],[\"实战spi案例\",{\"1\":{\"0\":1}}],[\"机制详解\",{\"1\":{\"0\":1}}],[\"pos\",{\"1\":{\"117\":3}}],[\"postman\",{\"1\":{\"69\":1}}],[\"postprocessafterinitialization\",{\"1\":{\"19\":2,\"20\":4}}],[\"post\",{\"1\":{\"0\":1,\"3\":1}}],[\"port\",{\"1\":{\"100\":3}}],[\"p>\",{\"1\":{\"26\":1}}],[\"password\",{\"1\":{\"78\":1}}],[\"parser\",{\"1\":{\"108\":7}}],[\"parseobj\",{\"1\":{\"26\":1}}],[\"param\",{\"1\":{\"5\":4,\"10\":4,\"18\":2,\"26\":29,\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"41\":2,\"46\":5,\"48\":6,\"59\":1,\"79\":4,\"102\":1,\"113\":2,\"116\":3,\"124\":1,\"125\":1,\"126\":1}}],[\"parametertypes\",{\"1\":{\"3\":2,\"4\":1,\"48\":4,\"103\":1}}],[\"path\",{\"1\":{\"26\":12,\"81\":1,\"83\":2,\"84\":1,\"85\":1}}],[\"package\",{\"1\":{\"10\":1,\"26\":1,\"51\":1,\"78\":1,\"96\":1}}],[\"putoption\",{\"1\":{\"83\":4}}],[\"put\",{\"1\":{\"4\":4,\"10\":5,\"40\":3,\"51\":1,\"83\":1,\"88\":1,\"103\":4,\"116\":1,\"118\":1}}],[\"public\",{\"1\":{\"3\":8,\"4\":2,\"5\":3,\"8\":6,\"10\":6,\"14\":2,\"15\":2,\"16\":2,\"18\":2,\"19\":2,\"20\":2,\"21\":1,\"26\":13,\"29\":5,\"30\":4,\"37\":1,\"38\":2,\"39\":4,\"40\":2,\"41\":2,\"46\":1,\"47\":3,\"48\":5,\"49\":3,\"50\":3,\"51\":3,\"59\":1,\"60\":2,\"61\":2,\"63\":2,\"64\":2,\"65\":4,\"70\":6,\"77\":4,\"78\":1,\"79\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":3,\"87\":2,\"88\":1,\"96\":2,\"98\":2,\"99\":2,\"100\":3,\"101\":4,\"102\":2,\"103\":2,\"108\":7,\"113\":1,\"114\":2,\"115\":2,\"116\":2,\"117\":4,\"118\":4,\"124\":1,\"125\":2,\"126\":3,\"127\":3,\"128\":2}}],[\"prefix\",{\"1\":{\"26\":33}}],[\"private\",{\"1\":{\"10\":8,\"26\":18,\"29\":2,\"39\":1,\"48\":1,\"49\":1,\"51\":3,\"61\":1,\"64\":1,\"66\":1,\"77\":7,\"78\":5,\"81\":6,\"86\":1,\"96\":9,\"108\":2,\"114\":1,\"115\":1,\"116\":3,\"117\":3,\"118\":4,\"127\":2,\"128\":2}}],[\"println\",{\"1\":{\"3\":1,\"8\":2,\"10\":2,\"20\":2,\"26\":1,\"30\":2,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"86\":1,\"100\":2,\"101\":8}}],[\"printstacktrace\",{\"1\":{\"3\":1,\"102\":1}}],[\"procedure\",{\"1\":{\"90\":1}}],[\"processor<\",{\"1\":{\"12\":2}}],[\"protocolconstant\",{\"1\":{\"99\":1,\"101\":2,\"108\":4}}],[\"protocolmessagestatusenum\",{\"1\":{\"102\":1}}],[\"protocolmessageserializerenum\",{\"1\":{\"98\":2,\"99\":2,\"101\":1}}],[\"protocolmessagetypeenum\",{\"1\":{\"99\":2,\"101\":1,\"102\":1}}],[\"protocolmessagedecoder\",{\"1\":{\"99\":1,\"101\":1,\"102\":2}}],[\"protocolmessage\",{\"1\":{\"98\":8,\"99\":2,\"101\":6,\"102\":6}}],[\"protocolmessage<rpcrequest>\",{\"1\":{\"102\":3}}],[\"protocolmessage<rpcresponse>\",{\"1\":{\"101\":2,\"102\":2}}],[\"protocolmessage<object>\",{\"1\":{\"101\":1}}],[\"protocolmessage<>\",{\"1\":{\"99\":2,\"101\":1,\"102\":1}}],[\"protocolmessage<\",{\"1\":{\"98\":1,\"99\":1}}],[\"protocolmessage<t>\",{\"1\":{\"96\":1}}],[\"protocolmessageencoder\",{\"1\":{\"98\":1,\"101\":1,\"102\":2}}],[\"protocol是一种面向连接的\",{\"1\":{\"90\":1}}],[\"protocol是一种用于从网络传输超文本到本地浏览器的传输协议\",{\"1\":{\"90\":1}}],[\"protocol\",{\"1\":{\"90\":2,\"96\":1,\"99\":1,\"101\":2}}],[\"protostuffserializer\",{\"1\":{\"51\":1}}],[\"protostuffioutil\",{\"1\":{\"51\":3}}],[\"protostuff<\",{\"1\":{\"51\":2}}],[\"protostuff\",{\"1\":{\"51\":7}}],[\"proto\",{\"1\":{\"51\":1}}],[\"protobuf需要先定义\",{\"1\":{\"51\":1}}],[\"protobuf\",{\"0\":{\"51\":1},\"1\":{\"44\":2,\"91\":1,\"94\":1}}],[\"props\",{\"1\":{\"26\":20}}],[\"properties\",{\"1\":{\"26\":22}}],[\"properties>\",{\"1\":{\"12\":1}}],[\"provider模块\",{\"0\":{\"60\":1}}],[\"providerbootstrap\",{\"1\":{\"29\":3}}],[\"provider只用在提交的jar包里的meta\",{\"1\":{\"8\":1}}],[\"provider\",{\"1\":{\"7\":1,\"28\":1,\"56\":1,\"60\":1,\"63\":2}}],[\"proxy\",{\"1\":{\"2\":1,\"4\":2,\"5\":4,\"20\":2,\"70\":2,\"103\":1}}],[\"pdai\",{\"1\":{\"0\":1}}],[\"p\",{\"1\":{\"0\":1}}],[\"waitstrategies\",{\"1\":{\"126\":2}}],[\"waiting\",{\"1\":{\"101\":1}}],[\"watchevent\",{\"1\":{\"88\":1}}],[\"watchclient\",{\"1\":{\"88\":2}}],[\"watchingkeyset\",{\"1\":{\"81\":1,\"88\":1}}],[\"watch\",{\"1\":{\"79\":1,\"85\":1,\"88\":3}}],[\"warn\",{\"1\":{\"26\":5,\"127\":1,\"128\":1}}],[\"weight>\",{\"1\":{\"118\":1}}],[\"weight=\",{\"1\":{\"118\":1}}],[\"weightedroundrobinloadbalancer\",{\"1\":{\"117\":2,\"118\":1}}],[\"weighted\",{\"1\":{\"112\":1}}],[\"weight\",{\"1\":{\"77\":1,\"117\":5,\"118\":14}}],[\"weixin\",{\"1\":{\"0\":1}}],[\"webpack\",{\"1\":{\"69\":1}}],[\"withretrylistener\",{\"1\":{\"126\":2}}],[\"withstopstrategy\",{\"1\":{\"126\":2}}],[\"withwaitstrategy\",{\"1\":{\"126\":2}}],[\"withleaseid\",{\"1\":{\"83\":1}}],[\"withinitial\",{\"1\":{\"49\":1}}],[\"will\",{\"1\":{\"26\":5}}],[\"write\",{\"1\":{\"101\":2,\"102\":2}}],[\"writecache\",{\"1\":{\"85\":2}}],[\"writevalueasbytes\",{\"1\":{\"48\":3}}],[\"writeobject\",{\"1\":{\"47\":1,\"49\":1,\"50\":1}}],[\"while\",{\"1\":{\"10\":2,\"127\":1,\"128\":1}}],[\"whgk\",{\"1\":{\"0\":1}}],[\"wu\",{\"1\":{\"0\":1}}],[\"www\",{\"1\":{\"0\":6}}],[\"functionalinterface\",{\"1\":{\"127\":1}}],[\"flood等攻击\",{\"1\":{\"111\":1}}],[\"from\",{\"1\":{\"26\":4,\"83\":2,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":1,\"101\":1}}],[\"fasterxml\",{\"1\":{\"48\":2}}],[\"fast\",{\"1\":{\"16\":3,\"26\":1}}],[\"failed\",{\"1\":{\"100\":1,\"101\":2,\"127\":1,\"128\":1}}],[\"failsilenttolerantstrategy\",{\"1\":{\"39\":3}}],[\"failsafetolerantstrategy\",{\"1\":{\"39\":1}}],[\"failsafe\",{\"1\":{\"34\":1}}],[\"failbacktolerantstrategy\",{\"1\":{\"41\":1}}],[\"failback\",{\"1\":{\"34\":1}}],[\"failfasttolerantstrategy\",{\"1\":{\"38\":3}}],[\"failfast\",{\"1\":{\"34\":1}}],[\"failovertolerantstrategy\",{\"1\":{\"40\":4,\"41\":3}}],[\"failover\",{\"1\":{\"34\":1}}],[\"fail\",{\"1\":{\"16\":3,\"26\":1,\"40\":2,\"41\":2}}],[\"false\",{\"1\":{\"14\":1,\"16\":3,\"20\":1,\"26\":1,\"49\":3,\"65\":2}}],[\"factories文件来加载各种自定义的bean\",{\"1\":{\"9\":1}}],[\"fang\",{\"1\":{\"0\":1}}],[\"found\",{\"1\":{\"131\":1}}],[\"forking\",{\"1\":{\"34\":1}}],[\"format\",{\"1\":{\"10\":8,\"77\":4}}],[\"forname\",{\"1\":{\"10\":7}}],[\"for\",{\"1\":{\"8\":1,\"10\":4,\"20\":1,\"29\":1,\"40\":1,\"41\":1,\"48\":1,\"86\":1,\"87\":1,\"88\":1,\"101\":2,\"116\":2,\"117\":4,\"118\":4,\"127\":1,\"128\":1}}],[\"food\",{\"1\":{\"8\":5}}],[\"fixedintervalretrystrategy\",{\"1\":{\"126\":1}}],[\"fixedwait\",{\"1\":{\"126\":2}}],[\"fixed\",{\"1\":{\"122\":1}}],[\"fixedsizemode\",{\"1\":{\"108\":5}}],[\"firstentry\",{\"1\":{\"116\":1}}],[\"field\",{\"1\":{\"16\":3,\"20\":10}}],[\"finally\",{\"1\":{\"47\":1,\"51\":1}}],[\"final\",{\"1\":{\"4\":1,\"10\":4,\"18\":1,\"19\":1,\"26\":6,\"29\":1,\"39\":1,\"48\":1,\"49\":1,\"81\":4,\"103\":1,\"108\":1,\"114\":1,\"115\":1,\"116\":2,\"127\":2,\"128\":2}}],[\"file\",{\"1\":{\"0\":1,\"26\":29}}],[\"fen\",{\"1\":{\"0\":1}}],[\"times\",{\"1\":{\"127\":5,\"128\":4}}],[\"timeunit\",{\"1\":{\"101\":1,\"103\":1,\"126\":2,\"127\":2,\"128\":2}}],[\"timeout\",{\"1\":{\"78\":1}}],[\"tcpbufferhandlerwrapper\",{\"1\":{\"101\":4,\"102\":4,\"103\":4,\"108\":10}}],[\"tcp客户端实现\",{\"0\":{\"101\":1}}],[\"tcpserverhandler\",{\"1\":{\"100\":2,\"102\":1,\"108\":1}}],[\"tcp服务器实现\",{\"0\":{\"100\":1},\"1\":{\"100\":1}}],[\"tcp有半包和粘包问题\",{\"1\":{\"94\":1}}],[\"tcp与udp\",{\"1\":{\"93\":1}}],[\"tcp\",{\"1\":{\"29\":2,\"74\":1,\"90\":2,\"100\":1,\"101\":3,\"102\":1,\"108\":2,\"111\":1}}],[\"tclassname\",{\"1\":{\"10\":4}}],[\"tclass\",{\"1\":{\"10\":3,\"26\":2}}],[\"t>\",{\"1\":{\"29\":1}}],[\"totalweight\",{\"1\":{\"117\":3,\"118\":3}}],[\"to\",{\"1\":{\"100\":1,\"101\":6,\"102\":1,\"127\":2}}],[\"tolist\",{\"1\":{\"85\":1}}],[\"tolerantstrategykeys\",{\"1\":{\"16\":3,\"25\":1,\"26\":1}}],[\"tolerantstrategyconstant\",{\"1\":{\"4\":3,\"40\":6,\"41\":3,\"103\":3}}],[\"tolerantstrategyfactory\",{\"1\":{\"4\":1,\"40\":1,\"103\":1}}],[\"tolerantstrategy\",{\"1\":{\"4\":1,\"16\":2,\"25\":1,\"26\":1,\"37\":3,\"38\":1,\"39\":1,\"40\":2,\"41\":1,\"103\":1}}],[\"tojsonstr\",{\"1\":{\"83\":1}}],[\"todo\",{\"1\":{\"52\":1,\"53\":1,\"54\":1}}],[\"tobytearray\",{\"1\":{\"47\":1,\"49\":1,\"50\":1,\"51\":1}}],[\"tobean\",{\"1\":{\"26\":3,\"85\":1,\"87\":1}}],[\"tostring\",{\"1\":{\"26\":2,\"85\":1,\"87\":1,\"101\":1}}],[\"treemap<>\",{\"1\":{\"116\":1}}],[\"treemap<integer\",{\"1\":{\"116\":1}}],[\"treemap\",{\"1\":{\"116\":1}}],[\"transmission\",{\"1\":{\"90\":1}}],[\"transfer\",{\"1\":{\"90\":1}}],[\"true\",{\"1\":{\"14\":3,\"20\":1,\"21\":1,\"49\":1,\"85\":1,\"87\":1}}],[\"try\",{\"1\":{\"3\":2,\"4\":1,\"10\":3,\"19\":1,\"20\":1,\"26\":7,\"29\":1,\"40\":2,\"41\":1,\"47\":1,\"51\":1,\"85\":1,\"86\":1,\"87\":1,\"101\":2,\"102\":3,\"103\":1,\"127\":1,\"128\":1}}],[\"type\",{\"1\":{\"14\":3,\"15\":3,\"21\":1,\"48\":6,\"96\":1,\"98\":1}}],[\"tychozzz\",{\"1\":{\"0\":1}}],[\"the\",{\"1\":{\"102\":1}}],[\"this\",{\"1\":{\"10\":1,\"39\":2,\"108\":1}}],[\"threadlocal<kryo>\",{\"1\":{\"49\":1}}],[\"threadlocal\",{\"1\":{\"49\":3}}],[\"thread\",{\"1\":{\"26\":1,\"49\":3,\"86\":1,\"127\":2,\"128\":1}}],[\"throw\",{\"1\":{\"4\":1,\"10\":4,\"19\":1,\"20\":1,\"26\":1,\"29\":1,\"38\":1,\"40\":1,\"41\":1,\"47\":1,\"85\":1,\"86\":1,\"87\":1,\"98\":1,\"99\":4,\"101\":2,\"102\":2,\"103\":1,\"127\":1,\"128\":1}}],[\"throwable\",{\"1\":{\"4\":1,\"70\":2,\"103\":1}}],[\"throws\",{\"1\":{\"4\":1,\"8\":1,\"19\":1,\"20\":1,\"26\":2,\"46\":4,\"47\":2,\"48\":5,\"49\":2,\"50\":2,\"51\":1,\"70\":2,\"79\":2,\"83\":1,\"98\":1,\"99\":1,\"101\":1,\"103\":1,\"124\":2,\"125\":2,\"126\":2,\"127\":5,\"128\":1}}],[\"thrift\",{\"0\":{\"54\":1},\"1\":{\"0\":1,\"44\":2,\"91\":1}}],[\"test\",{\"1\":{\"10\":2,\"26\":1,\"61\":1,\"64\":1,\"66\":3}}],[\"tech\",{\"1\":{\"0\":2}}],[\"t\",{\"1\":{\"5\":5,\"10\":3,\"26\":14,\"46\":2,\"47\":3,\"48\":5,\"49\":3,\"50\":3,\"51\":3,\"70\":2,\"96\":1}}],[\"task\",{\"1\":{\"87\":1}}],[\"target\",{\"1\":{\"14\":2,\"15\":2,\"16\":2,\"21\":1}}],[\"tai\",{\"1\":{\"0\":1}}],[\"tab=readme\",{\"1\":{\"0\":1}}],[\"简要介绍\",{\"1\":{\"44\":1}}],[\"简单\",{\"1\":{\"26\":1}}],[\"简单rpc框架https\",{\"1\":{\"0\":1}}],[\"简易版dubbo构造\",{\"1\":{\"0\":1}}],[\"如最大重试次数\",{\"1\":{\"128\":1}}],[\"如方法名\",{\"1\":{\"94\":1}}],[\"如成功\",{\"1\":{\"94\":1,\"98\":1}}],[\"如请求\",{\"1\":{\"94\":1,\"98\":1}}],[\"如灰度发布\",{\"1\":{\"74\":1}}],[\"如服务名称\",{\"1\":{\"74\":1}}],[\"如服务名\",{\"1\":{\"72\":1}}],[\"如超时\",{\"1\":{\"69\":1}}],[\"如网络延迟\",{\"1\":{\"33\":1}}],[\"如轮询\",{\"1\":{\"25\":1}}],[\"如地址\",{\"1\":{\"25\":1}}],[\"如\",{\"1\":{\"25\":3,\"91\":1,\"94\":1}}],[\"如hutool\",{\"1\":{\"24\":1}}],[\"如注册中心地址\",{\"1\":{\"24\":1}}],[\"如获取类的成员\",{\"1\":{\"10\":1}}],[\"如序列化器\",{\"1\":{\"10\":1}}],[\"如log4j\",{\"1\":{\"9\":1}}],[\"如图\",{\"1\":{\"8\":1}}],[\"如果对响应时间要求较高\",{\"1\":{\"128\":1}}],[\"如果对于轮询算法\",{\"1\":{\"116\":1}}],[\"如果出现异常\",{\"1\":{\"127\":1}}],[\"如果重试次数达到上限\",{\"1\":{\"127\":1}}],[\"如果重试失败\",{\"1\":{\"124\":1}}],[\"如果重试成功\",{\"1\":{\"124\":1,\"127\":1}}],[\"如果重试再失败\",{\"1\":{\"40\":1,\"41\":1}}],[\"如果超时了会直接返回超时异常\",{\"1\":{\"121\":1}}],[\"如果超过5那么就是c\",{\"1\":{\"117\":1}}],[\"如果配置了异常重试机制\",{\"1\":{\"121\":1}}],[\"如果没有重试机制\",{\"1\":{\"121\":1}}],[\"如果没有的话\",{\"1\":{\"85\":1}}],[\"如果当前位置小于权重值\",{\"1\":{\"117\":1}}],[\"如果说服务列表不变\",{\"1\":{\"117\":1}}],[\"如果说服务器算出的哈希值分布不够均匀\",{\"1\":{\"116\":1}}],[\"如果找不到大于该哈希值的虚拟节点\",{\"1\":{\"116\":1}}],[\"如果某个点下线了\",{\"1\":{\"116\":1}}],[\"如果size==\",{\"1\":{\"108\":1}}],[\"如果消息不完整\",{\"1\":{\"107\":1}}],[\"如果我们客户端要发送的消息为hello\",{\"1\":{\"105\":1}}],[\"如果在调用过程中出现异常\",{\"1\":{\"102\":1}}],[\"如果服务器数量非常大\",{\"1\":{\"117\":1}}],[\"如果服务实例较少\",{\"1\":{\"116\":1}}],[\"如果服务注册信息发生了变化\",{\"1\":{\"88\":1}}],[\"如果服务端增删字段\",{\"1\":{\"44\":1}}],[\"如果节点宕机了\",{\"1\":{\"87\":1}}],[\"如果系统在一定时间内没有响应\",{\"1\":{\"87\":1}}],[\"如果系统压力过大\",{\"1\":{\"36\":1}}],[\"如果缓存中有\",{\"1\":{\"85\":1}}],[\"如果注册中心都挂了\",{\"1\":{\"75\":1}}],[\"如果类型不同\",{\"1\":{\"48\":2}}],[\"如果json对象包含其他json对象或json数组\",{\"1\":{\"48\":1}}],[\"如果java对象包含其他java对象或集合\",{\"1\":{\"48\":1}}],[\"如果都失败\",{\"1\":{\"40\":1}}],[\"如果加载失败\",{\"1\":{\"26\":1}}],[\"如果直接在代码中硬编码这些配置\",{\"1\":{\"24\":1}}],[\"如果未指定则默认使用字段类型\",{\"1\":{\"20\":1}}],[\"如果未开启\",{\"1\":{\"5\":1}}],[\"如果字段被\",{\"1\":{\"20\":2}}],[\"如果有\",{\"1\":{\"20\":1}}],[\"如果\",{\"1\":{\"19\":1,\"127\":3}}],[\"如果不设置该属性\",{\"1\":{\"15\":2,\"16\":6}}],[\"如果要创建类的实例\",{\"1\":{\"10\":1}}],[\"如果需要切换到\",{\"1\":{\"5\":1}}],[\"如果开启了\",{\"1\":{\"5\":1}}],[\"如负载均衡\",{\"1\":{\"2\":1,\"4\":1}}],[\"如何解决粘包问题\",{\"0\":{\"108\":1}}],[\"如何解决半包\",{\"0\":{\"107\":1}}],[\"如何解决半包粘包问题\",{\"0\":{\"106\":1}}],[\"如何在java项目退出的时候\",{\"1\":{\"86\":1}}],[\"如何设计\",{\"0\":{\"25\":1}}],[\"如何实现一个rpc框架\",{\"1\":{\"0\":1}}],[\"如何手撸一个较为完整的rpc框架\",{\"1\":{\"0\":1}}],[\"如下\",{\"1\":{\"0\":1,\"70\":1}}],[\"attempt\",{\"1\":{\"126\":2}}],[\"attempt<v>\",{\"1\":{\"126\":1}}],[\"atomicinteger\",{\"1\":{\"115\":3,\"117\":4,\"118\":2}}],[\"a\",{\"1\":{\"118\":2,\"127\":2}}],[\"actualport\",{\"1\":{\"100\":1}}],[\"actual\",{\"1\":{\"100\":1}}],[\"aclass\",{\"1\":{\"10\":2}}],[\"alibaba\",{\"1\":{\"73\":1}}],[\"allocate\",{\"1\":{\"51\":1}}],[\"all\",{\"1\":{\"40\":1,\"41\":1}}],[\"allargsconstructor\",{\"1\":{\"29\":1,\"96\":2,\"118\":1}}],[\"avro\",{\"0\":{\"52\":1},\"1\":{\"44\":2}}],[\"author\",{\"1\":{\"30\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"117\":1,\"118\":1,\"126\":1}}],[\"address\",{\"1\":{\"78\":1}}],[\"add\",{\"1\":{\"29\":1,\"83\":1,\"88\":1,\"117\":1}}],[\"addshutdownhook\",{\"1\":{\"26\":1,\"86\":1}}],[\"advanced\",{\"1\":{\"0\":2}}],[\"api\",{\"1\":{\"69\":4}}],[\"appendbuffer\",{\"1\":{\"108\":4}}],[\"appendbytes\",{\"1\":{\"98\":1,\"101\":1}}],[\"appendbyte\",{\"1\":{\"98\":5}}],[\"appendint\",{\"1\":{\"98\":1,\"101\":2}}],[\"appendlong\",{\"1\":{\"98\":1}}],[\"append\",{\"1\":{\"26\":6}}],[\"application\",{\"1\":{\"26\":19,\"86\":1}}],[\"apache\",{\"1\":{\"0\":1,\"12\":1,\"25\":1,\"34\":1,\"44\":1}}],[\"aslist\",{\"1\":{\"10\":1}}],[\"arraylist<>\",{\"1\":{\"29\":1,\"117\":1}}],[\"arrays\",{\"1\":{\"10\":2}}],[\"artifactid>\",{\"1\":{\"12\":5,\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"57\":2,\"70\":1,\"124\":1}}],[\"article\",{\"1\":{\"0\":4,\"121\":1}}],[\"args\",{\"1\":{\"3\":4,\"4\":3,\"8\":1,\"29\":1,\"30\":1,\"48\":5,\"65\":4,\"70\":2,\"100\":1,\"101\":1,\"103\":3}}],[\"archives\",{\"1\":{\"0\":2}}],[\"annotationmetadata\",{\"1\":{\"18\":1}}],[\"animalserviceloader\",{\"1\":{\"8\":2}}],[\"animal\",{\"1\":{\"8\":8}}],[\"an\",{\"1\":{\"0\":1,\"127\":1}}],[\"深入理解rpc框架的序列化方案\",{\"1\":{\"0\":1}}],[\"sleep\",{\"1\":{\"127\":2,\"128\":1}}],[\"sleeptime\",{\"1\":{\"127\":6,\"128\":4}}],[\"slf4j\",{\"1\":{\"10\":3,\"18\":1,\"26\":4,\"29\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"60\":1,\"63\":1,\"70\":2,\"86\":1,\"125\":1,\"126\":1,\"127\":3,\"128\":3}}],[\"slf4j和logback等\",{\"1\":{\"9\":1}}],[\"switch\",{\"1\":{\"88\":1,\"99\":1}}],[\"short\",{\"1\":{\"70\":1}}],[\"shit\",{\"1\":{\"8\":1}}],[\"shi\",{\"1\":{\"0\":2}}],[\"size\",{\"1\":{\"51\":1,\"108\":10,\"114\":5,\"115\":5,\"117\":1}}],[\"schedule\",{\"1\":{\"87\":1}}],[\"schemacache\",{\"1\":{\"51\":3}}],[\"schema<t>\",{\"1\":{\"51\":5}}],[\"schema<\",{\"1\":{\"51\":2}}],[\"schema\",{\"1\":{\"51\":12}}],[\"scandir\",{\"1\":{\"10\":4}}],[\"scan\",{\"1\":{\"10\":2}}],[\"synchronized\",{\"1\":{\"26\":1}}],[\"system\",{\"1\":{\"3\":1,\"8\":2,\"10\":5,\"20\":2,\"26\":1,\"30\":2,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"86\":1,\"100\":2,\"101\":8}}],[\"succeeded\",{\"1\":{\"100\":1,\"101\":2}}],[\"success\",{\"1\":{\"26\":2,\"86\":2}}],[\"super\",{\"1\":{\"19\":1,\"20\":2}}],[\"sdk\",{\"1\":{\"25\":1,\"44\":1}}],[\"snapshot<\",{\"1\":{\"12\":1,\"57\":2}}],[\"s不存在\",{\"1\":{\"10\":1}}],[\"sql\",{\"1\":{\"7\":1,\"9\":1}}],[\"send\",{\"1\":{\"101\":1}}],[\"seconds\",{\"1\":{\"101\":1,\"103\":1,\"126\":2}}],[\"searchprefix\",{\"1\":{\"85\":2}}],[\"see\",{\"1\":{\"76\":1}}],[\"setcurrentweight\",{\"1\":{\"118\":2}}],[\"setoutput\",{\"1\":{\"108\":1}}],[\"setexception\",{\"1\":{\"102\":1}}],[\"setmessage\",{\"1\":{\"102\":2}}],[\"setmagic\",{\"1\":{\"99\":1,\"101\":1}}],[\"setmatchsecond\",{\"1\":{\"87\":1}}],[\"setbody\",{\"1\":{\"101\":1}}],[\"setbodylength\",{\"1\":{\"99\":1}}],[\"setheader\",{\"1\":{\"101\":1}}],[\"setrequestid\",{\"1\":{\"99\":1,\"101\":1}}],[\"setregistrationrequired\",{\"1\":{\"49\":4}}],[\"setstatus\",{\"1\":{\"99\":1,\"102\":1}}],[\"setserializer\",{\"1\":{\"99\":1,\"101\":1}}],[\"setserviceport\",{\"1\":{\"19\":1,\"29\":1}}],[\"setservicehost\",{\"1\":{\"19\":1,\"29\":1}}],[\"setserviceversion\",{\"1\":{\"4\":1,\"19\":1,\"103\":1}}],[\"setservicename\",{\"1\":{\"4\":1,\"19\":1,\"29\":1,\"103\":1}}],[\"settype\",{\"1\":{\"99\":1,\"101\":1,\"102\":1}}],[\"setting\",{\"1\":{\"26\":2}}],[\"setversion\",{\"1\":{\"99\":1,\"101\":1}}],[\"set<string>\",{\"1\":{\"81\":2}}],[\"setdatatype\",{\"1\":{\"102\":1}}],[\"setdata\",{\"1\":{\"48\":1,\"102\":1}}],[\"setname\",{\"1\":{\"30\":1,\"61\":1,\"64\":1}}],[\"set\",{\"1\":{\"20\":1}}],[\"setaccessible\",{\"1\":{\"20\":2}}],[\"select\",{\"1\":{\"4\":1,\"103\":1,\"113\":1,\"114\":1,\"115\":2,\"116\":3,\"117\":2,\"118\":1}}],[\"serialization\",{\"1\":{\"44\":1}}],[\"serialize\",{\"1\":{\"3\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"98\":1}}],[\"serializerenum\",{\"1\":{\"98\":3,\"99\":3}}],[\"serializerkeys\",{\"1\":{\"25\":1,\"26\":1}}],[\"serializerfactory\",{\"1\":{\"4\":1,\"10\":1,\"98\":1,\"99\":1,\"103\":1}}],[\"serializer\",{\"1\":{\"3\":3,\"4\":2,\"10\":10,\"25\":1,\"26\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"96\":1,\"98\":5,\"99\":4,\"103\":2}}],[\"servicecache\",{\"1\":{\"85\":4}}],[\"serviceclass\",{\"1\":{\"5\":13,\"70\":3}}],[\"servicenodekey\",{\"1\":{\"79\":1,\"88\":3}}],[\"servicename\",{\"1\":{\"3\":2,\"4\":3,\"19\":5,\"29\":4,\"77\":2,\"103\":3}}],[\"servicekey\",{\"1\":{\"79\":2,\"85\":2}}],[\"serviceport\",{\"1\":{\"77\":4}}],[\"serviceproxyfactory\",{\"1\":{\"5\":3,\"20\":2,\"30\":1,\"70\":2}}],[\"serviceproxy\",{\"1\":{\"4\":2,\"5\":3,\"103\":1}}],[\"servicehost\",{\"1\":{\"77\":5}}],[\"servicegroup\",{\"1\":{\"77\":1}}],[\"serviceaddress\",{\"1\":{\"77\":1}}],[\"serviceregisterinfos\",{\"1\":{\"29\":4}}],[\"serviceregisterinfo\",{\"1\":{\"29\":8}}],[\"serviceregisterinfo<\",{\"1\":{\"29\":1}}],[\"serviceregisterinfo<t>\",{\"1\":{\"29\":1}}],[\"serviceregisterinfolist\",{\"1\":{\"29\":2}}],[\"serviceregisterinfo类主要是服务名称和服务实现类\",{\"1\":{\"29\":1}}],[\"serviceversion\",{\"1\":{\"15\":2,\"16\":2,\"19\":4,\"77\":2}}],[\"serviceloader<animal>\",{\"1\":{\"8\":1}}],[\"serviceloader\",{\"1\":{\"7\":1,\"8\":1}}],[\"services目录\",{\"1\":{\"10\":1}}],[\"services目录中存放输入输出格式接口的实现类路径\",{\"1\":{\"9\":1}}],[\"services目录中存放插件接口的实现类路径\",{\"1\":{\"9\":1}}],[\"services目录下面去新建一个文件com\",{\"1\":{\"8\":1}}],[\"services下根据平台定义的接口新建文件\",{\"1\":{\"8\":1}}],[\"services\",{\"1\":{\"7\":2}}],[\"servicediscovery\",{\"1\":{\"4\":1,\"79\":1,\"85\":1,\"103\":1}}],[\"service\",{\"1\":{\"4\":3,\"7\":1,\"15\":3,\"16\":3,\"40\":4,\"41\":2,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"69\":2,\"72\":1,\"103\":3}}],[\"servicemetainfo>\",{\"1\":{\"116\":2}}],[\"servicemetainfolist\",{\"1\":{\"85\":3,\"113\":2,\"114\":4,\"115\":5,\"116\":5,\"117\":6,\"118\":3}}],[\"servicemetainfo是注册中心中服务的元数据信息\",{\"1\":{\"77\":1}}],[\"servicemetainfos\",{\"1\":{\"4\":4,\"40\":1,\"85\":3,\"103\":4}}],[\"servicemetainfo\",{\"1\":{\"4\":7,\"19\":8,\"29\":7,\"40\":5,\"41\":5,\"77\":1,\"79\":6,\"83\":5,\"84\":3,\"85\":1,\"87\":4,\"101\":1,\"103\":7,\"113\":1,\"114\":1,\"115\":1,\"116\":5,\"117\":16,\"118\":10}}],[\"serverport\",{\"1\":{\"25\":1,\"26\":1}}],[\"serverhost\",{\"1\":{\"25\":1,\"26\":1}}],[\"server\",{\"1\":{\"3\":2,\"18\":1,\"100\":6,\"101\":9}}],[\"stop\",{\"1\":{\"127\":1,\"128\":1}}],[\"stopwatch\",{\"1\":{\"127\":9,\"128\":8}}],[\"stopafterattempt\",{\"1\":{\"126\":2}}],[\"stopstrategies\",{\"1\":{\"126\":2}}],[\"status\",{\"1\":{\"96\":1,\"98\":1}}],[\"static\",{\"1\":{\"3\":2,\"5\":2,\"8\":1,\"10\":13,\"26\":18,\"29\":2,\"30\":2,\"48\":1,\"49\":1,\"51\":3,\"65\":2,\"70\":2,\"81\":1,\"86\":2,\"96\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"116\":1,\"117\":1,\"118\":2,\"127\":2,\"128\":2}}],[\"start\",{\"1\":{\"87\":1,\"101\":2,\"127\":1,\"128\":1}}],[\"starter\",{\"1\":{\"57\":1}}],[\"starter<\",{\"1\":{\"12\":1,\"57\":1}}],[\"started\",{\"1\":{\"18\":1}}],[\"standardcharsets\",{\"1\":{\"83\":2,\"84\":1,\"85\":2,\"86\":1,\"87\":2,\"88\":1}}],[\"str\",{\"1\":{\"101\":4}}],[\"stream\",{\"1\":{\"85\":1}}],[\"strutil\",{\"1\":{\"26\":3,\"77\":1}}],[\"strategy\",{\"1\":{\"4\":2,\"40\":2,\"103\":2}}],[\"stringbuilder\",{\"1\":{\"26\":4}}],[\"string\",{\"1\":{\"3\":3,\"4\":1,\"8\":4,\"10\":24,\"15\":2,\"16\":8,\"19\":3,\"20\":1,\"26\":35,\"29\":3,\"30\":1,\"65\":2,\"70\":1,\"77\":12,\"78\":4,\"79\":2,\"81\":1,\"83\":1,\"84\":1,\"85\":3,\"86\":1,\"87\":2,\"88\":1,\"100\":1,\"101\":2,\"103\":1}}],[\"s\",{\"1\":{\"0\":1,\"10\":4,\"77\":9}}],[\"so\",{\"1\":{\"127\":1}}],[\"socket\",{\"1\":{\"101\":6,\"102\":5,\"103\":1,\"108\":3}}],[\"soap使用较为复杂\",{\"1\":{\"44\":1}}],[\"soap\",{\"0\":{\"53\":1},\"1\":{\"44\":1}}],[\"sofarpc\",{\"1\":{\"0\":1}}],[\"sourcessr=users\",{\"1\":{\"0\":1}}],[\"split\",{\"1\":{\"10\":10,\"26\":2}}],[\"springapplication\",{\"1\":{\"65\":2}}],[\"springboottest\",{\"1\":{\"66\":1}}],[\"springbootapplication\",{\"1\":{\"65\":2}}],[\"springboot注解驱动设计\",{\"0\":{\"11\":1}}],[\"spring初始化执行时候\",{\"1\":{\"18\":1}}],[\"springframework\",{\"1\":{\"12\":3}}],[\"spring的spi机制提供了很多扩展点\",{\"1\":{\"9\":1}}],[\"spring的spi机制支持动态替换服务提供者\",{\"1\":{\"9\":1}}],[\"spring的spi机制支持自动装配\",{\"1\":{\"9\":1}}],[\"spring的spi机制允许为同一个接口定义多个实现类\",{\"1\":{\"9\":1}}],[\"spring的spi机制相对于java原生的spi机制进行了改造和扩展\",{\"1\":{\"9\":1}}],[\"spring框架中的bean加载机制就使用了spi思想\",{\"1\":{\"9\":1}}],[\"spring框架\",{\"1\":{\"9\":1}}],[\"spring\",{\"1\":{\"0\":1,\"9\":1,\"14\":2,\"15\":3,\"16\":1,\"18\":3,\"20\":2,\"57\":2,\"73\":1}}],[\"spi配置文件\",{\"1\":{\"10\":1}}],[\"spi配置文件格式错误\",{\"1\":{\"10\":2}}],[\"spiloader\",{\"1\":{\"10\":7}}],[\"spi加载器\",{\"1\":{\"10\":1}}],[\"spi声明扩展点接口\",{\"1\":{\"9\":1}}],[\"spi目录下面\",{\"1\":{\"8\":1}}],[\"spi服务发现机制实现\",{\"0\":{\"6\":1}}],[\"spi概念\",{\"1\":{\"0\":1}}],[\"spi\",{\"1\":{\"0\":3,\"7\":2,\"8\":1,\"10\":12}}],[\"spi机制的应用场景\",{\"0\":{\"9\":1}}],[\"spi机制\",{\"1\":{\"0\":1,\"129\":1}}],[\"spi机制部分\",{\"1\":{\"0\":1}}],[\"3l\",{\"1\":{\"126\":2}}],[\"3=1\",{\"1\":{\"117\":1}}],[\"32个比特\",{\"1\":{\"94\":1}}],[\"30\",{\"1\":{\"83\":1}}],[\"30s\",{\"1\":{\"83\":1}}],[\"3\",{\"1\":{\"70\":1,\"99\":1,\"117\":5,\"118\":6,\"122\":2,\"126\":6}}],[\"353159058410643456\",{\"1\":{\"0\":1}}],[\"38685503\",{\"1\":{\"0\":1}}],[\"nginx\",{\"1\":{\"111\":1}}],[\"nacos等其他注册中心\",{\"1\":{\"130\":1}}],[\"nacos等等\",{\"1\":{\"79\":1}}],[\"nacos\",{\"1\":{\"73\":1}}],[\"name\",{\"1\":{\"25\":1,\"26\":8}}],[\"num\",{\"1\":{\"116\":3,\"117\":2,\"118\":1}}],[\"number\",{\"1\":{\"70\":3}}],[\"null\",{\"1\":{\"3\":1,\"10\":3,\"19\":1,\"20\":2,\"26\":4,\"30\":1,\"40\":2,\"41\":2,\"51\":2,\"85\":1,\"86\":2,\"98\":3,\"99\":2,\"101\":1,\"103\":1,\"114\":1,\"115\":1,\"116\":2,\"117\":1,\"118\":2}}],[\"noretrystrategy\",{\"1\":{\"125\":1}}],[\"noresourceexception\",{\"1\":{\"26\":9}}],[\"node\",{\"1\":{\"116\":3}}],[\"now\",{\"1\":{\"100\":1}}],[\"nowcoder\",{\"1\":{\"0\":1}}],[\"noargsconstructor\",{\"1\":{\"29\":1,\"96\":2}}],[\"not\",{\"1\":{\"18\":1,\"26\":5,\"131\":1}}],[\"no\",{\"1\":{\"16\":3,\"26\":2,\"122\":1}}],[\"next\",{\"1\":{\"127\":1,\"128\":1}}],[\"nextint\",{\"1\":{\"114\":1}}],[\"needserver\",{\"1\":{\"14\":2,\"18\":4,\"21\":1,\"65\":2}}],[\"newfixed\",{\"1\":{\"108\":2}}],[\"newwatch\",{\"1\":{\"88\":2}}],[\"newservicecache\",{\"1\":{\"85\":2}}],[\"newmessage\",{\"1\":{\"51\":1}}],[\"newrpcconfig\",{\"1\":{\"26\":8,\"86\":2}}],[\"newinstance\",{\"1\":{\"10\":4,\"102\":1}}],[\"newproxyinstance\",{\"1\":{\"5\":4,\"70\":1}}],[\"new\",{\"1\":{\"3\":7,\"4\":4,\"5\":7,\"10\":14,\"18\":1,\"19\":2,\"20\":1,\"26\":7,\"29\":5,\"30\":1,\"38\":1,\"39\":1,\"40\":2,\"41\":1,\"47\":5,\"48\":1,\"49\":5,\"50\":4,\"51\":1,\"61\":1,\"64\":1,\"70\":3,\"81\":3,\"85\":1,\"86\":2,\"87\":2,\"98\":1,\"99\":7,\"100\":3,\"101\":7,\"102\":5,\"103\":6,\"108\":3,\"114\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":3,\"126\":2,\"127\":1,\"128\":1}}],[\"netsocket\",{\"1\":{\"101\":2,\"102\":1,\"108\":1}}],[\"netserver\",{\"1\":{\"100\":1}}],[\"netclient\",{\"1\":{\"101\":4,\"103\":1,\"108\":1}}],[\"netflix\",{\"1\":{\"73\":1}}],[\"netty框架也使用了spi机制\",{\"1\":{\"9\":1}}],[\"netty框架\",{\"1\":{\"9\":1}}],[\"net\",{\"1\":{\"0\":4,\"10\":1,\"121\":1}}],[\"qq\",{\"1\":{\"0\":4}}],[\"b放3个进去\",{\"1\":{\"117\":1}}],[\"b\",{\"1\":{\"117\":1,\"118\":4}}],[\"bind\",{\"1\":{\"100\":1}}],[\"bit\",{\"1\":{\"94\":1}}],[\"breaker\",{\"1\":{\"122\":1}}],[\"break\",{\"1\":{\"88\":2}}],[\"broadcast\",{\"1\":{\"34\":1}}],[\"boolean\",{\"1\":{\"14\":2,\"16\":2,\"18\":2,\"21\":1,\"26\":1,\"88\":1}}],[\"boot\",{\"1\":{\"12\":3,\"18\":1,\"57\":2}}],[\"boot<\",{\"1\":{\"12\":3}}],[\"bodylength\",{\"1\":{\"96\":1,\"98\":1}}],[\"body\",{\"1\":{\"3\":1,\"96\":1,\"98\":3}}],[\"bodybytes\",{\"1\":{\"3\":3,\"98\":3,\"99\":3}}],[\"before\",{\"1\":{\"127\":1,\"128\":1}}],[\"beat\",{\"1\":{\"99\":1}}],[\"beanclass\",{\"1\":{\"19\":5,\"20\":3}}],[\"beansexception\",{\"1\":{\"19\":1,\"20\":1}}],[\"beanname\",{\"1\":{\"19\":2,\"20\":3}}],[\"bean\",{\"1\":{\"19\":4,\"20\":9}}],[\"beanpostprocessor\",{\"1\":{\"19\":2,\"20\":6}}],[\"beandefinitionregistry\",{\"1\":{\"18\":1}}],[\"beanfactorypostprocessor等\",{\"1\":{\"9\":1}}],[\"belongtocode\",{\"1\":{\"0\":1}}],[\"byte类型\",{\"1\":{\"98\":5}}],[\"bytearrayinputstream\",{\"1\":{\"47\":2,\"49\":5,\"50\":5}}],[\"bytearrayoutputstream\",{\"1\":{\"47\":2,\"49\":6,\"50\":6}}],[\"bytesequence\",{\"1\":{\"83\":4,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":1}}],[\"bytes\",{\"1\":{\"46\":2,\"47\":2,\"48\":6,\"49\":2,\"50\":2,\"51\":2}}],[\"byte\",{\"1\":{\"3\":2,\"46\":2,\"47\":2,\"48\":4,\"49\":2,\"50\":2,\"51\":3,\"96\":5,\"98\":1,\"99\":2,\"101\":2,\"102\":2}}],[\"backing\",{\"1\":{\"127\":1,\"128\":1}}],[\"backoffinterval\",{\"1\":{\"127\":4,\"128\":6}}],[\"backoff\",{\"1\":{\"122\":1,\"127\":2,\"128\":4}}],[\"base\",{\"1\":{\"26\":27,\"127\":1,\"128\":1}}],[\"basis\",{\"1\":{\"0\":1}}],[\"balance\",{\"1\":{\"0\":1}}],[\"balancehttps\",{\"1\":{\"0\":1}}],[\"blog\",{\"1\":{\"0\":5,\"34\":1,\"121\":1}}],[\"bufferhandler\",{\"1\":{\"108\":5}}],[\"bufferhandlerwrapper\",{\"1\":{\"102\":2,\"108\":2}}],[\"buffer\",{\"1\":{\"51\":4,\"98\":19,\"99\":10,\"101\":13,\"102\":3,\"103\":1,\"108\":22}}],[\"bufferedreader\",{\"1\":{\"10\":9}}],[\"buildconfigfilepath\",{\"1\":{\"26\":3}}],[\"build\",{\"1\":{\"3\":2,\"4\":1,\"82\":1,\"83\":1,\"85\":1,\"103\":1,\"126\":1}}],[\"builder\",{\"1\":{\"3\":2,\"4\":1,\"82\":1,\"83\":1,\"85\":1,\"103\":1}}],[\"bu\",{\"1\":{\"0\":1}}],[\"hypertext\",{\"1\":{\"90\":1}}],[\"hello\",{\"1\":{\"101\":4,\"105\":3}}],[\"heat\",{\"1\":{\"99\":1}}],[\"header\",{\"1\":{\"96\":3,\"98\":11,\"99\":15,\"101\":9,\"102\":5,\"108\":5}}],[\"heading\",{\"1\":{\"0\":1}}],[\"heartbeat\",{\"1\":{\"79\":1,\"82\":1,\"87\":1}}],[\"hessianserializer\",{\"1\":{\"50\":1}}],[\"hessianoutput\",{\"1\":{\"50\":5}}],[\"hessianinput\",{\"1\":{\"50\":5}}],[\"hessian2协议\",{\"1\":{\"44\":1}}],[\"hessian\",{\"0\":{\"50\":1},\"1\":{\"44\":2,\"50\":3,\"94\":1}}],[\"houyunfei\",{\"1\":{\"30\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"117\":1,\"118\":1,\"126\":1}}],[\"hook\",{\"1\":{\"26\":1,\"86\":1}}],[\"home\",{\"1\":{\"0\":1}}],[\"hutool\",{\"1\":{\"10\":1,\"26\":6}}],[\"handle\",{\"1\":{\"102\":2,\"108\":7}}],[\"handler<buffer>\",{\"1\":{\"108\":5}}],[\"handler<netsocket>\",{\"1\":{\"102\":1,\"108\":1}}],[\"handler\",{\"1\":{\"101\":2,\"102\":1,\"103\":1,\"108\":2}}],[\"handleresponse\",{\"1\":{\"48\":2}}],[\"handlerequest\",{\"1\":{\"48\":2}}],[\"hashcode\",{\"1\":{\"116\":1}}],[\"hash算法\",{\"1\":{\"116\":1}}],[\"hash\",{\"1\":{\"116\":4}}],[\"hashing\",{\"1\":{\"112\":1}}],[\"hashicorp\",{\"1\":{\"73\":1}}],[\"hashset<>\",{\"1\":{\"81\":1}}],[\"hashmap\",{\"1\":{\"10\":1,\"118\":1}}],[\"hashmap<>\",{\"1\":{\"4\":2,\"10\":1,\"40\":1,\"103\":2}}],[\"hashmap<string\",{\"1\":{\"4\":1,\"10\":1,\"103\":1}}],[\"hadoop框架中的输入输出格式也使用了spi思想\",{\"1\":{\"9\":1}}],[\"hadoop框架\",{\"1\":{\"9\":1}}],[\"http只是一个通信协议\",{\"1\":{\"90\":1}}],[\"httprequest\",{\"1\":{\"3\":1}}],[\"httpresponse\",{\"1\":{\"3\":3}}],[\"http\",{\"1\":{\"3\":1,\"69\":1,\"77\":2,\"78\":1,\"90\":2,\"91\":1,\"111\":1}}],[\"httpserver\",{\"1\":{\"100\":1}}],[\"https\",{\"1\":{\"0\":20,\"25\":1,\"34\":1,\"44\":1,\"51\":1,\"75\":1,\"111\":1,\"121\":1}}],[\"html\",{\"1\":{\"0\":7}}],[\"or\",{\"1\":{\"127\":1}}],[\"org\",{\"1\":{\"0\":1,\"25\":1,\"34\":1,\"44\":1}}],[\"off\",{\"1\":{\"127\":1,\"128\":1}}],[\"ofmillis\",{\"1\":{\"82\":1}}],[\"ok\",{\"1\":{\"102\":2}}],[\"onretry\",{\"1\":{\"126\":1}}],[\"on\",{\"1\":{\"100\":1}}],[\"other\",{\"1\":{\"99\":1}}],[\"obj\",{\"1\":{\"46\":2,\"47\":2,\"48\":8,\"49\":2,\"50\":2,\"51\":6}}],[\"objectmapper\",{\"1\":{\"48\":3}}],[\"objectmapper类的实例是线程安全的\",{\"1\":{\"48\":1}}],[\"objectinputstream\",{\"1\":{\"47\":5}}],[\"objectoutputstream\",{\"1\":{\"47\":5}}],[\"object>\",{\"1\":{\"4\":2,\"10\":2,\"26\":1,\"37\":3,\"38\":1,\"39\":1,\"40\":2,\"41\":1,\"103\":2,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":1}}],[\"object\",{\"1\":{\"3\":2,\"4\":3,\"10\":1,\"19\":2,\"20\":3,\"48\":8,\"70\":4,\"102\":1,\"103\":3,\"116\":1}}],[\"optional>\",{\"1\":{\"12\":2}}],[\"openstream\",{\"1\":{\"10\":2}}],[\"output\",{\"1\":{\"49\":6}}],[\"outputstream\",{\"1\":{\"47\":3}}],[\"out\",{\"1\":{\"3\":1,\"8\":2,\"10\":2,\"20\":2,\"26\":1,\"30\":2,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"86\":1,\"100\":1,\"101\":7}}],[\"override\",{\"1\":{\"3\":1,\"4\":1,\"8\":2,\"18\":1,\"19\":1,\"20\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"47\":2,\"48\":2,\"49\":2,\"50\":2,\"51\":2,\"60\":1,\"63\":1,\"70\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":2,\"88\":1,\"100\":1,\"102\":1,\"103\":1,\"108\":3,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":1,\"125\":1,\"126\":2,\"127\":1,\"128\":1}}],[\"overview\",{\"1\":{\"0\":1,\"25\":2,\"44\":1}}],[\"ov\",{\"1\":{\"0\":1}}],[\"lambda\",{\"1\":{\"127\":1}}],[\"lang\",{\"1\":{\"4\":1}}],[\"lvs\",{\"1\":{\"111\":1}}],[\"least\",{\"1\":{\"112\":1}}],[\"leaseid\",{\"1\":{\"83\":2}}],[\"leaseclient\",{\"1\":{\"83\":2}}],[\"lease\",{\"1\":{\"83\":1}}],[\"len\",{\"1\":{\"108\":1}}],[\"length=17\",{\"1\":{\"108\":1}}],[\"length\",{\"1\":{\"10\":2,\"48\":1,\"98\":1,\"101\":1,\"108\":4}}],[\"long类型\",{\"1\":{\"98\":1}}],[\"long\",{\"1\":{\"78\":1,\"83\":1,\"96\":1,\"127\":4,\"128\":4}}],[\"log\",{\"1\":{\"10\":7,\"18\":1,\"20\":1,\"26\":9,\"38\":1,\"39\":1,\"40\":2,\"41\":2,\"70\":3,\"86\":2,\"126\":1,\"127\":2,\"128\":2}}],[\"lombok\",{\"1\":{\"10\":1,\"26\":1,\"78\":1,\"96\":3,\"127\":1,\"128\":1}}],[\"localregisternodekeyset\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"86\":1,\"87\":1}}],[\"localregistry\",{\"1\":{\"3\":1,\"19\":2,\"29\":2,\"102\":1}}],[\"local\",{\"1\":{\"49\":3}}],[\"localhost\",{\"1\":{\"3\":1,\"26\":1,\"78\":1,\"101\":1}}],[\"loadbypath\",{\"1\":{\"26\":1}}],[\"loadbalancerkeys\",{\"1\":{\"16\":3,\"25\":1,\"26\":1}}],[\"loadbalancerfactory\",{\"1\":{\"4\":1,\"103\":1}}],[\"loadbalancer\",{\"1\":{\"4\":3,\"16\":2,\"25\":1,\"26\":1,\"103\":3,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":1}}],[\"loadyaml\",{\"1\":{\"26\":4}}],[\"loadproperties\",{\"1\":{\"26\":2}}],[\"loadconfig\",{\"1\":{\"26\":7}}],[\"loadclass\",{\"1\":{\"10\":6}}],[\"loadall\",{\"1\":{\"10\":1}}],[\"loadermap\",{\"1\":{\"10\":4}}],[\"load\",{\"1\":{\"0\":2,\"8\":1,\"10\":8,\"26\":6}}],[\"ltyzzz\",{\"1\":{\"0\":1}}],[\"limit\",{\"1\":{\"122\":1}}],[\"linkedbuffer\",{\"1\":{\"51\":4}}],[\"linkedhashmap\",{\"1\":{\"48\":2}}],[\"linearretrystrategy\",{\"1\":{\"128\":1}}],[\"linear\",{\"1\":{\"122\":1}}],[\"line\",{\"1\":{\"10\":6}}],[\"listening\",{\"1\":{\"100\":1}}],[\"listen\",{\"1\":{\"100\":1}}],[\"list<keyvalue>\",{\"1\":{\"85\":1,\"87\":1}}],[\"list<serviceregisterinfo<\",{\"1\":{\"29\":2}}],[\"list<servicemetainfo>\",{\"1\":{\"4\":1,\"40\":2,\"41\":2,\"79\":1,\"85\":6,\"103\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":4,\"118\":1}}],[\"list<url>\",{\"1\":{\"10\":1}}],[\"list<class<\",{\"1\":{\"10\":1}}],[\"list\",{\"1\":{\"4\":1,\"10\":3,\"40\":2,\"41\":1,\"103\":1,\"117\":5}}],[\"li\",{\"1\":{\"0\":2}}],[\"ldbmcs\",{\"1\":{\"0\":1}}],[\"giving\",{\"1\":{\"127\":1,\"128\":1}}],[\"github\",{\"1\":{\"0\":1,\"26\":1,\"51\":1,\"70\":1,\"124\":1}}],[\"gitbook\",{\"1\":{\"0\":1}}],[\"guava\",{\"1\":{\"126\":1}}],[\"google\",{\"1\":{\"126\":1,\"127\":1,\"128\":1}}],[\"gou\",{\"1\":{\"0\":1}}],[\"grant\",{\"1\":{\"83\":1}}],[\"groupid>\",{\"1\":{\"12\":5,\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"57\":2,\"70\":1,\"124\":1}}],[\"getcurrentweight\",{\"1\":{\"118\":4}}],[\"getclass\",{\"1\":{\"19\":1,\"20\":1,\"48\":1,\"51\":1}}],[\"getclassloader\",{\"1\":{\"5\":3,\"70\":1}}],[\"getweight\",{\"1\":{\"117\":3,\"118\":3}}],[\"getwatchclient\",{\"1\":{\"88\":1}}],[\"gethash\",{\"1\":{\"116\":3}}],[\"getheader\",{\"1\":{\"98\":2,\"102\":1}}],[\"getbytes\",{\"1\":{\"99\":1,\"101\":2}}],[\"getbyte\",{\"1\":{\"99\":5}}],[\"getbodylength\",{\"1\":{\"99\":1}}],[\"getbody\",{\"1\":{\"98\":1,\"101\":1,\"102\":1,\"103\":1}}],[\"getenumbyvalue\",{\"1\":{\"101\":1}}],[\"getenumbykey\",{\"1\":{\"98\":1,\"99\":1}}],[\"getenum\",{\"1\":{\"99\":1}}],[\"geteventtype\",{\"1\":{\"88\":1}}],[\"getevents\",{\"1\":{\"88\":1}}],[\"getversion\",{\"1\":{\"98\":1}}],[\"getvalue\",{\"1\":{\"10\":1,\"85\":1,\"87\":1,\"98\":1,\"99\":1,\"102\":1,\"116\":1}}],[\"getoption\",{\"1\":{\"85\":4}}],[\"getlong\",{\"1\":{\"99\":1}}],[\"getloadbalancer\",{\"1\":{\"4\":1,\"103\":1}}],[\"getleaseclient\",{\"1\":{\"83\":1}}],[\"getkvs\",{\"1\":{\"85\":1,\"87\":1}}],[\"getkvclient\",{\"1\":{\"82\":1}}],[\"getkey\",{\"1\":{\"10\":1,\"101\":2,\"102\":1}}],[\"getsnowflakenextid\",{\"1\":{\"101\":1}}],[\"getstatus\",{\"1\":{\"98\":1}}],[\"getschema\",{\"1\":{\"51\":4}}],[\"getservicehost\",{\"1\":{\"101\":1,\"103\":1,\"108\":1}}],[\"getserviceport\",{\"1\":{\"101\":1,\"103\":1,\"108\":1}}],[\"getserviceaddress\",{\"1\":{\"77\":1,\"116\":1}}],[\"getservicenodekey\",{\"1\":{\"77\":1,\"83\":2,\"84\":1}}],[\"getservicename\",{\"1\":{\"29\":1,\"102\":1}}],[\"getservicekey\",{\"1\":{\"4\":1,\"77\":2,\"103\":1}}],[\"getserverhost\",{\"1\":{\"19\":1,\"29\":1}}],[\"getserverport\",{\"1\":{\"18\":1,\"19\":1,\"29\":2}}],[\"getserializer\",{\"1\":{\"4\":1,\"98\":2,\"99\":1,\"101\":1,\"103\":1}}],[\"getattemptnumber\",{\"1\":{\"126\":1}}],[\"getandincrement\",{\"1\":{\"115\":2,\"117\":2}}],[\"getannotation\",{\"1\":{\"19\":1,\"20\":2}}],[\"getannotationattributes\",{\"1\":{\"18\":1}}],[\"getaddress\",{\"1\":{\"82\":1}}],[\"getargs\",{\"1\":{\"48\":1,\"102\":1}}],[\"getid\",{\"1\":{\"83\":1}}],[\"getimplclass\",{\"1\":{\"29\":1}}],[\"getinfo\",{\"1\":{\"118\":1}}],[\"getint\",{\"1\":{\"99\":1,\"108\":2}}],[\"getinterfaces\",{\"1\":{\"19\":1}}],[\"getinstance\",{\"1\":{\"4\":5,\"10\":6,\"19\":1,\"26\":1,\"29\":1,\"40\":3,\"41\":1,\"86\":1,\"98\":1,\"99\":1,\"103\":5}}],[\"getjsonobject\",{\"1\":{\"26\":1}}],[\"gettimeout\",{\"1\":{\"82\":1}}],[\"gettype\",{\"1\":{\"20\":2,\"98\":1,\"99\":1}}],[\"gettolerantstrategy\",{\"1\":{\"4\":1,\"40\":1,\"103\":1}}],[\"get\",{\"1\":{\"10\":5,\"18\":1,\"40\":3,\"41\":3,\"49\":2,\"51\":1,\"61\":1,\"64\":1,\"83\":2,\"85\":2,\"86\":1,\"87\":3,\"101\":1,\"102\":1,\"103\":2,\"114\":2,\"115\":2,\"117\":1}}],[\"getmethod\",{\"1\":{\"102\":1}}],[\"getmethodname\",{\"1\":{\"4\":1,\"102\":1,\"103\":1}}],[\"getmessage\",{\"1\":{\"101\":1,\"102\":1}}],[\"getmagic\",{\"1\":{\"98\":1}}],[\"getmockproxy\",{\"1\":{\"5\":4,\"70\":2}}],[\"getproxy\",{\"1\":{\"5\":2,\"20\":2,\"30\":1}}],[\"getparametertypes\",{\"1\":{\"4\":1,\"48\":1,\"102\":1,\"103\":1}}],[\"getruntime\",{\"1\":{\"26\":1,\"86\":1}}],[\"getrequestid\",{\"1\":{\"98\":1}}],[\"getreturntype\",{\"1\":{\"70\":1,\"102\":1}}],[\"getretrystrategy\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"103\":1}}],[\"getresources\",{\"1\":{\"10\":1}}],[\"getregistry\",{\"1\":{\"4\":1,\"19\":1,\"26\":1,\"29\":1,\"86\":1,\"103\":1}}],[\"getregistryconfig\",{\"1\":{\"4\":1,\"19\":1,\"26\":1,\"29\":1,\"86\":1,\"103\":1}}],[\"getrpcconfig\",{\"1\":{\"4\":2,\"5\":1,\"18\":1,\"19\":1,\"26\":2,\"29\":2,\"40\":1,\"41\":1,\"101\":1,\"103\":2}}],[\"getdeclaredfields\",{\"1\":{\"20\":2}}],[\"getdeclaringclass\",{\"1\":{\"4\":2,\"103\":2}}],[\"getdatatype\",{\"1\":{\"48\":2}}],[\"getdata\",{\"1\":{\"3\":1,\"4\":1,\"40\":1,\"48\":2,\"103\":1}}],[\"getname\",{\"1\":{\"3\":4,\"4\":3,\"10\":7,\"18\":1,\"19\":1,\"20\":2,\"29\":1,\"30\":1,\"61\":1,\"64\":1,\"103\":3}}],[\"getnumber\",{\"1\":{\"3\":1,\"70\":1}}],[\"getuser\",{\"1\":{\"3\":5,\"30\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"70\":1}}],[\"jmockdata\",{\"1\":{\"70\":1}}],[\"jackson会将其反序列化为一个linkedhashmap对象\",{\"1\":{\"48\":1}}],[\"jackson\",{\"1\":{\"48\":2}}],[\"java对象的属性将被转换为json对象的键值对\",{\"1\":{\"48\":1}}],[\"java友好\",{\"1\":{\"44\":1}}],[\"java中spi机制主要思想是将装配的控制权移到程序之外\",{\"1\":{\"7\":1}}],[\"javaguide\",{\"1\":{\"0\":1}}],[\"java\",{\"1\":{\"0\":6,\"4\":3,\"5\":2,\"7\":2,\"10\":9,\"12\":1,\"25\":1,\"26\":1,\"44\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":3,\"50\":3,\"51\":4,\"127\":4,\"128\":2}}],[\"jsonzou<\",{\"1\":{\"70\":1}}],[\"jsonserializer\",{\"1\":{\"48\":1}}],[\"json对象的键值对将被转换为java对象的属性\",{\"1\":{\"48\":1}}],[\"json反序列化是将json字符串转换为java对象的过程\",{\"1\":{\"48\":1}}],[\"json序列化是将java对象转换为json字符串的过程\",{\"1\":{\"48\":1}}],[\"json格式的idl不够直观\",{\"1\":{\"44\":1}}],[\"jsonutil\",{\"1\":{\"26\":3,\"83\":1,\"85\":1,\"87\":1}}],[\"jsonobject\",{\"1\":{\"26\":2}}],[\"json\",{\"0\":{\"48\":1},\"1\":{\"26\":2,\"44\":2,\"48\":1}}],[\"jvm原生序列化支持\",{\"1\":{\"44\":1}}],[\"jvm\",{\"1\":{\"14\":1,\"15\":1,\"16\":1,\"26\":4,\"86\":1}}],[\"jdbc驱动程序的加载就是通过spi机制实现的\",{\"1\":{\"9\":1}}],[\"jdbc为了实现可插拔的数据库驱动\",{\"1\":{\"9\":1}}],[\"jdk动态代理\",{\"1\":{\"70\":1}}],[\"jdk原生序列化\",{\"1\":{\"44\":2}}],[\"jdk=com\",{\"1\":{\"10\":1}}],[\"jdk中查找服务的实现的工具类是\",{\"1\":{\"7\":1}}],[\"jdk\",{\"0\":{\"47\":1},\"1\":{\"4\":1,\"10\":3,\"25\":1,\"26\":1}}],[\"jdkserializer\",{\"1\":{\"3\":2,\"10\":2,\"47\":1}}],[\"jonasx\",{\"1\":{\"0\":2}}],[\"ji\",{\"1\":{\"0\":1}}],[\"jia\",{\"1\":{\"0\":1}}],[\"juejin\",{\"1\":{\"0\":1}}],[\"dns也运用到了负载均衡算法\",{\"1\":{\"111\":1}}],[\"duration\",{\"1\":{\"82\":1}}],[\"dubbo协议设计\",{\"1\":{\"94\":1}}],[\"dubbo中对序列化器的介绍\",{\"1\":{\"44\":1}}],[\"dubbo<\",{\"1\":{\"12\":1}}],[\"dubboreference\",{\"1\":{\"11\":1}}],[\"dubboservice\",{\"1\":{\"11\":1}}],[\"dubbo目录中提供实现类的配置文件\",{\"1\":{\"9\":1}}],[\"dubbo框架也使用了spi思想\",{\"1\":{\"9\":1}}],[\"dubbo框架\",{\"1\":{\"9\":1}}],[\"dubbofu\",{\"1\":{\"0\":1}}],[\"dubbo官网\",{\"1\":{\"0\":1}}],[\"dubbo\",{\"1\":{\"0\":3,\"25\":1,\"34\":2,\"44\":1,\"73\":1}}],[\"dubbo架构\",{\"1\":{\"0\":1}}],[\"dialect\",{\"1\":{\"26\":1}}],[\"dirs\",{\"1\":{\"10\":2}}],[\"dir\",{\"1\":{\"10\":5,\"26\":8}}],[\"discuss\",{\"1\":{\"0\":1}}],[\"driver接口中定义了一组标准的api规范\",{\"1\":{\"9\":1}}],[\"driver接口\",{\"1\":{\"7\":1}}],[\"do\",{\"1\":{\"127\":1}}],[\"doloadyaml\",{\"1\":{\"26\":5}}],[\"doloadproperties\",{\"1\":{\"26\":3}}],[\"dog\",{\"1\":{\"8\":2}}],[\"dotolerant\",{\"1\":{\"4\":1,\"37\":2,\"38\":3,\"39\":2,\"40\":5,\"41\":4,\"103\":1}}],[\"dorequest\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"101\":1,\"103\":2}}],[\"doretry\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"103\":1,\"124\":2,\"125\":1,\"126\":2,\"127\":4,\"128\":1}}],[\"dostart\",{\"1\":{\"3\":1,\"18\":1,\"29\":2,\"100\":2}}],[\"dong\",{\"1\":{\"0\":1}}],[\"datagram\",{\"1\":{\"90\":1}}],[\"data字段实际上被反序列化为一个linkedhashmap对象\",{\"1\":{\"48\":1}}],[\"databind\",{\"1\":{\"48\":1}}],[\"databind<\",{\"1\":{\"48\":1}}],[\"data\",{\"1\":{\"26\":1,\"29\":1,\"51\":3,\"77\":1,\"78\":2,\"96\":3,\"101\":2,\"118\":1}}],[\"dai\",{\"1\":{\"0\":1}}],[\"daraw\",{\"1\":{\"0\":1}}],[\"decode\",{\"1\":{\"99\":1,\"101\":1,\"102\":2}}],[\"declaredfields\",{\"1\":{\"20\":3}}],[\"delete\",{\"1\":{\"84\":1,\"86\":1,\"88\":1}}],[\"dee\",{\"1\":{\"76\":1}}],[\"destroy\",{\"1\":{\"26\":1,\"79\":1,\"86\":2}}],[\"deserialize\",{\"1\":{\"3\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"99\":2}}],[\"dependencies>\",{\"1\":{\"12\":1,\"57\":1}}],[\"dependency>\",{\"1\":{\"12\":5,\"26\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":2,\"57\":2,\"70\":1,\"124\":1}}],[\"demo\",{\"0\":{\"8\":1}}],[\"defaultresponse\",{\"1\":{\"39\":4}}],[\"default\",{\"1\":{\"4\":1,\"14\":2,\"15\":7,\"16\":15,\"21\":1,\"26\":3,\"51\":1,\"77\":1,\"88\":1,\"99\":1,\"103\":1}}],[\"details\",{\"1\":{\"0\":2,\"121\":1}}],[\"de\",{\"1\":{\"0\":2}}],[\"1了\",{\"1\":{\"108\":1}}],[\"17\",{\"1\":{\"99\":2}}],[\"13\",{\"1\":{\"99\":1,\"108\":2}}],[\"132053496\",{\"1\":{\"0\":1}}],[\"1个字节\",{\"1\":{\"98\":5}}],[\"1<\",{\"1\":{\"48\":1}}],[\"118639448\",{\"1\":{\"0\":1}}],[\"18884633\",{\"1\":{\"0\":1}}],[\"121451100\",{\"1\":{\"121\":1}}],[\"12\",{\"1\":{\"0\":1}}],[\"14371290\",{\"1\":{\"0\":1}}],[\"16\",{\"1\":{\"0\":1,\"48\":1}}],[\"10\",{\"1\":{\"87\":1,\"118\":7}}],[\"100\",{\"1\":{\"116\":1,\"127\":2}}],[\"1000\",{\"1\":{\"101\":1,\"128\":1}}],[\"10000l\",{\"1\":{\"78\":1}}],[\"100s续约一次\",{\"1\":{\"87\":1}}],[\"10分钟带你彻底搞懂rpc架构\",{\"1\":{\"0\":1}}],[\"10794078\",{\"1\":{\"0\":1}}],[\"10138756\",{\"1\":{\"0\":1}}],[\"1\",{\"1\":{\"0\":1,\"10\":2,\"26\":1,\"57\":1,\"77\":2,\"99\":1,\"108\":6,\"114\":1,\"115\":2,\"118\":5,\"122\":2,\"128\":2}}],[\"circuit\",{\"1\":{\"122\":1}}],[\"c=2\",{\"1\":{\"118\":1}}],[\"c放5个\",{\"1\":{\"117\":1}}],[\"c\",{\"1\":{\"117\":1,\"118\":5}}],[\"ceilingentry\",{\"1\":{\"116\":1}}],[\"createunstarted\",{\"1\":{\"127\":1,\"128\":1}}],[\"createnetclient\",{\"1\":{\"101\":2}}],[\"createnetserver\",{\"1\":{\"100\":1}}],[\"cronutil\",{\"1\":{\"87\":3}}],[\"cause\",{\"1\":{\"101\":1}}],[\"caucho\",{\"1\":{\"50\":2}}],[\"caucho<\",{\"1\":{\"50\":1}}],[\"callable<v>\",{\"1\":{\"127\":1}}],[\"callable<rpcresponse>\",{\"1\":{\"124\":2,\"125\":1,\"126\":1,\"127\":2,\"128\":1}}],[\"callable\",{\"1\":{\"124\":4,\"125\":3,\"126\":5,\"127\":15,\"128\":3}}],[\"call\",{\"1\":{\"90\":1,\"125\":1,\"126\":2,\"127\":12,\"128\":2}}],[\"case\",{\"1\":{\"88\":2,\"99\":4}}],[\"cast\",{\"1\":{\"48\":2}}],[\"cat\",{\"1\":{\"8\":2}}],[\"catch\",{\"1\":{\"3\":1,\"4\":1,\"10\":3,\"19\":1,\"20\":1,\"26\":7,\"29\":1,\"40\":2,\"41\":1,\"47\":1,\"85\":1,\"86\":1,\"87\":1,\"101\":2,\"102\":3,\"103\":1,\"127\":1,\"128\":1}}],[\"category\",{\"1\":{\"0\":2}}],[\"client\",{\"1\":{\"81\":2,\"82\":3,\"83\":1,\"86\":2,\"88\":1}}],[\"cloud\",{\"1\":{\"73\":1}}],[\"close\",{\"1\":{\"47\":2,\"49\":2,\"86\":2,\"101\":1}}],[\"clearcache\",{\"1\":{\"85\":1,\"88\":1}}],[\"clear\",{\"1\":{\"51\":1}}],[\"clazz\",{\"1\":{\"26\":29,\"46\":2,\"47\":1,\"48\":7,\"49\":2,\"50\":2,\"51\":8}}],[\"classnotfoundexception\",{\"1\":{\"47\":1}}],[\"classname为\",{\"1\":{\"10\":1}}],[\"classname=\",{\"1\":{\"10\":1}}],[\"classname\",{\"1\":{\"10\":10}}],[\"classpath\",{\"1\":{\"26\":4}}],[\"classmap\",{\"1\":{\"10\":2}}],[\"class<\",{\"1\":{\"10\":12,\"15\":2,\"16\":2,\"19\":2,\"20\":2,\"29\":2,\"48\":2,\"70\":1,\"102\":1}}],[\"class<t>\",{\"1\":{\"5\":4,\"26\":7,\"46\":1,\"47\":1,\"48\":3,\"49\":1,\"50\":1,\"51\":4,\"70\":1}}],[\"class\",{\"1\":{\"3\":13,\"4\":1,\"5\":4,\"8\":3,\"10\":22,\"14\":6,\"15\":3,\"16\":3,\"18\":2,\"19\":4,\"20\":4,\"21\":3,\"26\":7,\"29\":5,\"30\":3,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"65\":4,\"66\":1,\"70\":5,\"77\":1,\"78\":1,\"85\":2,\"86\":1,\"87\":1,\"96\":2,\"98\":1,\"99\":3,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"108\":3,\"114\":1,\"115\":1,\"116\":1,\"117\":2,\"118\":2,\"125\":1,\"126\":3,\"127\":1,\"128\":1}}],[\"cxk\",{\"1\":{\"30\":1,\"105\":6}}],[\"currweight\",{\"1\":{\"118\":2}}],[\"currweight+=weight\",{\"1\":{\"118\":1}}],[\"currweight=\",{\"1\":{\"118\":1}}],[\"currentweightmap\",{\"1\":{\"118\":5}}],[\"currentweight\",{\"1\":{\"118\":2}}],[\"currentindex\",{\"1\":{\"115\":3,\"117\":2}}],[\"current\",{\"1\":{\"4\":1,\"40\":2,\"41\":1,\"103\":1,\"127\":1,\"128\":1}}],[\"curl\",{\"1\":{\"69\":1}}],[\"custom\",{\"1\":{\"10\":6}}],[\"cglib\",{\"1\":{\"4\":1}}],[\"cookie等\",{\"1\":{\"111\":1}}],[\"collectors\",{\"1\":{\"85\":1}}],[\"collect\",{\"1\":{\"85\":1}}],[\"collutil\",{\"1\":{\"4\":1,\"85\":1,\"87\":1,\"103\":1}}],[\"coreos\",{\"1\":{\"73\":1}}],[\"coreconsumerexample\",{\"1\":{\"30\":1}}],[\"coreproviderexample\",{\"1\":{\"29\":1}}],[\"core<\",{\"1\":{\"12\":1,\"48\":1,\"51\":1}}],[\"core\",{\"1\":{\"10\":1,\"26\":2}}],[\"consistenthashloadbalancer\",{\"1\":{\"116\":1}}],[\"consistent\",{\"1\":{\"112\":1}}],[\"consul\",{\"1\":{\"73\":1}}],[\"consumer模块\",{\"0\":{\"61\":1}}],[\"consumerbootstrap\",{\"1\":{\"30\":2}}],[\"consumer\",{\"1\":{\"28\":2,\"56\":1,\"61\":1,\"64\":2}}],[\"consumer通过静态代理调用\",{\"1\":{\"3\":1}}],[\"connections\",{\"1\":{\"112\":1}}],[\"connected\",{\"1\":{\"101\":2}}],[\"connect\",{\"1\":{\"101\":4,\"103\":1,\"108\":1}}],[\"connecthandler\",{\"1\":{\"100\":2}}],[\"connecttimeout\",{\"1\":{\"82\":1}}],[\"conffilepath\",{\"1\":{\"26\":4}}],[\"conf\",{\"1\":{\"26\":27}}],[\"configfilebuilder\",{\"1\":{\"26\":8}}],[\"configutils\",{\"1\":{\"26\":5}}],[\"configuration\",{\"1\":{\"12\":2}}],[\"config\",{\"1\":{\"25\":1,\"26\":7,\"78\":1,\"86\":2}}],[\"control\",{\"1\":{\"90\":1}}],[\"contains\",{\"1\":{\"77\":1}}],[\"containskey\",{\"1\":{\"10\":3}}],[\"continue\",{\"1\":{\"10\":2,\"40\":1,\"41\":1,\"87\":1}}],[\"context\",{\"1\":{\"4\":5,\"37\":4,\"38\":2,\"39\":2,\"40\":10,\"41\":5,\"103\":5}}],[\"concurrenthashset<>\",{\"1\":{\"81\":1}}],[\"concurrenthashmap<class<\",{\"1\":{\"51\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"10\":4}}],[\"concurrenthashmap\",{\"1\":{\"10\":1,\"51\":1}}],[\"concurrent\",{\"1\":{\"10\":1,\"51\":1,\"127\":2,\"128\":2}}],[\"codefather\",{\"1\":{\"0\":1}}],[\"compute\",{\"1\":{\"127\":1}}],[\"computed\",{\"1\":{\"127\":1}}],[\"computes\",{\"1\":{\"127\":1}}],[\"complete\",{\"1\":{\"101\":1,\"103\":1}}],[\"completablefuture<>\",{\"1\":{\"101\":1,\"103\":1}}],[\"completablefuture<rpcresponse>\",{\"1\":{\"101\":1,\"103\":1}}],[\"component\",{\"1\":{\"9\":1,\"15\":2}}],[\"common<\",{\"1\":{\"57\":1}}],[\"common模块\",{\"0\":{\"59\":1},\"1\":{\"56\":1}}],[\"common\",{\"1\":{\"26\":6,\"127\":1,\"128\":1}}],[\"com\",{\"1\":{\"0\":11,\"10\":3,\"26\":1,\"48\":3,\"49\":3,\"50\":2,\"51\":2,\"78\":2,\"96\":1,\"127\":1,\"128\":1}}],[\"csdn\",{\"1\":{\"0\":4,\"121\":1}}],[\"cn\",{\"1\":{\"0\":6,\"10\":1,\"25\":2,\"26\":6,\"34\":2,\"44\":2}}],[\"cnblogs\",{\"1\":{\"0\":2}}],[\"chenchuxin\",{\"1\":{\"0\":1}}],[\"框架自身实现\",{\"1\":{\"110\":1}}],[\"框架实现的\",{\"1\":{\"29\":1}}],[\"框架配置\",{\"1\":{\"24\":1}}],[\"框架的核心组件\",{\"1\":{\"73\":1}}],[\"框架的核心入口点\",{\"1\":{\"26\":1}}],[\"框架的入口和全局配置管理器\",{\"1\":{\"25\":1}}],[\"框架的名称和版本号\",{\"1\":{\"25\":1}}],[\"框架的全局配置类\",{\"1\":{\"25\":1}}],[\"框架的配置管理和初始化过程是统一和可靠的\",{\"1\":{\"26\":1}}],[\"框架的配置\",{\"1\":{\"24\":1}}],[\"框架的初始化和服务端启动逻辑\",{\"1\":{\"18\":1}}],[\"框架需要能够从配置文件中读取配置信息\",{\"1\":{\"24\":1}}],[\"框架需要被其他项目引入使用\",{\"1\":{\"24\":1}}],[\"框架需要涉及很多配置信息\",{\"1\":{\"24\":1}}],[\"框架时需要引入全局配置加载的功能主要有以下几个原因\",{\"1\":{\"24\":1}}],[\"框架在\",{\"1\":{\"18\":1}}],[\"框架中非常重要的一个组件\",{\"1\":{\"72\":1}}],[\"框架中的各种重要配置项集中在一起\",{\"1\":{\"25\":1}}],[\"框架中很多重要的配置项\",{\"1\":{\"25\":1}}],[\"框架中\",{\"1\":{\"2\":1,\"4\":1,\"73\":1,\"110\":1}}],[\"框架之总体设计与扩展机制\",{\"1\":{\"0\":1}}],[\"框架\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
